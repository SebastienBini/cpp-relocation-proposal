<!doctype html><html lang="en">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport">
  <title>P2785R4: Relocating prvalues</title>
<style data-fill-with="stylesheet">/******************************************************************************
 *                   Style sheet for the W3C specifications                   *
 *
 * Special classes handled by this style sheet include:
 *
 * Indices
 *   - .toc for the Table of Contents (<ol class="toc">)
 *     + <span class="secno"> for the section numbers
 *   - #toc for the Table of Contents (<nav id="toc">)
 *   - ul.index for Indices (<a href="#ref">term</a><span>, in § N.M</span>)
 *   - table.index for Index Tables (e.g. for properties or elements)
 *
 * Structural Markup
 *   - table.data for general data tables
 *     -> use 'scope' attribute, <colgroup>, <thead>, and <tbody> for best results !
 *     -> use <table class='complex data'> for extra-complex tables
 *     -> use <td class='long'> for paragraph-length cell content
 *     -> use <td class='pre'> when manual line breaks/indentation would help readability
 *   - dl.switch for switch statements
 *   - ol.algorithm for algorithms (helps to visualize nesting)
 *   - .figure and .caption (HTML4) and figure and figcaption (HTML5)
 *     -> .sidefigure for right-floated figures
 *   - ins/del
 *     -> ins/del.c### for candidate and proposed changes (amendments)
 *
 * Code
 *   - pre and code
 *
 * Special Sections
 *   - .note       for informative notes             (div, p, span, aside, details)
 *   - .example    for informative examples          (div, p, pre, span)
 *   - .issue      for issues                        (div, p, span)
 *   - .advisement for loud normative statements     (div, p, strong)
 *   - .annoying-warning for spec obsoletion notices (div, aside, details)
 *   - .correction for "candidate corrections"       (div, aside, details, section)
 *   - .addition   for "candidate additions"         (div, aside, details, section)
 *   - .correction.proposed for "proposed corrections" (div, aside, details, section)
 *   - .addition.proposed   for "proposed additions"   (div, aside, details, section)
 *
 * Definition Boxes
 *   - pre.def   for WebIDL definitions
 *   - table.def for tables that define other entities (e.g. CSS properties)
 *   - dl.def    for definition lists that define other entitles (e.g. HTML elements)
 *
 * Numbering
 *   - .secno for section numbers in .toc and headings (<span class='secno'>3.2</span>)
 *   - .marker for source-inserted example/figure/issue numbers (<span class='marker'>Issue 4</span>)
 *   - ::before styled for CSS-generated issue/example/figure numbers:
 *     -> Documents wishing to use this only need to add
 *        figcaption::before,
 *        .caption::before { content: "Figure "  counter(figure) " ";  }
 *        .example::before { content: "Example " counter(example) " "; }
 *        .issue::before   { content: "Issue "   counter(issue) " ";   }
 *
 * Header Stuff (ignore, just don't conflict with these classes)
 *   - .head for the header
 *   - .copyright for the copyright
 *
 * Outdated warning for old specs
 *
 * Miscellaneous
 *   - .overlarge for things that should be as wide as possible, even if
 *     that overflows the body text area. This can be used on an item or
 *     on its container, depending on the effect desired.
 *     Note that this styling basically doesn't help at all when printing,
 *     since A4 paper isn't much wider than the max-width here.
 *     It's better to design things to fit into a narrower measure if possible.
 *
 *   - js-added ToC jump links (see fixup.js)
 *
 ******************************************************************************/

/* color variables included separately for reliability */

/******************************************************************************/
/*                                    Body                                    */
/******************************************************************************/

	html {
	}

	body {
		counter-reset: example figure issue;

		/* Layout */
		max-width: 50em;			  /* limit line length to 50em for readability   */
		margin: 0 auto;				/* center text within page                    */
		padding: 1.6em 1.5em 2em 50px; /* assume 16px font size for downlevel clients */
		padding: 1.6em 1.5em 2em calc(26px + 1.5em); /* leave space for status flag    */

		/* Typography */
		line-height: 1.5;
		font-family: sans-serif;
		widows: 2;
		orphans: 2;
		word-wrap: break-word;
		overflow-wrap: break-word;
		hyphens: auto;

		color: black;
		color: var(--text);
		background: white top left fixed no-repeat;
		background: var(--bg) top left fixed no-repeat;
		background-size: 25px auto;
	}


/******************************************************************************/
/*                         Front Matter & Navigation                          */
/******************************************************************************/

/** Header ********************************************************************/

	div.head { margin-bottom: 1em; }
	div.head hr { border-style: solid; }

	div.head h1 {
		font-weight: bold;
		margin: 0 0 .1em;
		font-size: 220%;
	}

	div.head h2 { margin-bottom: 1.5em;}

/** W3C Logo ******************************************************************/

	.head .logo {
		float: right;
		margin: 0.4rem 0 0.2rem .4rem;
	}

	.head img[src*="logos/W3C"] {
		display: block;
		border: solid #1a5e9a;
		border: solid var(--logo-bg);
		border-width: .65rem .7rem .6rem;
		border-radius: .4rem;
		background: #1a5e9a;
		background: var(--logo-bg);
		color: white;
		color: var(--logo-text);
		font-weight: bold;
	}

	.head a:hover > img[src*="logos/W3C"],
	.head a:focus > img[src*="logos/W3C"] {
		opacity: .8;
	}

	.head a:active > img[src*="logos/W3C"] {
		background: #c00;
		background: var(--logo-active-bg);
		border-color: #c00;
		border-color: var(--logo-active-bg);
	}

	/* see also additional rules in Link Styling section */

/** Copyright *****************************************************************/

	p.copyright,
	p.copyright small { font-size: small; }

/** Back to Top / ToC Toggle **************************************************/

	@media print {
		#toc-nav {
			display: none;
		}
	}
	@media not print {
		#toc-nav {
			position: fixed;
			z-index: 3;
			bottom: 0; left: 0;
			margin: 0;
			min-width: 1.33em;
			border-top-right-radius: 2rem;
			box-shadow: 0 0 2px;
			font-size: 1.5em;
		}
		#toc-nav > a {
			display: block;
			white-space: nowrap;

			height: 1.33em;
			padding: .1em 0.3em;
			margin: 0;

			box-shadow: 0 0 2px;
			border: none;
			border-top-right-radius: 1.33em;

			color: #707070;
			color: var(--tocnav-normal-text);
			background: white;
			background: var(--tocnav-normal-bg);
		}
		#toc-nav > a:hover,
		#toc-nav > a:focus {
			color: black;
			color: var(--tocnav-hover-text);
			background: #f8f8f8;
			background: var(--tocnav-hover-bg);
		}
		#toc-nav > a:active {
			color: #c00;
			color: var(--tocnav-active-text);
			background: white;
			background: var(--tocnav-active-bg);
		}

		#toc-nav > #toc-jump {
			padding-bottom: 2em;
			margin-bottom: -1.9em;
		}

		/* statusbar gets in the way on keyboard focus; remove once browsers fix */
		#toc-nav > a[href="#toc"]:not(:hover):focus:last-child {
			padding-bottom: 1.5rem;
		}

		#toc-nav:not(:hover) > a:not(:focus) > span + span {
			/* Ideally this uses :focus-within on #toc-nav */
			display: none;
		}
		#toc-nav > a > span + span {
			padding-right: 0.2em;
		}
	}

/** ToC Sidebar ***************************************************************/

	/* Floating sidebar */
	@media screen {
		body.toc-sidebar #toc {
			position: fixed;
			top: 0; bottom: 0;
			left: 0;
			width: 23.5em;
			max-width: 80%;
			max-width: calc(100% - 2em - 26px);
			overflow: auto;
			padding: 0 1em;
			padding-left: 42px;
			padding-left: calc(1em + 26px);
			color: black;
			color: var(--tocsidebar-text);
			background: inherit;
			background-color: #f7f8f9;
			background-color: var(--tocsidebar-bg);
			z-index: 1;
			box-shadow: -.1em 0 .25em rgba(0,0,0,.1) inset;
			box-shadow: -.1em 0 .25em var(--tocsidebar-shadow) inset;
		}
		body.toc-sidebar #toc h2 {
			margin-top: .8rem;
			font-variant: small-caps;
			font-variant: all-small-caps;
			text-transform: lowercase;
			font-weight: bold;
			color: gray;
			color: hsla(203,20%,40%,.7);
			color: var(--tocsidebar-heading-text);
		}
		body.toc-sidebar #toc-jump:not(:focus) {
			width: 0;
			height: 0;
			padding: 0;
			position: absolute;
			overflow: hidden;
		}
	}
	/* Hide main scroller when only the ToC is visible anyway */
	@media screen and (max-width: 28em) {
		body.toc-sidebar {
			overflow: hidden;
		}
	}

	/* Sidebar with its own space */
	@media screen and (min-width: 78em) {
		body:not(.toc-inline) #toc {
			position: fixed;
			top: 0; bottom: 0;
			left: 0;
			width: 23.5em;
			overflow: auto;
			padding: 0 1em;
			padding-left: 42px;
			padding-left: calc(1em + 26px);
			color: black;
			color: var(--tocsidebar-text);
			background: inherit;
			background-color: #f7f8f9;
			background-color: var(--tocsidebar-bg);
			z-index: 1;
			box-shadow: -.1em 0 .25em rgba(0,0,0,.1) inset;
			box-shadow: -.1em 0 .25em var(--tocsidebar-shadow) inset;
		}
		body:not(.toc-inline) #toc h2 {
			margin-top: .8rem;
			font-variant: small-caps;
			font-variant: all-small-caps;
			text-transform: lowercase;
			font-weight: bold;
			color: gray;
			color: hsla(203,20%,40%,.7);
			color: var(--tocsidebar-heading-text);
		}

		body:not(.toc-inline) {
			padding-left: 29em;
		}
		/* See also Overflow section at the bottom */

		body:not(.toc-inline) #toc-jump:not(:focus) {
			width: 0;
			height: 0;
			padding: 0;
			position: absolute;
			overflow: hidden;
		}
	}
	@media screen and (min-width: 90em) {
		body:not(.toc-inline) {
			margin: 0 4em;
		}
	}

/******************************************************************************/
/*                                Sectioning                                  */
/******************************************************************************/

/** Headings ******************************************************************/

	h1, h2, h3, h4, h5, h6, dt {
		page-break-after: avoid;
		page-break-inside: avoid;
		font: 100% sans-serif;   /* Reset all font styling to clear out UA styles */
		font-family: inherit;	/* Inherit the font family. */
		line-height: 1.2;		/* Keep wrapped headings compact */
		hyphens: manual;		/* Hyphenated headings look weird */
	}

	h2, h3, h4, h5, h6 {
		margin-top: 3rem;
	}

	h1, h2, h3 {
		color: #005A9C;
		color: var(--heading-text);
	}

	h1 { font-size: 170%; }
	h2 { font-size: 140%; }
	h3 { font-size: 120%; }
	h4 { font-weight: bold; }
	h5 { font-style: italic; }
	h6 { font-variant: small-caps; }
	dt { font-weight: bold; }

/** Subheadings ***************************************************************/

	h1 + h2,
	#profile-and-date {
		/* #profile-and-date is a subtitle in an H2 under the H1 */
		margin-top: 0;
	}
	h2 + h3,
	h3 + h4,
	h4 + h5,
	h5 + h6 {
		margin-top: 1.2em; /* = 1 x line-height */
	}

/** Section divider ***********************************************************/

	:not(.head) > :not(.head) + hr {
		font-size: 1.5em;
		text-align: center;
		margin: 1em auto;
		height: auto;
		color: black;
		color: var(--hr-text);
		border: transparent solid 0;
		background: transparent;
	}
	:not(.head) > hr::before {
		content: "\2727\2003\2003\2727\2003\2003\2727";
	}

/******************************************************************************/
/*                            Paragraphs and Lists                            */
/******************************************************************************/

	p {
		margin: 1em 0;
	}

	dd > p:first-child,
	li > p:first-child {
		margin-top: 0;
	}

	ul, ol {
		margin-left: 0;
		padding-left: 2em;
	}

	li {
		margin: 0.25em 0 0.5em;
		padding: 0;
	}

	dl dd {
		margin: 0 0 .5em 2em;
	}

	.head dd + dd { /* compact for header */
		margin-top: -.5em;
	}

	/* Style for algorithms */
	ol.algorithm ol:not(.algorithm),
	.algorithm > ol ol:not(.algorithm) {
	border-left: 0.5em solid #DEF;
	border-left: 0.5em solid var(--algo-border);
	}

	/* Put nice boxes around each algorithm. */
	[data-algorithm]:not(.heading) {
	 padding: .5em;
	 border: thin solid #ddd;
	 border: thin solid var(--algo-border);
	 border-radius: .5em;
	 margin: .5em calc(-0.5em - 1px);
	}
	[data-algorithm]:not(.heading) > :first-child {
	 margin-top: 0;
	}
	[data-algorithm]:not(.heading) > :last-child {
	 margin-bottom: 0;
	}

	/* Style for switch/case <dl>s */
	dl.switch > dd > ol.only,
	dl.switch > dd > .only > ol {
	margin-left: 0;
	}
	dl.switch > dd > ol.algorithm,
	dl.switch > dd > .algorithm > ol {
	margin-left: -2em;
	}
	dl.switch {
	padding-left: 2em;
	}
	dl.switch > dt {
	text-indent: -1.5em;
	margin-top: 1em;
	}
	dl.switch > dt + dt {
	margin-top: 0;
	}
	dl.switch > dt::before {
	content: '\21AA';
	padding: 0 0.5em 0 0;
	display: inline-block;
	width: 1em;
	text-align: right;
	line-height: 0.5em;
	}

/** Terminology Markup ********************************************************/


/******************************************************************************/
/*                                 Inline Markup                              */
/******************************************************************************/

/** Terminology Markup ********************************************************/
	dfn   { /* Defining instance */
		font-weight: bolder;
	}
	a > i { /* Instance of term */
		font-style: normal;
	}
	dt dfn code, code.idl {
		font-size: inherit;
	}
	dfn var {
		font-style: normal;
	}

/** Change Marking ************************************************************/

	del {
		color: #aa0000;
		color: var(--del-text);
		background: transparent;
		background: var(--del-bg);
		text-decoration: line-through;
	}
	ins {
		color: #006100;
		color: var(--ins-text);
		background: transparent;
		background: var(--ins-bg);
		text-decoration: underline;
	}

	/* for amendments (candidate/proposed changes) */

	.amendment ins, .correction ins, .addition ins,
	ins[class^=c] {
		text-decoration-style: dotted;
	}
	.amendment del, .correction del, .addition del,
	del[class^=c] {
		text-decoration-style: dotted;
	}
	.amendment.proposed ins, .correction.proposed ins, .addition.proposed ins,
	ins[class^=c].proposed {
		text-decoration-style: double;
	}
	.amendment.proposed del, .correction.proposed del, .addition.proposed del,
	del[class^=c].proposed {
		text-decoration-style: double;
	}

/** Miscellaneous improvements to inline formatting ***************************/

	sup {
		vertical-align: super;
		font-size: 80%
	}

/******************************************************************************/
/*                                    Code                                    */
/******************************************************************************/

/** General monospace/pre rules ***********************************************/

	pre, code, samp {
		font-family: Menlo, Consolas, "DejaVu Sans Mono", Monaco, monospace;
		font-size: .9em;
		hyphens: none;
		text-transform: none;
		text-align: left;
		text-align: start;
		font-variant: normal;
		orphans: 3;
		widows: 3;
		page-break-before: avoid;
	}
	pre code,
	code code {
		font-size: 100%;
	}

	pre {
		margin-top: 1em;
		margin-bottom: 1em;
		overflow: auto;
	}

/** Inline Code fragments *****************************************************/

	/* Do something nice. */

/******************************************************************************/
/*                                    Links                                   */
/******************************************************************************/

/** General Hyperlinks ********************************************************/

	/* We hyperlink a lot, so make it less intrusive */
	a[href] {
		color: #034575;
		color: var(--a-normal-text);
		text-decoration: underline #707070;
		text-decoration: underline var(--a-normal-underline);
		text-decoration-skip-ink: none;
	}
	a:visited {
		color: #034575;
		color: var(--a-visited-text);
		text-decoration-color: #bbb;
		text-decoration-color: var(--a-visited-underline);
	}

	/* Indicate interaction with the link */
	a[href]:focus,
	a[href]:hover {
		text-decoration-thickness: 2px;
	}
	a[href]:active {
		color: #c00;
		color: var(--a-active-text);
		text-decoration-color: #c00;
		text-decoration-color: var(--a-active-underline);
	}

	/* Backout above styling for W3C logo */
	.head .logo,
	.head .logo a {
		border: none;
		text-decoration: none;
		background: transparent;
	}

/******************************************************************************/
/*                                    Images                                  */
/******************************************************************************/

	img {
		border-style: none;
	}

	img, svg {
		/* Intentionally not color-scheme aware. */
		background: white;
	}

	/* For autogen numbers, add
	  .caption::before, figcaption::before { content: "Figure " counter(figure) ". "; }
	*/

	figure, .figure, .sidefigure {
		page-break-inside: avoid;
		text-align: center;
		margin: 2.5em 0;
	}
	.figure img,	.sidefigure img,	figure img,
	.figure object, .sidefigure object, figure object {
		max-width: 100%;
		margin: auto;
		height: auto;
	}
	.figure pre, .sidefigure pre, figure pre {
		text-align: left;
		display: table;
		margin: 1em auto;
	}
	.figure table, figure table {
		margin: auto;
	}
	@media screen and (min-width: 20em) {
		.sidefigure {
			float: right;
			width: 50%;
			margin: 0 0 0.5em 0.5em;
		}
	}
	.caption, figcaption, caption {
		font-style: italic;
		font-size: 90%;
	}
	.caption::before, figcaption::before, figcaption > .marker {
		font-weight: bold;
	}
	.caption, figcaption {
		counter-increment: figure;
	}

	/* DL list is indented 2em, but figure inside it is not */
	dd > .figure, dd > figure { margin-left: -2em; }

/******************************************************************************/
/*                             Colored Boxes                                  */
/******************************************************************************/

	.issue, .note, .example, .assertion, .advisement, blockquote,
	.amendment, .correction, .addition {
		margin: 1em auto;
		padding: .5em;
		border: .5em;
		border-left-style: solid;
		page-break-inside: avoid;
	}
	span.issue, span.note {
		padding: .1em .5em .15em;
		border-right-style: solid;
	}

	blockquote > :first-child,
	.note  > p:first-child,
	.issue > p:first-child,
	.amendment > p:first-child,
	.correction > p:first-child,
	.addition > p:first-child {
		margin-top: 0;
	}
	blockquote > :last-child,
	.note  > p:last-child,
	.issue > p:last-child,
	.amendment > p:last-child,
	.correction > p:last-child,
	.addition > p:last-child {
		margin-bottom: 0;
	}


	.issue::before, .issue > .marker,
	.example::before, .example > .marker,
	.note::before, .note > .marker,
	details.note > summary > .marker,
	.amendment::before, .amendment > .marker,
	details.amendment > summary > .marker,
	.addition::before, .addition > .marker,
	addition.amendment > summary > .marker,
	.correction::before, .correction > .marker,
	correction.amendment > summary > .marker
	{
		text-transform: uppercase;
		padding-right: 1em;
	}

	.example::before, .example > .marker {
		display: block;
		padding-right: 0em;
	}

/** Blockquotes ***************************************************************/

	blockquote {
		border-color: silver;
		border-color: var(--blockquote-border);
		background: transparent;
		background: var(--blockquote-bg);
		color: currentcolor;
		color: var(--blockquote-text);
	}

/** Open issue ****************************************************************/

	.issue {
		border-color: #e05252;
		border-color: var(--issue-border);
		background: #fbe9e9;
		background: var(--issue-bg);
		color: black;
		color: var(--issue-text);
		counter-increment: issue;
		overflow: auto;
	}
	.issue::before, .issue > .marker {
		color: #831616;
		color: var(--issueheading-text);
	}
	/* Add .issue::before { content: "Issue " counter(issue) " "; } for autogen numbers,
	  or use class="marker" to mark up the issue number in source. */

/** Example *******************************************************************/

	.example {
		border-color: #e0cb52;
		border-color: var(--example-border);
		background: #fcfaee;
		background: var(--example-bg);
		color: black;
		color: var(--example-text);
		counter-increment: example;
		overflow: auto;
		clear: both;
	}
	.example::before, .example > .marker {
		color: #574b0f;
		color: var(--exampleheading-text);
	}
	/* Add .example::before { content: "Example " counter(example) " "; } for autogen numbers,
	  or use class="marker" to mark up the example number in source. */

/** Non-normative Note ********************************************************/

	.note {
		border-color: #52e052;
		border-color: var(--note-border);
		background: #e9fbe9;
		background: var(--note-bg);
		color: black;
		color: var(--note-text);
		overflow: auto;
	}

	.note::before, .note > .marker,
	details.note > summary {
		color: hsl(120, 70%, 30%);
		color: var(--noteheading-text);
	}
	/* Add .note::before { content: "Note "; } for autogen label,
	  or use class="marker" to mark up the label in source. */

	details.note[open] > summary {
		border-bottom: 1px silver solid;
		border-bottom: 1px var(--notesummary-underline) solid;
	}

/** Assertion Box *************************************************************/
	/*  for assertions in algorithms */

	.assertion {
		border-color: #AAA;
		border-color: var(--assertion-border);
		background: #EEE;
		background: var(--assertion-bg);
		color: black;
		color: var(--assertion-text);
	}

/** Advisement Box ************************************************************/
	/*  for attention-grabbing normative statements */

	.advisement {
		border-color: orange;
		border-color: var(--advisement-border);
		border-style: none solid;
		background: #fec;
		background: var(--advisement-bg);
		color: black;
		color: var(--advisement-text);
	}
	strong.advisement {
		display: block;
		text-align: center;
	}
	.advisement::before, .advisement > .marker {
		color: #b35f00;
		color: var(--advisementheading-text);
	}

/** Amendment Box *************************************************************/

	.amendment, .correction, .addition {
		border-color: #330099;
		border-color: var(--amendment-border);
		background: #F5F0FF;
		background: var(--amendment-bg);
		color: black;
		color: var(--amendment-text);
	}
	.amendment.proposed, .correction.proposed, .addition.proposed {
		border-style: solid;
		border-block-width: 0.25em;
	}
	.amendment::before, .amendment > .marker,
	details.amendment > summary::before, details.amendment > summary > .marker,
	.correction::before, .correction > .marker,
	details.correction > summary::before, details.correction > summary > .marker,
	.addition::before, .addition > .marker,
	details.addition > summary::before, details.addition > summary > .marker {
		color: #220066;
		color: var(--amendmentheading-text);
	}
	.amendment.proposed::before, .amendment.proposed > .marker,
	details.amendment.proposed > summary::before, details.amendment.proposed > summary > .marker,
	.correction.proposed::before, .correction.proposed > .marker,
	details.correction.proposed > summary::before, details.correction.proposed > summary > .marker,
	.addition.proposed::before, .addition.proposed > .marker,
	details.addition.proposed > summary::before, details.addition.proposed > summary > .marker {
		font-weight: bold;
	}

/** Spec Obsoletion Notice ****************************************************/
	/* obnoxious obsoletion notice for older/abandoned specs. */

	details {
		display: block;
	}
	summary {
		font-weight: bolder;
	}

	.annoying-warning:not(details),
	details.annoying-warning:not([open]) > summary,
	details.annoying-warning[open] {
		background: hsla(40,100%,50%,0.95);
		background: var(--warning-bg);
		color: black;
		color: var(--warning-text);
		padding: .75em 1em;
		border: red;
		border: var(--warning-border);
		border-style: solid none;
		box-shadow: 0 2px 8px black;
		text-align: center;
	}
	.annoying-warning :last-child {
		margin-bottom: 0;
	}

@media not print {
	details.annoying-warning[open] {
		position: fixed;
		left: 0;
		right: 0;
		bottom: 2em;
		z-index: 1000;
	}
}

	details.annoying-warning:not([open]) > summary {
		text-align: center;
	}

/** Entity Definition Boxes ***************************************************/

	.def {
		padding: .5em 1em;
		background: #def;
		background: var(--def-bg);
		margin: 1.2em 0;
		border-left: 0.5em solid #8ccbf2;
		border-left: 0.5em solid var(--def-border);
		color: black;
		color: var(--def-text);
	}

/******************************************************************************/
/*                                    Tables                                  */
/******************************************************************************/

	th, td {
		text-align: left;
		text-align: start;
	}

/** Property/Descriptor Definition Tables *************************************/

	table.def {
		/* inherits .def box styling, see above */
		width: 100%;
		border-spacing: 0;
	}

	table.def td,
	table.def th {
		padding: 0.5em;
		vertical-align: baseline;
		border-bottom: 1px solid #bbd7e9;
		border-bottom: 1px solid var(--defrow-border);
	}

	table.def > tbody > tr:last-child th,
	table.def > tbody > tr:last-child td {
		border-bottom: 0;
	}

	table.def th {
		font-style: italic;
		font-weight: normal;
		padding-left: 1em;
		width: 3em;
	}

	/* For when values are extra-complex and need formatting for readability */
	table td.pre {
		white-space: pre-wrap;
	}

	/* A footnote at the bottom of a def table */
	table.def td.footnote {
		padding-top: 0.6em;
	}
	table.def td.footnote::before {
		content: " ";
		display: block;
		height: 0.6em;
		width: 4em;
		border-top: thin solid;
	}

/** Data tables (and properly marked-up index tables) *************************/
	/*
		<table class="data"> highlights structural relationships in a table
		when correct markup is used (e.g. thead/tbody, th vs. td, scope attribute)

		Use class="complex data" for particularly complicated tables --
		(This will draw more lines: busier, but clearer.)

		Use class="long" on table cells with paragraph-like contents
		(This will adjust text alignment accordingly.)
		Alternately use class="longlastcol" on tables, to have the last column assume "long".
	*/

	table {
		word-wrap: normal;
		overflow-wrap: normal;
		hyphens: manual;
	}

	table.data,
	table.index {
		margin: 1em auto;
		border-collapse: collapse;
		border: hidden;
		width: 100%;
	}
	table.data caption,
	table.index caption {
		max-width: 50em;
		margin: 0 auto 1em;
	}

	table.data td,  table.data th,
	table.index td, table.index th {
		padding: 0.5em 1em;
		border-width: 1px;
		border-color: silver;
		border-color: var(--datacell-border);
		border-top-style: solid;
	}

	table.data thead td:empty {
		padding: 0;
		border: 0;
	}

	table.data  thead,
	table.index thead,
	table.data  tbody,
	table.index tbody {
		border-bottom: 2px solid;
	}

	table.data colgroup,
	table.index colgroup {
		border-left: 2px solid;
	}

	table.data  tbody th:first-child,
	table.index tbody th:first-child  {
		border-right: 2px solid;
		border-top: 1px solid silver;
		border-top: 1px solid var(--datacell-border);
		padding-right: 1em;
	}

	table.data th[colspan],
	table.data td[colspan] {
		text-align: center;
	}

	table.complex.data th,
	table.complex.data td {
		border: 1px solid silver;
		border: 1px solid var(--datacell-border);
		text-align: center;
	}

	table.data.longlastcol td:last-child,
	table.data td.long {
		vertical-align: baseline;
		text-align: left;
	}

	table.data img {
		vertical-align: middle;
	}


/*
Alternate table alignment rules

	table.data,
	table.index {
		text-align: center;
	}

	table.data  thead th[scope="row"],
	table.index thead th[scope="row"] {
		text-align: right;
	}

	table.data  tbody th:first-child,
	table.index tbody th:first-child  {
		text-align: right;
	}

Possible extra rowspan handling

	table.data  tbody th[rowspan]:not([rowspan='1']),
	table.index tbody th[rowspan]:not([rowspan='1']),
	table.data  tbody td[rowspan]:not([rowspan='1']),
	table.index tbody td[rowspan]:not([rowspan='1']) {
		border-left: 1px solid silver;
	}

	table.data  tbody th[rowspan]:first-child,
	table.index tbody th[rowspan]:first-child,
	table.data  tbody td[rowspan]:first-child,
	table.index tbody td[rowspan]:first-child{
		border-left: 0;
		border-right: 1px solid silver;
	}
*/

/******************************************************************************/
/*                                  Indices                                   */
/******************************************************************************/


/** Table of Contents *********************************************************/

	.toc a {
		/* More spacing; use padding to make it part of the click target. */
		padding: 0.1rem 1px 0;
		/* Larger, more consistently-sized click target */
		display: block;
		/* Switch to using border-bottom for underlines */
		text-decoration: none;
		border-bottom: 1px solid;
		/* Reverse color scheme */
		color: black;
		color: var(--toclink-text);
		border-color: #3980b5;
		border-color: var(--toclink-underline);
	}
	.toc a:visited {
		color: black;
		color: var(--toclink-visited-text);
		border-color: #054572;
		border-color: var(--toclink-visited-underline);
	}
	.toc a:focus,
	.toc a:hover {
		background: rgba(75%, 75%, 75%, .25);
		background: var(--a-hover-bg);
		border-bottom-width: 3px;
		margin-bottom: -2px;
	}
	.toc a:not(:focus):not(:hover) {
		/* Allow colors to cascade through from link styling */
		border-bottom-color: transparent;
	}

	.toc, .toc ol, .toc ul, .toc li {
		list-style: none; /* Numbers must be inlined into source */
		/* because generated content isn't search/selectable and markers can't do multilevel yet */
		margin:  0;
		padding: 0;
	}
	.toc {
		line-height: 1.1em;
	}

	/* ToC not indented until third level, but font style & margins show hierarchy */
	.toc > li			{ font-weight: bold;   }
	.toc > li li		 { font-weight: normal; }
	.toc > li li li	  { font-size:   95%;	}
	.toc > li li li li	{ font-size:   90%;	}
	.toc > li li li li li { font-size:   85%;	}

	/* @supports not (display:grid) { */
		.toc > li			{ margin: 1.5rem 0;	}
		.toc > li li		 { margin: 0.3rem 0;	}
		.toc > li li li	  { margin-left: 2rem;   }

		/* Section numbers in a column of their own */
		.toc .secno {
			float: left;
			width: 4rem;
			white-space: nowrap;
		}
		.toc > li li li li .secno { font-size: 85%; }
		.toc > li li li li li .secno { font-size: 100%; }

		.toc li {
			clear: both;
		}

		:not(li) > .toc			 { margin-left:  5rem; }
		.toc .secno				 { margin-left: -5rem; }
		.toc > li li li .secno	  { margin-left: -7rem; }
		.toc > li li li li .secno	{ margin-left: -9rem; }
		.toc > li li li li li .secno { margin-left: -11rem; }

		/* Tighten up indentation in narrow ToCs */
		@media (max-width: 30em) {
			:not(li) > .toc			 { margin-left:  4rem; }
			.toc .secno				 { margin-left: -4rem; }
			.toc > li li li			 { margin-left:  1rem; }
			.toc > li li li .secno	  { margin-left: -5rem; }
			.toc > li li li li .secno	{ margin-left: -6rem; }
			.toc > li li li li li .secno { margin-left: -7rem; }
		}
		/* Loosen it on wide screens */
		@media screen and (min-width: 78em) {
			body:not(.toc-inline) :not(li) > .toc			 { margin-left:  4rem; }
			body:not(.toc-inline) .toc .secno				 { margin-left: -4rem; }
			body:not(.toc-inline) .toc > li li li			 { margin-left:  1rem; }
			body:not(.toc-inline) .toc > li li li .secno	  { margin-left: -5rem; }
			body:not(.toc-inline) .toc > li li li li .secno	{ margin-left: -6rem; }
			body:not(.toc-inline) .toc > li li li li li .secno { margin-left: -7rem; }
	}
	/* } */

	@supports (display:grid) and (display:contents) {
		/* Use #toc over .toc to override non-@supports rules. */
		#toc {
			display: grid;
			align-content: start;
			grid-template-columns: auto 1fr;
			grid-column-gap: 1rem;
			column-gap: 1rem;
			grid-row-gap: .6rem;
			row-gap: .6rem;
		}
		#toc h2 {
			grid-column: 1 / -1;
			margin-bottom: 0;
		}
		#toc ol,
		#toc li,
		#toc a {
			display: contents;
			/* Switch <a> to subgrid when supported */
		}
		#toc span {
			margin: 0;
		}
		#toc > .toc > li > a > span {
			/* The spans of the top-level list,
			  comprising the first items of each top-level section. */
			margin-top: 1.1rem;
		}
		#toc#toc .secno { /* Ugh, need more specificity to override base.css */
			grid-column: 1;
			width: auto;
			margin-left: 0;
		}
		#toc .content {
			grid-column: 2;
			width: auto;
			margin-right: 1rem;
			border-bottom: 3px solid transparent;
			margin-bottom: -3px;
		}
		#toc .content:hover,
		#toc .content:focus {
			background: rgba(75%, 75%, 75%, .25);
			background: var(--a-hover-bg);
			border-bottom-color: #054572;
			border-bottom-color: var(--toclink-underline);
		}
		#toc li li li .content {
			margin-left: 1rem;
		}
		#toc li li li li .content {
			margin-left: 2rem;
		}
	}


/** Index *********************************************************************/

	/* Index Lists: Layout */
	ul.index	  { margin-left: 0; columns: 15em; text-indent: 1em hanging; }
	ul.index li	{ margin-left: 0; list-style: none; break-inside: avoid; }
	ul.index li li { margin-left: 1em; }
	ul.index dl	{ margin-top: 0; }
	ul.index dt	{ margin: .2em 0 .2em 20px;}
	ul.index dd	{ margin: .2em 0 .2em 40px;}
	/* Index Lists: Typography */
	ul.index ul,
	ul.index dl { font-size: smaller; }
	@media not print {
		ul.index li a + span {
			white-space: nowrap;
			color: transparent; }
		ul.index li a:hover + span,
		ul.index li a:focus + span {
			color: #707070;
			color: var(--indexinfo-text);
		}
	}

/** Index Tables *****************************************************/
	/* See also the data table styling section, which this effectively subclasses */

	table.index {
		font-size: small;
		border-collapse: collapse;
		border-spacing: 0;
		text-align: left;
		margin: 1em 0;
	}

	table.index td,
	table.index th {
		padding: 0.4em;
	}

	table.index tr:hover td:not([rowspan]),
	table.index tr:hover th:not([rowspan]) {
		color: black;
		color: var(--indextable-hover-text);
		background: #f7f8f9;
		background: var(--indextable-hover-bg);
	}

	/* The link in the first column in the property table (formerly a TD) */
	table.index th:first-child a {
		font-weight: bold;
	}

/** Outdated warning **********************************************************/

.outdated-spec {
	color: black;
	color: var(--outdatedspec-text);
	background-color: rgba(0,0,0,0.5);
	background-color: var(--outdatedspec-bg);
}

.outdated-warning {
	position: fixed;
	bottom: 50%;
	left: 0;
	right: 0;
	margin: 0 auto;
	width: 50%;
	background: maroon;
	background: var(--outdated-bg);
	color: white;
	color: var(--outdated-text);
	border-radius: 1em;
	box-shadow: 0 0 1em red;
	box-shadow: 0 0 1em var(--outdated-shadow);
	padding: 2em;
	text-align: center;
	z-index: 2;
}

.outdated-warning a {
	color: currentcolor;
	background: transparent;
}

.edited-rec-warning {
	background: darkorange;
	background: var(--editedrec-bg);
	box-shadow: 0 0 1em;
}

.outdated-warning button {
	color: var(--outdated-text);
	border-radius: 1em;
	box-shadow: 0 0 1em red;
	box-shadow: 0 0 1em var(--outdated-shadow);
	padding: 2em;
	text-align: center;
	z-index: 2;
}

.outdated-warning a {
	color: currentcolor;
	background: transparent;
}

.edited-rec-warning {
	background: darkorange;
	background: var(--editedrec-bg);
	box-shadow: 0 0 1em;
}

.outdated-warning button {
	position: absolute;
	top: 0;
	right:0;
	margin: 0;
	border: 0;
	padding: 0.25em 0.5em;
	background: transparent;
	color: white;
	color: var(--outdated-text);
	font:1em sans-serif;
	text-align:center;
}

.outdated-warning span {
	display: block;
}

.outdated-collapsed {
	bottom: 0;
	border-radius: 0;
	width: 100%;
	padding: 0;
}

/******************************************************************************/
/*                                    Print                                   */
/******************************************************************************/

	@media print {
		/* Pages have their own margins. */
		html {
			margin: 0;
		}
		/* Serif for print. */
		body {
			font-family: serif;
		}

		.outdated-warning {
			position: absolute;
			border-style: solid;
			border-color: red;
		}

		.outdated-warning input {
			display: none;
		}
	}
	@page {
		margin: 1.5cm 1.1cm;
	}



/******************************************************************************/
/*                             Overflow Control                               */
/******************************************************************************/

	.figure .caption, .sidefigure .caption, figcaption {
		/* in case figure is overlarge, limit caption to 50em */
		max-width: 50rem;
		margin-left: auto;
		margin-right: auto;
	}
	.overlarge {
		/* Magic to create good item positioning:
		  "content column" is 50ems wide at max; less on smaller screens.
		  Extra space (after ToC + content) is empty on the right.

		  1. When item < content column, centers item in column.
		  2. When content < item < available, left-aligns.
		  3. When item > available, fills available + scroll bar.
		*/
		display: grid;
		grid-template-columns: minmax(0, 50em);
	}
	.overlarge > table {
		/* limit preferred width of table */
		max-width: 50em;
		margin-left: auto;
		margin-right: auto;
	}

	@media (min-width: 55em) {
		.overlarge {
			margin-right: calc(13px + 26.5rem - 50vw);
			max-width: none;
		}
	}
	@media screen and (min-width: 78em) {
		body:not(.toc-inline) .overlarge {
			/* 30.5em body padding 50em content area */
			margin-right: calc(40em - 50vw) !important;
		}
	}
	@media screen and (min-width: 90em) {
		body:not(.toc-inline) .overlarge {
			/* 4em html margin 30.5em body padding 50em content area */
			margin-right: calc(84.5em - 100vw) !important;
		}
	}

	@media not print {
		.overlarge {
			overflow-x: auto;
			/* See Lea Verou's explanation background-attachment:
			* http://lea.verou.me/2012/04/background-attachment-local/
			*
			background: top left  / 4em 100% linear-gradient(to right,  #ffffff, rgba(255, 255, 255, 0)) local,
						top right / 4em 100% linear-gradient(to left, #ffffff, rgba(255, 255, 255, 0)) local,
						top left  / 1em 100% linear-gradient(to right,  #c3c3c5, rgba(195, 195, 197, 0)) scroll,
						top right / 1em 100% linear-gradient(to left, #c3c3c5, rgba(195, 195, 197, 0)) scroll,
						white;
			background-repeat: no-repeat;
			*/
		}
	}
</style>
<style>
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
      vertical-align: top;
    }
    th, td {
      border-left: none;
      border-right: none;
      padding: 0px 10px;
    }
    th {
      text-align: center;
    }

    del { background: #fcc; color: #000; text-decoration: line-through; }
    ins { background: #cfc; color: #000; }
    blockquote .highlight:not(.idl) { background: initial; margin: initial; padding: 0.5em }
    blockquote ul { background: inherit; }
    blockquote code.highlight:not(.idl) { padding: initial; }
    blockquote c-[a] { color: inherit; } /* Keyword.Declaration */
    blockquote c-[b] { color: inherit; } /* Keyword.Type */
    blockquote c-[c] { color: inherit; } /* Comment */
    blockquote c-[d] { color: inherit; } /* Comment.Multiline */
    blockquote c-[e] { color: inherit; } /* Name.Attribute */
    blockquote c-[f] { color: inherit; } /* Name.Tag */
    blockquote c-[g] { color: inherit; } /* Name.Variable */
    blockquote c-[k] { color: inherit; } /* Keyword */
    blockquote c-[l] { color: inherit; } /* Literal */
    blockquote c-[m] { color: inherit; } /* Literal.Number */
    blockquote c-[n] { color: inherit; } /* Name */
    blockquote c-[o] { color: inherit; } /* Operator */
    blockquote c-[p] { color: inherit; } /* Punctuation */
    blockquote c-[s] { color: inherit; } /* Literal.String */
    blockquote c-[t] { color: inherit; } /* Literal.String.Single */
    blockquote c-[u] { color: inherit; } /* Literal.String.Double */
    blockquote c-[cp] { color: inherit; } /* Comment.Preproc */
    blockquote c-[c1] { color: inherit; } /* Comment.Single */
    blockquote c-[cs] { color: inherit; } /* Comment.Special */
    blockquote c-[kc] { color: inherit; } /* Keyword.Constant */
    blockquote c-[kn] { color: inherit; } /* Keyword.Namespace */
    blockquote c-[kp] { color: inherit; } /* Keyword.Pseudo */
    blockquote c-[kr] { color: inherit; } /* Keyword.Reserved */
    blockquote c-[ld] { color: inherit; } /* Literal.Date */
    blockquote c-[nc] { color: inherit; } /* Name.Class */
    blockquote c-[no] { color: inherit; } /* Name.Constant */
    blockquote c-[nd] { color: inherit; } /* Name.Decorator */
    blockquote c-[ni] { color: inherit; } /* Name.Entity */
    blockquote c-[ne] { color: inherit; } /* Name.Exception */
    blockquote c-[nf] { color: inherit; } /* Name.Function */
    blockquote c-[nl] { color: inherit; } /* Name.Label */
    blockquote c-[nn] { color: inherit; } /* Name.Namespace */
    blockquote c-[py] { color: inherit; } /* Name.Property */
    blockquote c-[ow] { color: inherit; } /* Operator.Word */
    blockquote c-[mb] { color: inherit; } /* Literal.Number.Bin */
    blockquote c-[mf] { color: inherit; } /* Literal.Number.Float */
    blockquote c-[mh] { color: inherit; } /* Literal.Number.Hex */
    blockquote c-[mi] { color: inherit; } /* Literal.Number.Integer */
    blockquote c-[mo] { color: inherit; } /* Literal.Number.Oct */
    blockquote c-[sb] { color: inherit; } /* Literal.String.Backtick */
    blockquote c-[sc] { color: inherit; } /* Literal.String.Char */
    blockquote c-[sd] { color: inherit; } /* Literal.String.Doc */
    blockquote c-[se] { color: inherit; } /* Literal.String.Escape */
    blockquote c-[sh] { color: inherit; } /* Literal.String.Heredoc */
    blockquote c-[si] { color: inherit; } /* Literal.String.Interpol */
    blockquote c-[sx] { color: inherit; } /* Literal.String.Other */
    blockquote c-[sr] { color: inherit; } /* Literal.String.Regex */
    blockquote c-[ss] { color: inherit; } /* Literal.String.Symbol */
    blockquote c-[vc] { color: inherit; } /* Name.Variable.Class */
    blockquote c-[vg] { color: inherit; } /* Name.Variable.Global */
    blockquote c-[vi] { color: inherit; } /* Name.Variable.Instance */
    blockquote c-[il] { color: inherit; } /* Literal.Number.Integer.Long */
  </style>
  <meta content="Bikeshed version 82ce88815, updated Thu Sep 7 16:33:55 2023 -0700" name="generator">
  <link href="https://htmlpreview.github.io/?https://github.com/SebastienBini/cpp-relocation-proposal/blob/main/relocation.html" rel="canonical">
  <link href="https://isocpp.org/favicon.ico" rel="icon">
  <meta content="74513f9b96c809c63ece641f2e272472e705b0bb" name="document-revision">
<style>/* Boilerplate: style-autolinks */
.css.css, .property.property, .descriptor.descriptor {
    color: var(--a-normal-text);
    font-size: inherit;
    font-family: inherit;
}
.css::before, .property::before, .descriptor::before {
    content: "‘";
}
.css::after, .property::after, .descriptor::after {
    content: "’";
}
.property, .descriptor {
    /* Don't wrap property and descriptor names */
    white-space: nowrap;
}
.type { /* CSS value <type> */
    font-style: italic;
}
pre .property::before, pre .property::after {
    content: "";
}
[data-link-type="property"]::before,
[data-link-type="propdesc"]::before,
[data-link-type="descriptor"]::before,
[data-link-type="value"]::before,
[data-link-type="function"]::before,
[data-link-type="at-rule"]::before,
[data-link-type="selector"]::before,
[data-link-type="maybe"]::before {
    content: "‘";
}
[data-link-type="property"]::after,
[data-link-type="propdesc"]::after,
[data-link-type="descriptor"]::after,
[data-link-type="value"]::after,
[data-link-type="function"]::after,
[data-link-type="at-rule"]::after,
[data-link-type="selector"]::after,
[data-link-type="maybe"]::after {
    content: "’";
}

[data-link-type].production::before,
[data-link-type].production::after,
.prod [data-link-type]::before,
.prod [data-link-type]::after {
    content: "";
}

[data-link-type=element],
[data-link-type=element-attr] {
    font-family: Menlo, Consolas, "DejaVu Sans Mono", monospace;
    font-size: .9em;
}
[data-link-type=element]::before { content: "<" }
[data-link-type=element]::after  { content: ">" }

[data-link-type=biblio] {
    white-space: pre;
}

@media (prefers-color-scheme: dark) {
    :root {
        --selflink-text: black;
        --selflink-bg: silver;
        --selflink-hover-text: white;
    }
}
</style>
<style>/* Boilerplate: style-colors */

/* Any --*-text not paired with a --*-bg is assumed to have a transparent bg */
:root {
    color-scheme: light dark;

    --text: black;
    --bg: white;

    --unofficial-watermark: url(https://www.w3.org/StyleSheets/TR/2016/logos/UD-watermark);

    --logo-bg: #1a5e9a;
    --logo-active-bg: #c00;
    --logo-text: white;

    --tocnav-normal-text: #707070;
    --tocnav-normal-bg: var(--bg);
    --tocnav-hover-text: var(--tocnav-normal-text);
    --tocnav-hover-bg: #f8f8f8;
    --tocnav-active-text: #c00;
    --tocnav-active-bg: var(--tocnav-normal-bg);

    --tocsidebar-text: var(--text);
    --tocsidebar-bg: #f7f8f9;
    --tocsidebar-shadow: rgba(0,0,0,.1);
    --tocsidebar-heading-text: hsla(203,20%,40%,.7);

    --toclink-text: var(--text);
    --toclink-underline: #3980b5;
    --toclink-visited-text: var(--toclink-text);
    --toclink-visited-underline: #054572;

    --heading-text: #005a9c;

    --hr-text: var(--text);

    --algo-border: #def;

    --del-text: red;
    --del-bg: transparent;
    --ins-text: #080;
    --ins-bg: transparent;

    --a-normal-text: #034575;
    --a-normal-underline: #bbb;
    --a-visited-text: var(--a-normal-text);
    --a-visited-underline: #707070;
    --a-hover-bg: rgba(75%, 75%, 75%, .25);
    --a-active-text: #c00;
    --a-active-underline: #c00;

    --blockquote-border: silver;
    --blockquote-bg: transparent;
    --blockquote-text: currentcolor;

    --issue-border: #e05252;
    --issue-bg: #fbe9e9;
    --issue-text: var(--text);
    --issueheading-text: #831616;

    --example-border: #e0cb52;
    --example-bg: #fcfaee;
    --example-text: var(--text);
    --exampleheading-text: #574b0f;

    --note-border: #52e052;
    --note-bg: #e9fbe9;
    --note-text: var(--text);
    --noteheading-text: hsl(120, 70%, 30%);
    --notesummary-underline: silver;

    --assertion-border: #aaa;
    --assertion-bg: #eee;
    --assertion-text: black;

    --advisement-border: orange;
    --advisement-bg: #fec;
    --advisement-text: var(--text);
    --advisementheading-text: #b35f00;

    --warning-border: red;
    --warning-bg: hsla(40,100%,50%,0.95);
    --warning-text: var(--text);

    --amendment-border: #330099;
    --amendment-bg: #F5F0FF;
    --amendment-text: var(--text);
    --amendmentheading-text: #220066;

    --def-border: #8ccbf2;
    --def-bg: #def;
    --def-text: var(--text);
    --defrow-border: #bbd7e9;

    --datacell-border: silver;

    --indexinfo-text: #707070;

    --indextable-hover-text: black;
    --indextable-hover-bg: #f7f8f9;

    --outdatedspec-bg: rgba(0, 0, 0, .5);
    --outdatedspec-text: black;
    --outdated-bg: maroon;
    --outdated-text: white;
    --outdated-shadow: red;

    --editedrec-bg: darkorange;
}

@media (prefers-color-scheme: dark) {
    :root {
        --text: #ddd;
        --bg: black;

        --unofficial-watermark: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='400'%3E%3Cg fill='%23100808' transform='translate(200 200) rotate(-45) translate(-200 -200)' stroke='%23100808' stroke-width='3'%3E%3Ctext x='50%25' y='220' style='font: bold 70px sans-serif; text-anchor: middle; letter-spacing: 6px;'%3EUNOFFICIAL%3C/text%3E%3Ctext x='50%25' y='305' style='font: bold 70px sans-serif; text-anchor: middle; letter-spacing: 6px;'%3EDRAFT%3C/text%3E%3C/g%3E%3C/svg%3E");

        --logo-bg: #1a5e9a;
        --logo-active-bg: #c00;
        --logo-text: white;

        --tocnav-normal-text: #999;
        --tocnav-normal-bg: var(--bg);
        --tocnav-hover-text: var(--tocnav-normal-text);
        --tocnav-hover-bg: #080808;
        --tocnav-active-text: #f44;
        --tocnav-active-bg: var(--tocnav-normal-bg);

        --tocsidebar-text: var(--text);
        --tocsidebar-bg: #080808;
        --tocsidebar-shadow: rgba(255,255,255,.1);
        --tocsidebar-heading-text: hsla(203,20%,40%,.7);

        --toclink-text: var(--text);
        --toclink-underline: #6af;
        --toclink-visited-text: var(--toclink-text);
        --toclink-visited-underline: #054572;

        --heading-text: #8af;

        --hr-text: var(--text);

        --algo-border: #456;

        --del-text: #f44;
        --del-bg: transparent;
        --ins-text: #4a4;
        --ins-bg: transparent;

        --a-normal-text: #6af;
        --a-normal-underline: #555;
        --a-visited-text: var(--a-normal-text);
        --a-visited-underline: var(--a-normal-underline);
        --a-hover-bg: rgba(25%, 25%, 25%, .2);
        --a-active-text: #f44;
        --a-active-underline: var(--a-active-text);

        --borderedblock-bg: rgba(255, 255, 255, .05);

        --blockquote-border: silver;
        --blockquote-bg: var(--borderedblock-bg);
        --blockquote-text: currentcolor;

        --issue-border: #e05252;
        --issue-bg: var(--borderedblock-bg);
        --issue-text: var(--text);
        --issueheading-text: hsl(0deg, 70%, 70%);

        --example-border: hsl(50deg, 90%, 60%);
        --example-bg: var(--borderedblock-bg);
        --example-text: var(--text);
        --exampleheading-text: hsl(50deg, 70%, 70%);

        --note-border: hsl(120deg, 100%, 35%);
        --note-bg: var(--borderedblock-bg);
        --note-text: var(--text);
        --noteheading-text: hsl(120, 70%, 70%);
        --notesummary-underline: silver;

        --assertion-border: #444;
        --assertion-bg: var(--borderedblock-bg);
        --assertion-text: var(--text);

        --advisement-border: orange;
        --advisement-bg: #222218;
        --advisement-text: var(--text);
        --advisementheading-text: #f84;

        --warning-border: red;
        --warning-bg: hsla(40,100%,20%,0.95);
        --warning-text: var(--text);

        --amendment-border: #330099;
        --amendment-bg: #080010;
        --amendment-text: var(--text);
        --amendmentheading-text: #cc00ff;

        --def-border: #8ccbf2;
        --def-bg: #080818;
        --def-text: var(--text);
        --defrow-border: #136;

        --datacell-border: silver;

        --indexinfo-text: #aaa;

        --indextable-hover-text: var(--text);
        --indextable-hover-bg: #181818;

        --outdatedspec-bg: rgba(255, 255, 255, .5);
        --outdatedspec-text: black;
        --outdated-bg: maroon;
        --outdated-text: white;
        --outdated-shadow: red;

        --editedrec-bg: darkorange;
    }
    /* In case a transparent-bg image doesn't expect to be on a dark bg,
       which is quite common in practice... */
    img { background: white; }
}
</style>
<style>/* Boilerplate: style-counters */
body {
    counter-reset: example figure issue;
}
.issue {
    counter-increment: issue;
}
.issue:not(.no-marker)::before {
    content: "Issue " counter(issue);
}

.example {
    counter-increment: example;
}
.example:not(.no-marker)::before {
    content: "Example " counter(example);
}
.invalid.example:not(.no-marker)::before,
.illegal.example:not(.no-marker)::before {
    content: "Invalid Example" counter(example);
}

figcaption {
    counter-increment: figure;
}
figcaption:not(.no-marker)::before {
    content: "Figure " counter(figure) " ";
}
</style>
<style>/* Boilerplate: style-issues */
a[href].issue-return {
    float: right;
    float: inline-end;
    color: var(--issueheading-text);
    font-weight: bold;
    text-decoration: none;
}
</style>
<style>/* Boilerplate: style-md-lists */
/* This is a weird hack for me not yet following the commonmark spec
   regarding paragraph and lists. */
[data-md] > :first-child {
    margin-top: 0;
}
[data-md] > :last-child {
    margin-bottom: 0;
}
</style>
<style>/* Boilerplate: style-selflinks */

:root {
    --selflink-text: white;
    --selflink-bg: gray;
    --selflink-hover-text: black;
}
.heading, .issue, .note, .example, li, dt {
    position: relative;
}
a.self-link {
    position: absolute;
    top: 0;
    left: calc(-1 * (3.5rem - 26px));
    width: calc(3.5rem - 26px);
    height: 2em;
    text-align: center;
    border: none;
    transition: opacity .2s;
    opacity: .5;
}
a.self-link:hover {
    opacity: 1;
}
.heading > a.self-link {
    font-size: 83%;
}
.example > a.self-link,
.note > a.self-link,
.issue > a.self-link {
    /* These blocks are overflow:auto, so positioning outside
       doesn't work. */
    left: auto;
    right: 0;
}
li > a.self-link {
    left: calc(-1 * (3.5rem - 26px) - 2em);
}
dfn > a.self-link {
    top: auto;
    left: auto;
    opacity: 0;
    width: 1.5em;
    height: 1.5em;
    background: var(--selflink-bg);
    color: var(--selflink-text);
    font-style: normal;
    transition: opacity .2s, background-color .2s, color .2s;
}
dfn:hover > a.self-link {
    opacity: 1;
}
dfn > a.self-link:hover {
    color: var(--selflink-hover-text);
}

a.self-link::before            { content: "¶"; }
.heading > a.self-link::before { content: "§"; }
dfn > a.self-link::before      { content: "#"; }
</style>
<style>/* Boilerplate: style-syntax-highlighting */

code.highlight { padding: .1em; border-radius: .3em; }
pre.highlight, pre > code.highlight { display: block; padding: 1em; margin: .5em 0; overflow: auto; border-radius: 0; }

.highlight:not(.idl) { background: rgba(0, 0, 0, .03); }
c-[a] { color: #990055 } /* Keyword.Declaration */
c-[b] { color: #990055 } /* Keyword.Type */
c-[c] { color: #708090 } /* Comment */
c-[d] { color: #708090 } /* Comment.Multiline */
c-[e] { color: #0077aa } /* Name.Attribute */
c-[f] { color: #669900 } /* Name.Tag */
c-[g] { color: #222222 } /* Name.Variable */
c-[k] { color: #990055 } /* Keyword */
c-[l] { color: #000000 } /* Literal */
c-[m] { color: #000000 } /* Literal.Number */
c-[n] { color: #0077aa } /* Name */
c-[o] { color: #999999 } /* Operator */
c-[p] { color: #999999 } /* Punctuation */
c-[s] { color: #a67f59 } /* Literal.String */
c-[t] { color: #a67f59 } /* Literal.String.Single */
c-[u] { color: #a67f59 } /* Literal.String.Double */
c-[cp] { color: #708090 } /* Comment.Preproc */
c-[c1] { color: #708090 } /* Comment.Single */
c-[cs] { color: #708090 } /* Comment.Special */
c-[kc] { color: #990055 } /* Keyword.Constant */
c-[kn] { color: #990055 } /* Keyword.Namespace */
c-[kp] { color: #990055 } /* Keyword.Pseudo */
c-[kr] { color: #990055 } /* Keyword.Reserved */
c-[ld] { color: #000000 } /* Literal.Date */
c-[nc] { color: #0077aa } /* Name.Class */
c-[no] { color: #0077aa } /* Name.Constant */
c-[nd] { color: #0077aa } /* Name.Decorator */
c-[ni] { color: #0077aa } /* Name.Entity */
c-[ne] { color: #0077aa } /* Name.Exception */
c-[nf] { color: #0077aa } /* Name.Function */
c-[nl] { color: #0077aa } /* Name.Label */
c-[nn] { color: #0077aa } /* Name.Namespace */
c-[py] { color: #0077aa } /* Name.Property */
c-[ow] { color: #999999 } /* Operator.Word */
c-[mb] { color: #000000 } /* Literal.Number.Bin */
c-[mf] { color: #000000 } /* Literal.Number.Float */
c-[mh] { color: #000000 } /* Literal.Number.Hex */
c-[mi] { color: #000000 } /* Literal.Number.Integer */
c-[mo] { color: #000000 } /* Literal.Number.Oct */
c-[sb] { color: #a67f59 } /* Literal.String.Backtick */
c-[sc] { color: #a67f59 } /* Literal.String.Char */
c-[sd] { color: #a67f59 } /* Literal.String.Doc */
c-[se] { color: #a67f59 } /* Literal.String.Escape */
c-[sh] { color: #a67f59 } /* Literal.String.Heredoc */
c-[si] { color: #a67f59 } /* Literal.String.Interpol */
c-[sx] { color: #a67f59 } /* Literal.String.Other */
c-[sr] { color: #a67f59 } /* Literal.String.Regex */
c-[ss] { color: #a67f59 } /* Literal.String.Symbol */
c-[vc] { color: #0077aa } /* Name.Variable.Class */
c-[vg] { color: #0077aa } /* Name.Variable.Global */
c-[vi] { color: #0077aa } /* Name.Variable.Instance */
c-[il] { color: #000000 } /* Literal.Number.Integer.Long */


@media (prefers-color-scheme: dark) {
    .highlight:not(.idl) { background: rgba(255, 255, 255, .05); }

    c-[a] { color: #d33682 } /* Keyword.Declaration */
    c-[b] { color: #d33682 } /* Keyword.Type */
    c-[c] { color: #2aa198 } /* Comment */
    c-[d] { color: #2aa198 } /* Comment.Multiline */
    c-[e] { color: #268bd2 } /* Name.Attribute */
    c-[f] { color: #b58900 } /* Name.Tag */
    c-[g] { color: #cb4b16 } /* Name.Variable */
    c-[k] { color: #d33682 } /* Keyword */
    c-[l] { color: #657b83 } /* Literal */
    c-[m] { color: #657b83 } /* Literal.Number */
    c-[n] { color: #268bd2 } /* Name */
    c-[o] { color: #657b83 } /* Operator */
    c-[p] { color: #657b83 } /* Punctuation */
    c-[s] { color: #6c71c4 } /* Literal.String */
    c-[t] { color: #6c71c4 } /* Literal.String.Single */
    c-[u] { color: #6c71c4 } /* Literal.String.Double */
    c-[ch] { color: #2aa198 } /* Comment.Hashbang */
    c-[cp] { color: #2aa198 } /* Comment.Preproc */
    c-[cpf] { color: #2aa198 } /* Comment.PreprocFile */
    c-[c1] { color: #2aa198 } /* Comment.Single */
    c-[cs] { color: #2aa198 } /* Comment.Special */
    c-[kc] { color: #d33682 } /* Keyword.Constant */
    c-[kn] { color: #d33682 } /* Keyword.Namespace */
    c-[kp] { color: #d33682 } /* Keyword.Pseudo */
    c-[kr] { color: #d33682 } /* Keyword.Reserved */
    c-[ld] { color: #657b83 } /* Literal.Date */
    c-[nc] { color: #268bd2 } /* Name.Class */
    c-[no] { color: #268bd2 } /* Name.Constant */
    c-[nd] { color: #268bd2 } /* Name.Decorator */
    c-[ni] { color: #268bd2 } /* Name.Entity */
    c-[ne] { color: #268bd2 } /* Name.Exception */
    c-[nf] { color: #268bd2 } /* Name.Function */
    c-[nl] { color: #268bd2 } /* Name.Label */
    c-[nn] { color: #268bd2 } /* Name.Namespace */
    c-[py] { color: #268bd2 } /* Name.Property */
    c-[ow] { color: #657b83 } /* Operator.Word */
    c-[mb] { color: #657b83 } /* Literal.Number.Bin */
    c-[mf] { color: #657b83 } /* Literal.Number.Float */
    c-[mh] { color: #657b83 } /* Literal.Number.Hex */
    c-[mi] { color: #657b83 } /* Literal.Number.Integer */
    c-[mo] { color: #657b83 } /* Literal.Number.Oct */
    c-[sa] { color: #6c71c4 } /* Literal.String.Affix */
    c-[sb] { color: #6c71c4 } /* Literal.String.Backtick */
    c-[sc] { color: #6c71c4 } /* Literal.String.Char */
    c-[dl] { color: #6c71c4 } /* Literal.String.Delimiter */
    c-[sd] { color: #6c71c4 } /* Literal.String.Doc */
    c-[se] { color: #6c71c4 } /* Literal.String.Escape */
    c-[sh] { color: #6c71c4 } /* Literal.String.Heredoc */
    c-[si] { color: #6c71c4 } /* Literal.String.Interpol */
    c-[sx] { color: #6c71c4 } /* Literal.String.Other */
    c-[sr] { color: #6c71c4 } /* Literal.String.Regex */
    c-[ss] { color: #6c71c4 } /* Literal.String.Symbol */
    c-[fm] { color: #268bd2 } /* Name.Function.Magic */
    c-[vc] { color: #cb4b16 } /* Name.Variable.Class */
    c-[vg] { color: #cb4b16 } /* Name.Variable.Global */
    c-[vi] { color: #cb4b16 } /* Name.Variable.Instance */
    c-[vm] { color: #cb4b16 } /* Name.Variable.Magic */
    c-[il] { color: #657b83 } /* Literal.Number.Integer.Long */
}
</style>
 <body class="h-entry">
  <div class="head">
   <p data-fill-with="logo"></p>
   <h1 class="p-name no-ref" id="title">P2785R4<br>Relocating prvalues</h1>
   <h2 class="no-num no-toc no-ref heading settled" id="profile-and-date"><span class="content">Published Proposal, <time class="dt-updated" datetime="2023-06-14">2023-06-14</time></span></h2>
   <div data-fill-with="spec-metadata">
    <dl>
     <dt>This version:
     <dd><a class="u-url" href="https://htmlpreview.github.io/?https://github.com/SebastienBini/cpp-relocation-proposal/blob/main/relocation.html">https://htmlpreview.github.io/?https://github.com/SebastienBini/cpp-relocation-proposal/blob/main/relocation.html</a>
     <dt class="editor">Authors:
     <dd class="editor p-author h-card vcard"><span class="p-name fn"></span>
     <dd class="editor p-author h-card vcard"><a class="p-name fn u-email email" href="mailto:sebastien.bini@gmail.com">Sébastien Bini</a> (<span class="p-org org">Amadeus</span>)
     <dd class="editor p-author h-card vcard"><a class="p-name fn u-email email" href="mailto:ed@catmur.uk">Ed Catmur</a>
     <dt>Audience:
     <dd>LEWG, EWG
     <dt>Project:
     <dd>ISO/IEC 14882 Programming Languages — C++, ISO/IEC JTC1/SC22/WG21
    </dl>
   </div>
   <div data-fill-with="warning"></div>
   <hr title="Separator for header">
  </div>
  <div class="p-summary" data-fill-with="abstract">
   <h2 class="no-num no-toc no-ref heading settled" id="abstract"><span class="content">Abstract</span></h2>
   <p>This paper proposes several mechanisms to enable real relocation in C++.

  We cover several topics, such as trivial relocatibility, container optimizations,
  supports for relocate-only types, library changes and the impact of the existing code base.</p>
  </div>
  <nav data-fill-with="table-of-contents" id="toc">
   <h2 class="no-num no-toc no-ref" id="contents">Table of Contents</h2>
   <ol class="toc" role="directory">
    <li>
     <a href="#intro"><span class="secno">1</span> <span class="content">Overview</span></a>
     <ol class="toc">
      <li>
       <a href="#changes"><span class="secno">1.1</span> <span class="content">Changes from previous revisions of P2785</span></a>
       <ol class="toc">
        <li>
         <a href="#changes-from-r3"><span class="secno">1.1.1</span> <span class="content">Changes from P2785R3</span></a>
         <ol class="toc">
          <li><a href="#changes-from-r3-motivation"><span class="secno">1.1.1.1</span> <span class="content">Motivation</span></a>
          <li><a href="#changes-from-r3-dot-reloc"><span class="secno">1.1.1.2</span> <span class="content">Generalization of object decomposition</span></a>
          <li><a href="#changes-from-r3-value-param-ownership"><span class="secno">1.1.1.3</span> <span class="content">Value parameter ownership rule</span></a>
          <li><a href="#changes-from-r3-stl"><span class="secno">1.1.1.4</span> <span class="content">Library changes</span></a>
         </ol>
        <li><a href="#changes-from-older"><span class="secno">1.1.2</span> <span class="content">Changes from older revisions</span></a>
       </ol>
     </ol>
    <li>
     <a href="#motivation"><span class="secno">2</span> <span class="content">Motivation</span></a>
     <ol class="toc">
      <li>
       <a href="#const-vs-move"><span class="secno">2.1</span> <span class="content">More constness!</span></a>
       <ol class="toc">
        <li><a href="#const-var"><span class="secno">2.1.1</span> <span class="content">Constant local variables cannot be moved</span></a>
        <li><a href="#const-data-members"><span class="secno">2.1.2</span> <span class="content">Constant data members</span></a>
       </ol>
      <li>
       <a href="#reloc-only-support"><span class="secno">2.2</span> <span class="content">Support for relocate-only types</span></a>
       <ol class="toc">
        <li><a href="#motivation-accidental-relocate-only-types"><span class="secno">2.2.1</span> <span class="content">Accidental relocate-only types</span></a>
        <li><a href="#motivation-never-empty"><span class="secno">2.2.2</span> <span class="content">Move constructor breaks class invariant</span></a>
       </ol>
      <li><a href="#motivation-safer-use-after-move"><span class="secno">2.3</span> <span class="content">Safety against use-after-move</span></a>
      <li><a href="#motivation-early-dtor"><span class="secno">2.4</span> <span class="content">Early destruction</span></a>
      <li><a href="#motivation-teachability"><span class="secno">2.5</span> <span class="content">Teachability</span></a>
      <li><a href="#motivation-vs-trivial-relocation"><span class="secno">2.6</span> <span class="content">Versus trivial relocation</span></a>
      <li><a href="#motivation-performance"><span class="secno">2.7</span> <span class="content">Library performance</span></a>
     </ol>
    <li>
     <a href="#nomenclature"><span class="secno">3</span> <span class="content">Nomenclature</span></a>
     <ol class="toc">
      <li><a href="#src-and-target"><span class="secno">3.1</span> <span class="content">Source and target objects</span></a>
      <li><a href="#dtor-state"><span class="secno">3.2</span> <span class="content">Destructed state</span></a>
      <li><a href="#parameter-ownership"><span class="secno">3.3</span> <span class="content">Parameter ownership</span></a>
     </ol>
    <li>
     <a href="#compare"><span class="secno">4</span> <span class="content">Comparison with existing proposals</span></a>
     <ol class="toc">
      <li><a href="#compare-P1144R8"><span class="secno">4.1</span> <span class="content">P1144R8: Object relocation in terms of move plus destroy by Arthur O’Dwyer</span></a>
      <li><a href="#compare-P0023R0"><span class="secno">4.2</span> <span class="content">P0023R0: Relocator: Efficiently moving objects by Denis Bider</span></a>
      <li><a href="#compare-N4158"><span class="secno">4.3</span> <span class="content">N4158: Destructive Move by Pablo Halpern</span></a>
      <li><a href="#compare-P1029R3"><span class="secno">4.4</span> <span class="content">P1029R3: move = bitcopies by Niall Douglas</span></a>
      <li><a href="#compare-P0308R0"><span class="secno">4.5</span> <span class="content">P0308R0: Valueless Variants Considered Harmful by Peter Dimov</span></a>
      <li><a href="#compare-D2839"><span class="secno">4.6</span> <span class="content">D2839R1: Nontrivial Relocation via a New <em>owning reference</em> Type by Brian Bi and Joshua Berne</span></a>
     </ol>
    <li>
     <a href="#lg-changes"><span class="secno">5</span> <span class="content">Proposed language changes</span></a>
     <ol class="toc">
      <li>
       <a href="#reloc-operator"><span class="secno">5.1</span> <span class="content">reloc operator</span></a>
       <ol class="toc">
        <li><a href="#reloc-perfect-fwd"><span class="secno">5.1.1</span> <span class="content">reloc to perfectly forward all value categories</span></a>
        <li><a href="#reloc-constexpr"><span class="secno">5.1.2</span> <span class="content">reloc in constexpr</span></a>
        <li><a href="#reloc-value-change"><span class="secno">5.1.3</span> <span class="content">reloc produces a prvalue</span></a>
        <li><a href="#reloc-with-function-param"><span class="secno">5.1.4</span> <span class="content">Relocation constructor discardment with function parameters</span></a>
        <li><a href="#reloc-src-obj-lifetime"><span class="secno">5.1.5</span> <span class="content">Early end of scope</span></a>
        <li><a href="#reloc-illegal-uses"><span class="secno">5.1.6</span> <span class="content">Illegal uses of reloc</span></a>
        <li><a href="#reloc-elision"><span class="secno">5.1.7</span> <span class="content">Relocation elision</span></a>
        <li><a href="#discarded-reloc-expr"><span class="secno">5.1.8</span> <span class="content">Discarded reloc expressions</span></a>
       </ol>
      <li>
       <a href="#decomposed-object"><span class="secno">5.2</span> <span class="content">Object decomposition</span></a>
       <ol class="toc">
        <li><a href="#decomposed-object-decl"><span class="secno">5.2.1</span> <span class="content">Declaration and definition</span></a>
        <li>
         <a href="#decomposed-state"><span class="secno">5.2.2</span> <span class="content">Decomposition operation</span></a>
         <ol class="toc">
          <li><a href="#decomposed-obj-namespace"><span class="secno">5.2.2.1</span> <span class="content">Namespace of the decomposed object</span></a>
         </ol>
        <li><a href="#ill-formed-decomposition"><span class="secno">5.2.3</span> <span class="content">Illegal decomposition</span></a>
        <li><a href="#decompose-lambda"><span class="secno">5.2.4</span> <span class="content">Decomposition of a lambda closure type</span></a>
        <li><a href="#decompose-tmp"><span class="secno">5.2.5</span> <span class="content">Implicit decomposition of temporaries</span></a>
        <li><a href="#decompose-value-param"><span class="secno">5.2.6</span> <span class="content">Decomposition of value parameters</span></a>
        <li><a href="#dot-reloc-constexpr"><span class="secno">5.2.7</span> <span class="content">Decomposition in constexpr</span></a>
        <li>
         <a href="#decomposed-object-examples"><span class="secno">5.2.8</span> <span class="content">Examples</span></a>
         <ol class="toc">
          <li><a href="#decomposed-object-ex-nominal"><span class="secno">5.2.8.1</span> <span class="content">Nominal case</span></a>
          <li><a href="#decomposed-object-ex-extractor"><span class="secno">5.2.8.2</span> <span class="content">Custom extractor</span></a>
          <li><a href="#decomposed-object-putative-release"><span class="secno">5.2.8.3</span> <span class="content">Putative std::unique_ptr::release</span></a>
         </ol>
       </ol>
      <li>
       <a href="#ill-formed-reuse"><span class="secno">5.3</span> <span class="content">Ill-formed reuse of relocated objects</span></a>
       <ol class="toc">
        <li><a href="#variable-state-tracking"><span class="secno">5.3.1</span> <span class="content">Variable state tracking</span></a>
        <li><a href="#unevaluated-operands"><span class="secno">5.3.2</span> <span class="content">reloc in unevaluated operands</span></a>
        <li><a href="#reloc-dot-reloc-ill-formed-showcase"><span class="secno">5.3.3</span> <span class="content">Examples</span></a>
        <li><a href="#conditional-reloc"><span class="secno">5.3.4</span> <span class="content">Conditional destruction</span></a>
       </ol>
      <li>
       <a href="#reloc-ctor"><span class="secno">5.4</span> <span class="content">Relocation constructor</span></a>
       <ol class="toc">
        <li><a href="#reloc-ctor-is-2nd-dtor"><span class="secno">5.4.1</span> <span class="content">The relocation constructor is a second destructor</span></a>
        <li>
         <a href="#reloc-ctor-declaration"><span class="secno">5.4.2</span> <span class="content">Declaration</span></a>
         <ol class="toc">
          <li><a href="#reloc-ctor-declaration-implicit"><span class="secno">5.4.2.1</span> <span class="content">Implicit declaration</span></a>
          <li><a href="#reloc-ctor-declaration-deleted"><span class="secno">5.4.2.2</span> <span class="content">Deleted implicitly-declared or defaulted relocation constructor</span></a>
          <li><a href="#trivial-relocation"><span class="secno">5.4.2.3</span> <span class="content">Trivial relocation</span></a>
         </ol>
        <li>
         <a href="#reloc-ctor-definition"><span class="secno">5.4.3</span> <span class="content">Definition</span></a>
         <ol class="toc">
          <li><a href="#reloc-ctor-dtor-def"><span class="secno">5.4.3.1</span> <span class="content">Destruction of the source object</span></a>
          <li><a href="#reloc-dtor-virtual-bases"><span class="secno">5.4.3.2</span> <span class="content">Virtual bases</span></a>
          <li><a href="#reloc-ctor-default-definition"><span class="secno">5.4.3.3</span> <span class="content">Default definition</span></a>
          <li><a href="#reloc-ctor-user-definition"><span class="secno">5.4.3.4</span> <span class="content">User-provided definition</span></a>
          <li><a href="#reloc-ctor-delegate"><span class="secno">5.4.3.5</span> <span class="content">Delegating relocation constructor</span></a>
          <li><a href="#reloc-ctor-additional-params"><span class="secno">5.4.3.6</span> <span class="content">Additional parameters</span></a>
         </ol>
        <li><a href="#reloc-ctor-invoke"><span class="secno">5.4.4</span> <span class="content">Invocation</span></a>
        <li>
         <a href="#virtual-reloc-ctor"><span class="secno">5.4.5</span> <span class="content">Virtual relocation constructor</span></a>
         <ol class="toc">
          <li><a href="#virtual-reloc-ctor-decl"><span class="secno">5.4.5.1</span> <span class="content">Declaration</span></a>
          <li><a href="#virtual-reloc-ctor-def"><span class="secno">5.4.5.2</span> <span class="content">Definition</span></a>
          <li><a href="#virtual-reloc-ctor-def-ill-formed"><span class="secno">5.4.5.3</span> <span class="content">Ill-fomed definition</span></a>
         </ol>
       </ol>
      <li>
       <a href="#reloc-assign-operator"><span class="secno">5.5</span> <span class="content">Relocation assignment operator</span></a>
       <ol class="toc">
        <li>
         <a href="#reloc-assign-declaration"><span class="secno">5.5.1</span> <span class="content">Declaration</span></a>
         <ol class="toc">
          <li><a href="#reloc-assign-operator-implicit"><span class="secno">5.5.1.1</span> <span class="content">Implicit declaration</span></a>
          <li><a href="#reloc-assign-declaration-deleted"><span class="secno">5.5.1.2</span> <span class="content">Deleted implicitly-declared or defaulted relocation assignment operator</span></a>
         </ol>
        <li>
         <a href="#aliased-reloc-assign"><span class="secno">5.5.2</span> <span class="content">Relocation assignment operator parameter relocation elision</span></a>
         <ol class="toc">
          <li><a href="#aliased-reloc-assign-declaration"><span class="secno">5.5.2.1</span> <span class="content">Elision at declaration level</span></a>
          <li><a href="#aliased-reloc-assign-definition"><span class="secno">5.5.2.2</span> <span class="content">Elision at definition level</span></a>
         </ol>
        <li>
         <a href="#reloc-assign-definition"><span class="secno">5.5.3</span> <span class="content">Definition</span></a>
         <ol class="toc">
          <li><a href="#reloc-assign-default-definition"><span class="secno">5.5.3.1</span> <span class="content">Default definition</span></a>
          <li><a href="#reloc-assign-user-definition"><span class="secno">5.5.3.2</span> <span class="content">Possible user definitions</span></a>
         </ol>
        <li><a href="#reloc-assign-invoke"><span class="secno">5.5.4</span> <span class="content">Invocation</span></a>
       </ol>
      <li>
       <a href="#overload-resolution"><span class="secno">5.6</span> <span class="content">Overload resolution</span></a>
       <ol class="toc">
        <li><a href="#overload-against-P2665R0"><span class="secno">5.6.1</span> <span class="content">Comparison against P2665R0</span></a>
       </ol>
      <li>
       <a href="#structured-decomposition"><span class="secno">5.7</span> <span class="content">Structured decomposition</span></a>
       <ol class="toc">
        <li><a href="#structured-decomposition-discussion"><span class="secno">5.7.1</span> <span class="content">Discussion</span></a>
        <li><a href="#structured-decomposition-declaration"><span class="secno">5.7.2</span> <span class="content">Structured decomposition declaration</span></a>
        <li>
         <a href="#structured-decomposition-obj-decomposition"><span class="secno">5.7.3</span> <span class="content">Structured decomposition protocols</span></a>
         <ol class="toc">
          <li><a href="#structured-decomposition-array"><span class="secno">5.7.3.1</span> <span class="content">array protocol</span></a>
          <li><a href="#structured-decomposition-get_all"><span class="secno">5.7.3.2</span> <span class="content">get_all protocol</span></a>
          <li><a href="#structured-decomposition-dm"><span class="secno">5.7.3.3</span> <span class="content">data members protocol</span></a>
          <li><a href="#structured-decomposition-tuple"><span class="secno">5.7.3.4</span> <span class="content">Implementation-defined library support</span></a>
          <li><a href="#structured-decomposition-implem"><span class="secno">5.7.3.5</span> <span class="content">Possible get_all implementations</span></a>
         </ol>
       </ol>
     </ol>
    <li>
     <a href="#proposed-lib-changes"><span class="secno">6</span> <span class="content">Proposed library changes</span></a>
     <ol class="toc">
      <li>
       <a href="#std-mem-header"><span class="secno">6.1</span> <span class="content">Memory header</span></a>
       <ol class="toc">
        <li><a href="#std-construct_at"><span class="secno">6.1.1</span> <span class="content">std::construct_at</span></a>
        <li><a href="#std-reloc_and_uninitialize"><span class="secno">6.1.2</span> <span class="content">std::reloc_and_uninitialize and std::reloc_and_reclaim</span></a>
        <li><a href="#std-uninitialized_relocate"><span class="secno">6.1.3</span> <span class="content">std::uninitialized_relocate</span></a>
       </ol>
      <li><a href="#std-type_traits-header"><span class="secno">6.2</span> <span class="content">Type traits header</span></a>
     </ol>
    <li>
     <a href="#discuss"><span class="secno">7</span> <span class="content">Discussions</span></a>
     <ol class="toc">
      <li>
       <a href="#abi"><span class="secno">7.1</span> <span class="content">Potential ABI changes</span></a>
       <ol class="toc">
        <li><a href="#callee-destroy-abi"><span class="secno">7.1.1</span> <span class="content">relocate-only function parameters</span></a>
        <li><a href="#prvalue-assign-op-abi"><span class="secno">7.1.2</span> <span class="content">prvalue assignment operator</span></a>
       </ol>
      <li>
       <a href="#object-decomposition-alt"><span class="secno">7.2</span> <span class="content">Object decomposition alternatives</span></a>
       <ol class="toc">
        <li><a href="#dot-reloc-take-1"><span class="secno">7.2.1</span> <span class="content">The dot-reloc operator</span></a>
        <li><a href="#dot-reloc-take-2"><span class="secno">7.2.2</span> <span class="content">The dot-reloc operator (take 2)</span></a>
        <li><a href="#dot-reloc-no-longer"><span class="secno">7.2.3</span> <span class="content">The proposed approach</span></a>
       </ol>
      <li><a href="#reloc-new-keyword"><span class="secno">7.3</span> <span class="content">Why a new keyword?</span></a>
      <li>
       <a href="#future-directions"><span class="secno">7.4</span> <span class="content">Future directions</span></a>
       <ol class="toc">
        <li><a href="#future-capture-value"><span class="secno">7.4.1</span> <span class="content">More perfect forwarding</span></a>
        <li><a href="#solve-discarded-reloc-expr"><span class="secno">7.4.2</span> <span class="content">discarded reloc expression</span></a>
       </ol>
      <li><a href="#easier-cpp"><span class="secno">7.5</span> <span class="content">Will it make C++ easier?</span></a>
     </ol>
    <li>
     <a href="#references"><span class="secno"></span> <span class="content">References</span></a>
     <ol class="toc">
      <li><a href="#informative"><span class="secno"></span> <span class="content">Informative References</span></a>
     </ol>
   </ol>
  </nav>
  <main>
   <h2 class="heading settled" data-level="1" id="intro"><span class="secno">1. </span><span class="content">Overview</span><a class="self-link" href="#intro"></a></h2>
   <p>Move semantics were introduced with C++11, and have improved the language in
many aspects. However they have also brought their lot of defects:</p>
   <ul>
    <li data-md>
     <p><code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-></code> does not move ;</p>
    <li data-md>
     <p>moved-from objects are in an unspecified state, and more often than not,
must not be reused ;</p>
    <li data-md>
     <p>constant objects cannot be moved ;</p>
    <li data-md>
     <p>classes that want to support move-semantics must either have a natural empty
state (like strings, containers or smart pointers)
or force one into their design, usually creating a loophole in their class invariant.</p>
   </ul>
   <p>We propose to resolve all these issues with a new kind of operation: "relocation".
Relocation is the operation of constructing a
new target object while simultaneously destructing the source object.
Relocation will happen thanks to a new keyword <code class="highlight"><c- n>reloc</c-></code> and a new relocation
constructor (with signature <code class="highlight"><c- n>T</c-><c- p>(</c-><c- n>T</c-><c- p>)</c-></code>).</p>
<pre class="language-c++ highlight"><c- c1>// with: void foo(non_null&lt;unique_ptr&lt;T>>)</c->

<c- n>non_null</c-><c- o>&lt;</c-><c- n>unique_ptr</c-><c- o>&lt;</c-><c- n>T</c-><c- o>>></c-> <c- k>const</c-> <c- n>ptr</c-><c- p>{</c-><c- n>new</c-> <c- n>T</c-><c- p>};</c->
<c- n>ptr</c-><c- o>-></c-><c- n>do_stuff</c-><c- p>();</c->
<c- n>foo</c-><c- p>(</c-><c- n>reloc</c-> <c- n>ptr</c-><c- p>);</c->
<c- c1>// ptr cannot be reused or else the program is ill-formed</c->
</pre>
   <p>This tackles every flaw not solved by move-semantics:</p>
   <ul>
    <li data-md>
     <p><code class="highlight"><c- n>reloc</c-></code> does perform the relocation ;</p>
    <li data-md>
     <p>relocated objects cannot be re-used, or else the program is ill-formed ;</p>
    <li data-md>
     <p>relocation disregards cv-qualifiers, so constant objects can be relocated ;</p>
    <li data-md>
     <p>classes that want to support relocation can do so without breaking their
class invariant, as the relocated-from object is simultaneously destructed.</p>
   </ul>
   <p>Another major addition of this proposal is the object decomposition feature.
Object decomposition enables to relocate data members of compound types
(such as <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>pair</c-></code>) and to easily write used-defined relocation constructors
and relocation assignment operators.</p>
<pre class="language-c++ highlight"><c- n>pair</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- k>const</c-><c- p>,</c-> <c- b>int</c-><c- o>></c-> <c- k>const</c-> <c- n>keyValue</c-> <c- n>reloc</c-> <c- o>=</c-> <c- n>extractKV</c-><c- p>();</c->
<c- n>storeKey</c-><c- p>(</c-><c- n>reloc</c-> <c- n>keyValue</c-><c- o>::</c-><c- n>first</c-><c- p>);</c->
</pre>
<pre class="language-c++ highlight"><c- n>template</c-> <c- o>&lt;</c-><c- n>class</c-> <c- n>First</c-><c- p>,</c-> <c- n>class</c-> <c- n>Second</c-><c- o>></c->
<c- n>class</c-> <c- n>MyPair</c->
<c- p>{</c->
<c- n>public</c-><c- o>:</c->
    <c- n>First</c-> <c- n>first</c-><c- p>;</c->
    <c- n>Second</c-> <c- n>second</c-><c- p>;</c->

    <c- c1>// user-defined relocation constructor (could have been defaulted)</c->
    <c- n>MyPair</c-><c- p>(</c-><c- n>MyPair</c-> <c- n>rhs</c-> <c- n>reloc</c-><c- p>)</c-> <c- o>:</c-> <c- n>first</c-><c- p>{</c-><c- n>reloc</c-> <c- n>rhs</c-><c- o>::</c-><c- n>first</c-><c- p>},</c-> <c- n>second</c-><c- p>{</c-><c- n>reloc</c-> <c- n>rhs</c-><c- o>::</c-><c- n>second</c-><c- p>}</c-> <c- p>{}</c->
<c- p>};</c->
</pre>
   <p>The <code class="highlight"><c- n>reloc</c-></code> keyword in the object definition indicates that the object
is <em>decomposed</em>, which allows the relocation of its subobjects with <code class="highlight"><c- n>reloc</c-></code>.</p>
   <p>This proposal introduces:</p>
   <ul>
    <li data-md>
     <p>two new special member functions: a relocation constructor <code class="highlight"><c- n>T</c-><c- p>(</c-><c- n>T</c-><c- p>)</c-></code> and a relocation
assignment operator <code class="highlight"><c- n>T</c-><c- o>&amp;</c-> <c- k>operator</c-><c- o>=</c-><c- p>(</c-><c- n>T</c-><c- p>)</c-></code> ;</p>
    <li data-md>
     <p>a new keyword: <code class="highlight"><c- n>reloc</c-></code> which backs a new operator: <code class="highlight"><c- n>reloc</c-></code> and the object
decomposition feature ;</p>
    <li data-md>
     <p>slight changes to overload resolution rules ;</p>
    <li data-md>
     <p>might introduce ABI breaks to some functions (opt-in).</p>
   </ul>
   <p>This proposal does not introduce a new value category: instead it completes C++
tripartite value system as we propose relocation to happen from prvalues.</p>
   <h3 class="heading settled" data-level="1.1" id="changes"><span class="secno">1.1. </span><span class="content">Changes from previous revisions of P2785</span><a class="self-link" href="#changes"></a></h3>
   <h4 class="heading settled" data-level="1.1.1" id="changes-from-r3"><span class="secno">1.1.1. </span><span class="content">Changes from P2785R3</span><a class="self-link" href="#changes-from-r3"></a></h4>
   <h5 class="heading settled" data-level="1.1.1.1" id="changes-from-r3-motivation"><span class="secno">1.1.1.1. </span><span class="content">Motivation</span><a class="self-link" href="#changes-from-r3-motivation"></a></h5>
   <p>The motivation section is more complete, giving more explanations, describing
where today’s C++ falls short, how we intend to improve, and each time illustrated with an
example.</p>
   <h5 class="heading settled" data-level="1.1.1.2" id="changes-from-r3-dot-reloc"><span class="secno">1.1.1.2. </span><span class="content">Generalization of object decomposition</span><a class="self-link" href="#changes-from-r3-dot-reloc"></a></h5>
   <p>One of the major changes we introduced is the generalization of the decomposition
feature, which was introduced by the "decomposing functions".
The <code class="highlight"><c- n>reloc</c-></code> keyword can now be used to decompose any object, not only
the <code class="highlight"><c- k>this</c-></code> parameter of a member function.
This has several advantages:</p>
   <ul>
    <li data-md>
     <p>it greatly simplifies the writing and the understanding of the relocation constructor
and reloc assignment operator ;</p>
    <li data-md>
     <p>it simplifies the handling of relocate-only subobjects in user code ;</p>
    <li data-md>
     <p>it removes the <em>decomposing functions</em> feature as they are being replaced by
a more generic object decomposition feature ;</p>
    <li data-md>
     <p>the whole proposal is more unified as all those changes are now built on top
of the <em>object decomposition</em> feature.</p>
   </ul>
   <h5 class="heading settled" data-level="1.1.1.3" id="changes-from-r3-value-param-ownership"><span class="secno">1.1.1.3. </span><span class="content">Value parameter ownership rule</span><a class="self-link" href="#changes-from-r3-value-param-ownership"></a></h5>
   <p>In P2785R3, we mandated that a function taking a relocate-only type as value
parameter <strong>must</strong> have control over its lifetime. This might break some ABIs
on rare occasions, but in a controlled way.</p>
   <p>In R4, we take a slightly less conservative approach: <em>any function
that takes a parameter by value, whose type provides a relocation constructor</em> <strong>but no move constructor</strong>, <em>must have control over the lifetime of that parameter.</em></p>
   <p>Discussion about this change is detailed in the <a href="#reloc-with-function-param">reloc with function parameters</a> section.</p>
   <h5 class="heading settled" data-level="1.1.1.4" id="changes-from-r3-stl"><span class="secno">1.1.1.4. </span><span class="content">Library changes</span><a class="self-link" href="#changes-from-r3-stl"></a></h5>
   <p>In P2785R3, we enumerated all the desired changes in the STL to properly
support relocation. Now the suggested library changes only contain the bare
minimum for library writers. A more comprehensive list of changes
will be proposed separately, depending on the reception of the current proposal.</p>
   <h4 class="heading settled" data-level="1.1.2" id="changes-from-older"><span class="secno">1.1.2. </span><span class="content">Changes from older revisions</span><a class="self-link" href="#changes-from-older"></a></h4>
   <p>R0, R1 and R2 revisions are internal versions bumps that were
never officially presented.</p>
   <h2 class="heading settled" data-level="2" id="motivation"><span class="secno">2. </span><span class="content">Motivation</span><a class="self-link" href="#motivation"></a></h2>
   <h3 class="heading settled" data-level="2.1" id="const-vs-move"><span class="secno">2.1. </span><span class="content">More constness!</span><a class="self-link" href="#const-vs-move"></a></h3>
   <p>Automatic objects are recommended by various guidelines to be constant, since a constant object
will not change throughout its lifetime, simplifying reasoning about program state both for
humans (coders, reviewers, maintainers) and for machines (compilers, tooling).
In addition when used in class design, <code class="highlight"><c- k>const</c-></code> on member functions and data members
enables to explicitly state class invariants. Last, allowing an object
to be <code class="highlight"><c- k>const</c-></code> throughout its lifetime but give up its resources at the end of its lifetime allows
for better, safer code.</p>
   <p>However <code class="highlight"><c- k>const</c-></code> usefulness is greatly diminished because of move-semantics.
The move constructor cannot work with a constant source object.
Hence for those, the program either
silently falls back to calling their copy constructor, or is simply ill-formed...</p>
<pre class="language-c++ highlight"><c- c1>// with: void bar(A);</c->

<c- n>A</c-> <c- k>const</c-> <c- n>a</c-> <c- o>=</c-> <c- n>someFunc</c-><c- p>();</c->
<c- n>bar</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>a</c-><c- p>));</c-> <c- c1>// silently calls A’s copy ctor, performing a deep copy...</c->
</pre>
   <p>Declaring an object with <code class="highlight"><c- k>const</c-></code> may have unwanted side-effects. As a consequence:</p>
   <ul>
    <li data-md>
     <p>some developers will use <code class="highlight"><c- k>const</c-></code> to naively declare constant objects as so - <em>as one would
expect from the language</em> - while being unaware of the side-effects. This may
lead to unoptimized code, with the copy constructor being called <em>silently</em> while <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-></code> is explicitly called ;</p>
    <li data-md>
     <p>knowledgeable developers will rather not use it if they can foresee the
negative side-effect, which leads to poorer code (see the benefits of <code class="highlight"><c- k>const</c-></code> described above), but can make use of the move constructor.</p>
   </ul>
   <p>This is a missed opportunity and it leads to poorer code. The
proposed relocation semantics solves this problem: constant objects can be relocated,
they are just destroyed when done so.</p>
<pre class="language-c++ highlight"><c- n>A</c-> <c- k>const</c-> <c- n>a</c-> <c- o>=</c-> <c- n>someFunc</c-><c- p>();</c->
<c- n>bar</c-><c- p>(</c-><c- n>reloc</c-> <c- n>a</c-><c- p>);</c->
</pre>
   <h4 class="heading settled" data-level="2.1.1" id="const-var"><span class="secno">2.1.1. </span><span class="content">Constant local variables cannot be moved</span><a class="self-link" href="#const-var"></a></h4>
   <p>We also have to consider that the Immediately Invoked Function Expressions (IIFE)
decouples the possibilities to declare constant variables (even when they have
a complex initialization routine), were they not hindered down
by <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-></code>.</p>
   <p>Consider the following code snippets:</p>
   <table>
    <tbody>
     <tr>
      <th>Before
      <th>Constified + relocation (IIFE)
     <tr>
      <td valign="top">
<pre class="language-c++ highlight"><c- b>void</c-> <c- nf>foo</c-><c- p>(</c-><c- n>A</c-> <c- n>a</c-><c- p>,</c-> <c- n>B</c-> <c- n>b</c-><c- p>,</c-> <c- n>C</c-> <c- n>c</c-><c- p>);</c->

<c- b>void</c-> <c- nf>bar</c-><c- p>()</c->
<c- p>{</c->
  <c- n>A</c-> <c- n>a</c-> <c- o>=</c-> <c- n>getA</c-><c- p>();</c->

  <c- n>B</c-> <c- n>b</c-> <c- o>=</c-> <c- n>getB</c-><c- p>(</c-><c- n>a</c-><c- p>);</c->
  <c- n>b</c-><c- p>.</c-><c- n>processData</c-><c- p>();</c->

  <c- n>C</c-> <c- n>c</c-> <c- o>=</c-> <c- n>getC</c-><c- p>(</c-><c- n>a</c-><c- p>.</c-><c- n>token</c-><c- p>(),</c-> <c- n>b</c-><c- p>);</c->
  <c- n>c</c-><c- p>.</c-><c- n>fetchAll</c-><c- p>();</c->
  <c- n>c</c-><c- p>.</c-><c- n>processData</c-><c- p>();</c->
  <c- n>c</c-><c- p>.</c-><c- n>finalize</c-><c- p>();</c->

  <c- n>foo</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>a</c-><c- p>),</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>b</c-><c- p>),</c->
    <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>c</c-><c- p>));</c->
<c- p>}</c->
</pre>
      <td valign="top">
<pre class="language-c++ highlight"><c- b>void</c-> <c- nf>foo</c-><c- p>(</c-><c- n>A</c-> <c- n>a</c-><c- p>,</c-> <c- n>B</c-> <c- n>b</c-><c- p>,</c-> <c- n>C</c-> <c- n>c</c-><c- p>);</c->

<c- b>void</c-> <c- nf>bar</c-><c- p>()</c->
<c- p>{</c->
  <c- n>A</c-> <c- k>const</c-> <c- n>a</c-> <c- o>=</c-> <c- n>getA</c-><c- p>();</c->

  <c- n>B</c-> <c- k>const</c-> <c- n>b</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>invoke</c-><c- p>([</c-><c- o>&amp;</c-><c- p>]</c-> <c- p>{</c->
    <c- n>B</c-> <c- n>b</c-> <c- o>=</c-> <c- n>getB</c-><c- p>(</c-><c- n>a</c-><c- p>);</c->
    <c- n>b</c-><c- p>.</c-><c- n>processData</c-><c- p>();</c->
    <c- k>return</c-> <c- n>b</c-><c- p>;</c->
  <c- p>});</c->

  <c- n>C</c-> <c- k>const</c-> <c- n>c</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>invoke</c-><c- p>([</c-><c- o>&amp;</c-><c- p>]</c-> <c- p>{</c->
    <c- n>C</c-> <c- n>c</c-> <c- o>=</c-> <c- n>getC</c-><c- p>(</c-><c- n>a</c-><c- p>.</c-><c- n>token</c-><c- p>(),</c-> <c- n>b</c-><c- p>);</c->
    <c- n>c</c-><c- p>.</c-><c- n>fetchAll</c-><c- p>();</c->
    <c- n>c</c-><c- p>.</c-><c- n>processData</c-><c- p>();</c->
    <c- n>c</c-><c- p>.</c-><c- n>finalize</c-><c- p>();</c->
    <c- k>return</c-> <c- n>c</c-><c- p>;</c->
  <c- p>});</c->

  <c- n>foo</c-><c- p>(</c-><c- n>reloc</c-> <c- n>a</c-><c- p>,</c-> <c- n>reloc</c-> <c- n>b</c-><c- p>,</c-> <c- n>reloc</c-> <c- n>c</c-><c- p>);</c->
<c- p>}</c->
</pre>
   </table>
   <p class="note" role="note"><span class="marker">NOTE:</span> We expect the <code class="highlight"><c- n>reloc</c-></code> operator to also multiply the
possibilities to declare constant variables, with or without the IIFE idiom:</p>
   <table>
    <tbody>
     <tr>
      <th>Constified + relocation (no IIFE)
     <tr>
      <td valign="top">
<pre class="language-c++ highlight"><c- b>void</c-> <c- nf>foo</c-><c- p>(</c-><c- n>A</c-> <c- n>a</c-><c- p>,</c-> <c- n>B</c-> <c- n>b</c-><c- p>,</c-> <c- n>C</c-> <c- n>c</c-><c- p>);</c->

<c- b>void</c-> <c- nf>bar</c-><c- p>()</c->
<c- p>{</c->
  <c- n>A</c-> <c- k>const</c-> <c- n>a</c-> <c- o>=</c-> <c- n>getA</c-><c- p>();</c->

  <c- n>B</c-> <c- n>b_mut</c-> <c- o>=</c-> <c- n>getB</c-><c- p>(</c-><c- n>a</c-><c- p>);</c->
  <c- n>b_mut</c-><c- p>.</c-><c- n>processData</c-><c- p>();</c->
  <c- n>B</c-> <c- k>const</c-> <c- n>b</c-> <c- o>=</c-> <c- n>reloc</c-> <c- n>b_mut</c-><c- p>;</c->

  <c- n>C</c-> <c- n>c_mut</c-> <c- o>=</c-> <c- n>getC</c-><c- p>(</c-><c- n>a</c-><c- p>.</c-><c- n>token</c-><c- p>(),</c-> <c- n>b</c-><c- p>);</c->
  <c- n>c_mut</c-><c- p>.</c-><c- n>fetchAll</c-><c- p>();</c->
  <c- n>c_mut</c-><c- p>.</c-><c- n>processData</c-><c- p>();</c->
  <c- n>c_mut</c-><c- p>.</c-><c- n>finalize</c-><c- p>();</c->
  <c- n>C</c-> <c- k>const</c-> <c- n>c</c-> <c- o>=</c-> <c- n>reloc</c-> <c- n>c_mut</c-><c- p>;</c->

  <c- n>foo</c-><c- p>(</c-><c- n>reloc</c-> <c- n>a</c-><c- p>,</c-> <c- n>reloc</c-> <c- n>b</c-><c- p>,</c-> <c- n>reloc</c-> <c- n>c</c-><c- p>);</c->
<c- p>}</c->
</pre>
   </table>
   <p>The versions with <code class="highlight"><c- n>reloc</c-></code> can benefit from constant variables.
Their initialization code
is strictly enclosed in the lambda expressions (IFFE version) or relocated
to their const version once initialized (no IFFE). By looking at the code, we
know that each variable will remain unmodified for the remaining of the function,
even when used in the initialization of other variables.</p>
   <p>The <code class="highlight"><c- n>reloc</c-></code> keyword relocates the objects to the parameter slots of <code class="highlight"><c- n>foo</c-></code>. <code class="highlight"><c- n>a</c-></code>, <code class="highlight"><c- n>b</c-></code>, and <code class="highlight"><c- n>c</c-></code> have reached their end of life when the call to <code class="highlight"><c- n>foo</c-></code> completes and
can no longer be used in <code class="highlight"><c- n>bar</c-></code>. In particular, should <code class="highlight"><c- n>a</c-></code>, <code class="highlight"><c- n>b</c-></code> and <code class="highlight"><c- n>c</c-></code> be relocatable,
their destructor will not even be called.</p>
   <h4 class="heading settled" data-level="2.1.2" id="const-data-members"><span class="secno">2.1.2. </span><span class="content">Constant data members</span><a class="self-link" href="#const-data-members"></a></h4>
   <p>It’s not uncommon to find in production codebase things like this:</p>
<pre class="language-c++ highlight"><c- n>class</c-> <c- n>SomeType</c->
<c- p>{</c->
<c- n>public</c-><c- o>:</c->
    <c- c1>// some parameterized constructor</c->
    <c- c1>// SomeType(...)</c->

    <c- n>SomeType</c-><c- p>(</c-><c- n>SomeType</c-><c- o>&amp;&amp;</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->

<c- n>private</c-><c- o>:</c->
    <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- k>const</c-> <c- n>_key1</c-><c- p>;</c->
    <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- k>const</c-> <c- n>_key2</c-><c- p>;</c->
    <c- b>int</c-> <c- n>_val</c-><c- p>;</c->
<c- p>};</c->
</pre>
   <p>Here the developer innocently qualified <code class="highlight"><c- n>_key1</c-></code> and <code class="highlight"><c- n>_key2</c-></code> as constant.
In their mind, their value was never to change in the lifetime of the object.
This being part of the class invariant, it only feels natural to enforce the
class invariant in the code, with the <code class="highlight"><c- k>const</c-></code> qualifier.</p>
   <p>However the experienced developer will have noticed the incurred performance drawback:
the move constructor, because of <code class="highlight"><c- k>const</c-></code>, will be forced to make a deep copy
of <code class="highlight"><c- n>_key1</c-></code> and <code class="highlight"><c- n>_key2</c-></code> (via std::string’s copy constructor). This gives an even
bitter taste when we know that
the moved-from object will pretty likely be destructed right after, meaning
that the deep copy will have been done for nothing.</p>
   <p>This issue is solved with relocation:</p>
   <table>
    <tbody>
     <tr>
      <th>Before (fixed)
      <th>After
     <tr>
      <td valign="top">
<pre class="language-c++ highlight"><c- n>class</c-> <c- n>SomeType</c->
<c- p>{</c->
<c- n>public</c-><c- o>:</c->
  <c- c1>// some parameterized constructor</c->
  <c- c1>// SomeType(...)</c->

  <c- n>SomeType</c-><c- p>(</c-><c- n>SomeType</c-><c- o>&amp;&amp;</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->

<c- n>private</c-><c- o>:</c->
  <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>_key1</c-><c- p>;</c-> <c- d>/* const but cannot</c->
<c- d>    mark it so because of the</c->
<c- d>    move constructor */</c->
  <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>_key2</c-><c- p>;</c-> <c- d>/* const but cannot</c->
<c- d>    mark it so because of the</c->
<c- d>    move constructor */</c->

  <c- b>int</c-> <c- n>_val</c-><c- p>;</c->
<c- p>};</c->
</pre>
      <td valign="top">
<pre class="language-c++ highlight"><c- n>class</c-> <c- n>SomeType</c->
<c- p>{</c->
<c- n>public</c-><c- o>:</c->
  <c- c1>// some parameterized constructor</c->
  <c- c1>// SomeType(...)</c->

  <c- n>SomeType</c-><c- p>(</c-><c- n>SomeType</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->

<c- n>private</c-><c- o>:</c->
  <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- k>const</c-> <c- n>_key1</c-><c- p>;</c->
  <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- k>const</c-> <c- n>_key2</c-><c- p>;</c->
  <c- b>int</c-> <c- n>_val</c-><c- p>;</c->
<c- p>};</c->
</pre>
   </table>
   <p>See how the code becomes clearer: class invariant can be written in the code
instead of comments, which leads to a code that is both more readable and
robust.</p>
   <p><em>This is not an isolated example</em>. In fact, we invite the reader to think of all
the places that could have benefited from a constant data member but didn’t because
of this issue. How much clearer the code would have been, had you been able
to write <code class="highlight"><c- k>const</c-></code>?</p>
   <p>Let’s illustrate this with a final example. Consider a <code class="highlight"><c- n>flat_map</c-></code> implementation.
As a <code class="highlight"><c- n>flat_map</c-></code> implements an associative container, we know for a fact that the keys
of that container will never change. We could write it quite easily in our class
invariant:</p>
<pre class="language-c++ highlight"><c- n>template</c-> <c- o>&lt;</c-><c- n>class</c-> <c- n>Key</c-><c- p>,</c-> <c- n>class</c-> <c- n>Val</c-><c- o>></c->
<c- n>class</c-> <c- n>MyFlatMap</c->
<c- p>{</c->
<c- n>public</c-><c- o>:</c->
    <c- c1>// [...]</c->

<c- n>private</c-><c- o>:</c->
    <c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>pair</c-><c- o>&lt;</c-><c- n>Key</c-> <c- k>const</c-><c- p>,</c-> <c- n>Val</c-><c- o>>></c-> <c- n>_map</c-><c- p>;</c->
<c- p>};</c->
</pre>
   <p>However, as of today,
this will lead to a deep copy of some range of keys when a new item is inserted
anywhere but at the end of <code class="highlight"><c- n>_map</c-></code>, or when <code class="highlight"><c- n>_map</c-></code> needs to grow.
Support for relocation in the language (and in the STL) will enable to write <code class="highlight"><c- k>const</c-></code> with no performance hit.</p>
   <h3 class="heading settled" data-level="2.2" id="reloc-only-support"><span class="secno">2.2. </span><span class="content">Support for relocate-only types</span><a class="self-link" href="#reloc-only-support"></a></h3>
   <p>As of today, C++ provides very little support for class-types which provide
no copy and no move constructors. Such objects are impractical to handle, for they
can only be:</p>
   <ul>
    <li data-md>
     <p>constructed as a function local variable ;</p>
    <li data-md>
     <p>returned from said function if copy-elision is guaranteed ;</p>
    <li data-md>
     <p>constructed in-place in a node-based container ;</p>
    <li data-md>
     <p>or constructed in-place in the parameter slot of another function.</p>
   </ul>
   <p>We cannot however, perform any operation that will move or copy the object to
another address in memory:</p>
   <ul>
    <li data-md>
     <p>we cannot pass such objects by value in the parameter slots of other functions,
unless the object is constructed in the parameter slot.</p>
    <li data-md>
     <p>Such types cannot be stored in any non node-based containers. Node-based
containers have a performance overhead as they require more
memory allocations. The node-based property may not be desired by users
but they are forced to pay for it anyway as there is no support for such
types in other containers.</p>
   </ul>
   <p>Relocation fixes those issues by bringing support for relocate-only types.
Thanks to relocation, relocate-only types can for instance be stored in a <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>vector</c-></code> or passed from functions to functions.</p>
   <h4 class="heading settled" data-level="2.2.1" id="motivation-accidental-relocate-only-types"><span class="secno">2.2.1. </span><span class="content">Accidental relocate-only types</span><a class="self-link" href="#motivation-accidental-relocate-only-types"></a></h4>
   <p>Some classes do need to be immovable by design (like <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>mutex</c-></code>) ;
those types can perfectly remain so with this proposal. However there is still
the case of some types which are accidentally made immovable, because they are
being wrapped with another type, or merely because of their cv-qualifiers
(look no further than <code class="highlight"><c- k>const</c-></code>).</p>
   <p>Let’s us consider the <code class="highlight"><c- n>gsl</c-><c- o>::</c-><c- n>not_null</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>unique_ptr</c-><c- o>&lt;</c-><c- n>T</c-><c- o>>></c-></code> case for a moment. <code class="highlight"><c- n>gsl</c-><c- o>::</c-><c- n>not_null</c-></code> inhibits
the move constructor, as a moved-from pointer would be null and break the class invariant.
In turn <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>unique_ptr</c-></code> inhibits the copy constructor because of its ownership policy.
Hence this type is non-copyable and non-movable. Another example is simply <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>unique_ptr</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-> <c- k>const</c-></code>, where the qualifier inhibits the move constructor...</p>
   <p>Those objects are legitimate since
they improve code correctness (the user need not check whether they are empty,
or are sure the pointed address hasn’t changed) and performance. However, we
choose not to use such types in our code because we know how impractical they
are to handle, especially if we know they will need to be moved.</p>
   <p>This is once again a missed opportunity ; our proposal fixes this issue.
With the relocation
semantics in mind, this would be allowed: each time <code class="highlight"><c- n>gsl</c-><c- o>::</c-><c- n>not_null</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>unique_ptr</c-><c- o>&lt;</c-><c- n>T</c-><c- o>>></c-></code> or <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>unique_ptr</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-> <c- k>const</c-></code> are moved in memory, the previous instance is simultaneously destroyed (very often in practice,
this simply means the memory is moved as if by <code class="highlight"><c- n>memcpy</c-></code>, and the memory occupied
by the source object just becomes uninitialized.
In particular, the source object’s destructor is not called).</p>
   <h4 class="heading settled" data-level="2.2.2" id="motivation-never-empty"><span class="secno">2.2.2. </span><span class="content">Move constructor breaks class invariant</span><a class="self-link" href="#motivation-never-empty"></a></h4>
   <p>In framework code it is a relatively everyday task to write helper classes that are
constructed to own some resource, passed around from place to place, and then destroyed,
cleaning up the resource in the destructor.</p>
   <p>Move semantics for such classes requires
identifying or adding an appropriate empty state, writing a move constructor, and
adding checks to the destructor; all of these inhibit performance and are opportunities
to introduce bugs. Relocation would replace all of this with a single defaulted special
member function declaration.</p>
   <p>For instance, consider a file descriptor class, which opens a file in its
constructor (throws in case of failure), and closes it in its destructor.</p>
   <table>
    <tbody>
     <tr>
      <th>Before
      <th>After
     <tr>
      <td valign="top">
<pre class="language-c++ highlight"><c- n>class</c-> <c- n>FileDesc</c->
<c- p>{</c->
<c- n>public</c-><c- o>:</c->
  <c- c1>// some parameterized constructor, which</c->
  <c- c1>// guarantees _fd != -1 or else throws</c->
  <c- c1>// FileDesc(...)</c->

  <c- o>~</c-><c- n>FileDesc</c-><c- p>()</c->
  <c- p>{</c-> <c- k>if</c-> <c- p>(</c-><c- n>_fd</c-> <c- o>!=</c-> <c- mi>-1</c-><c- p>)</c-> <c- o>::</c-><c- n>close</c-><c- p>(</c-><c- n>_fd</c-><c- p>);</c-> <c- p>}</c->

  <c- n>FileDesc</c-><c- p>(</c-><c- n>FileDesc</c-><c- o>&amp;&amp;</c-> <c- n>rhs</c-><c- p>)</c-> <c- n>noexcept</c-> <c- o>:</c->
    <c- n>_fd</c-><c- p>{</c-><c- n>std</c-><c- o>::</c-><c- n>exchange</c-><c- p>(</c-><c- n>rhs</c-><c- p>.</c-><c- n>_fd</c-><c- p>,</c-> <c- mi>-1</c-><c- p>)}</c-> <c- p>{}</c->

  <c- n>FileDesc</c-><c- o>&amp;</c->
  <c- n>operator</c-><c- o>=</c-><c- p>(</c-><c- n>FileDesc</c-><c- o>&amp;&amp;</c-> <c- n>rhs</c-><c- p>)</c-> <c- n>noexcept</c->
  <c- p>{</c->
    <c- n>_fd</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>exchange</c-><c- p>(</c-><c- n>rhs</c-><c- p>.</c-><c- n>_fd</c-><c- p>,</c-> <c- mi>-1</c-><c- p>);</c->
    <c- k>return</c-> <c- o>*</c-><c- n>this</c-><c- p>;</c->
  <c- p>}</c->

<c- n>private</c-><c- o>:</c->
  <c- b>int</c-> <c- n>_fd</c-><c- p>;</c->
<c- p>};</c->
</pre>
      <td valign="top">
<pre class="language-c++ highlight"><c- n>class</c-> <c- n>FileDesc</c->
<c- p>{</c->
<c- n>public</c-><c- o>:</c->
  <c- c1>// some parameterized constructor, which</c->
  <c- c1>// guarantees _fd != -1 or else throws</c->
  <c- c1>// FileDesc(...)</c->

  <c- o>~</c-><c- n>FileDesc</c-><c- p>()</c-> <c- p>{</c-> <c- o>::</c-><c- n>close</c-><c- p>(</c-><c- n>_fd</c-><c- p>);</c-> <c- p>}</c->

  <c- n>FileDesc</c-><c- p>(</c-><c- n>FileDesc</c-><c- p>)</c-> <c- n>noexcept</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->

  <c- n>FileDesc</c-><c- o>&amp;</c->
  <c- n>operator</c-><c- o>=</c-><c- p>(</c-><c- n>FileDesc</c-><c- p>)</c-> <c- n>noexcept</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->

<c- n>private</c-><c- o>:</c->
  <c- b>int</c-> <c- k>const</c-> <c- n>_fd</c-><c- p>;</c-> <c- c1>//&lt; can now be const</c->
<c- p>};</c->
</pre>
   </table>
   <p>The code on the right is easier to write, to maintain and to understand.
This is because there is no need to handle the <em>moved-from</em> state in which <code class="highlight"><c- n>_fd</c-> <c- o>==</c-> <c- mi>-1</c-></code>. But first and foremost, the version with relocation benefits from
an <strong>improved class-invariant</strong>: it provides at all times a valid file
descriptor. This simplifies reasoning and usability throughout the code.</p>
   <p>We didn’t have this guarantee before because of the move-constructor: the <code class="highlight"><c- n>FileDesc</c-></code> class might not have held a valid file
descriptor, had it been moved-from before.</p>
   <h3 class="heading settled" data-level="2.3" id="motivation-safer-use-after-move"><span class="secno">2.3. </span><span class="content">Safety against use-after-move</span><a class="self-link" href="#motivation-safer-use-after-move"></a></h3>
   <p>Moved-from objects are in an unspecified yet valid state. This is true even
in cases where there exists a natural empty state (like for <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>string</c-></code> or <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>vector</c-></code>). For this reason, it is advised not to reuse a moved-from object
(that is to say, we let it die). However the language does not prevent from
reusing such objects,
which leaves the door open for mistaken uses, ... and sometimes with
disastrous consequences.</p>
   <p>Consider for instance the <em>p-impl</em> idiom, which is commonly used by
library vendors to guard against ABI breaks. The <code class="highlight"><c- n>impl</c-></code> pointer is allocated
in the constructor, but what about the move constructor? Understandably, to
avoid unnecessary allocations, library
vendors often choose to leave the <code class="highlight"><c- n>impl</c-></code> pointer of the moved-from object set to the
null pointer. Unless the moved-from object is re-assigned to something valid,
any further access to its data will trigger the program termination!</p>
   <p>This issue is fixed with relocation, as the language will forbid any reuse
of a relocated object. Reconsidering any <em>p-impl</em> implementation, the move
constructor could simply be dropped in favor of the relocation constructor, and
the <code class="highlight"><c- n>impl</c-></code> pointer would always be valid.</p>
   <p>External tools do exist to detect such <code class="highlight"><c- n>use</c-><c- o>-</c-><c- n>after</c-><c- o>-</c-><c- n>move</c-></code> errors. However we believe
the language can only be improved if we reduce its reliance on external tools,
especially for things as embarrassing as memory safety. Also, tools are fallible
(they may not detect all issues, or may not at all be ran in some companies),
which is less true for compilers (you cannot not run a compiler).</p>
   <h3 class="heading settled" data-level="2.4" id="motivation-early-dtor"><span class="secno">2.4. </span><span class="content">Early destruction</span><a class="self-link" href="#motivation-early-dtor"></a></h3>
   <p>We sometimes need to trigger the destruction of an object early, before
its end of scope. It’s often the case when a particular destructor side-effect
is wanted early:</p>
<pre class="language-c++ highlight"><c- n>std</c-><c- o>::</c-><c- n>experimental</c-><c- o>::</c-><c- n>scope_exit</c-> <c- n>guard</c-><c- p>{[</c-><c- n>this</c-><c- p>]</c-> <c- p>{</c-> <c- n>updateMetrics</c-><c- p>();</c-> <c- p>}};</c->
<c- c1>// [...]</c->
<c- k>if</c-> <c- p>(</c-><c- n>someTest</c-><c- p>())</c->
<c- p>{</c->
    <c- c1>// need to call updateMetrics before modifyMetrics!</c->
    <c- n>guard</c-><c- p>.</c-><c- n>release</c-><c- p>();</c->
    <c- n>updateMetrics</c-><c- p>();</c->
    <c- n>modifyMetrics</c-><c- p>();</c->
<c- p>}</c->
<c- c1>// [...]</c->
</pre>
   <p>There is no clean mechanism to do this today in C++. One way is to wrap the
type into an <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>optional</c-></code> and reset the optional when the destruction of the
contained object is wanted. Another is to move to a temporary.</p>
   <p>As it is done with this paper, relocation provides a clean solution for this
case. <a href="#discarded-reloc-expr">Discarded relocated objects are simply destructed</a>, triggering the desired
effect.</p>
   <table>
    <tbody>
     <tr>
      <th>Before (optional)
     <tr>
      <td valign="top">
<pre class="language-c++ highlight"><c- n>std</c-><c- o>::</c-><c- n>optional</c-> <c- n>guard</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>scope_exit</c-><c- p>{[</c-><c- n>this</c-><c- p>]</c-> <c- p>{</c-> <c- n>updateMetrics</c-><c- p>();</c-> <c- p>}};</c->
<c- c1>// [...]</c->
<c- k>if</c-> <c- p>(</c-><c- n>someTest</c-><c- p>())</c->
<c- p>{</c->
    <c- c1>// need to call updateMetrics before modifyMetrics!</c->
    <c- n>guard</c-><c- p>.</c-><c- n>reset</c-><c- p>();</c->
    <c- n>modifyMetrics</c-><c- p>();</c->
<c- p>}</c->
<c- c1>// [...]</c->
</pre>
   </table>
    <br> 
   <table>
    <tbody>
     <tr>
      <th>Before (Temporary)
     <tr>
      <td valign="top">
<pre class="language-c++ highlight"><c- n>std</c-><c- o>::</c-><c- n>scope_exit</c-> <c- n>guard</c-><c- p>{[</c-><c- n>this</c-><c- p>]</c-> <c- p>{</c-> <c- n>updateMetrics</c-><c- p>();</c-> <c- p>}};</c->
<c- c1>// [...]</c->
<c- k>if</c-> <c- p>(</c-><c- n>someTest</c-><c- p>())</c->
<c- p>{</c->
    <c- c1>// need to call updateMetrics before modifyMetrics!</c->
    <c- p>{</c-> <c- k>auto</c-> <c- n>_</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>guard</c-><c- p>);</c-> <c- p>}</c->
    <c- n>modifyMetrics</c-><c- p>();</c->
<c- p>}</c->
<c- c1>// [...]</c->
</pre>
   </table>
    <br> 
   <table>
    <tbody>
     <tr>
      <th>After
     <tr>
      <td valign="top">
<pre class="language-c++ highlight"><c- n>std</c-><c- o>::</c-><c- n>scope_exit</c-> <c- n>guard</c-><c- p>{[</c-><c- n>this</c-><c- p>]</c-> <c- p>{</c-> <c- n>updateMetrics</c-><c- p>();</c-> <c- p>}};</c->
<c- c1>// [...]</c->
<c- k>if</c-> <c- p>(</c-><c- n>someTest</c-><c- p>())</c->
<c- p>{</c->
    <c- c1>// need to call updateMetrics before modifyMetrics!</c->
    <c- n>reloc</c-> <c- n>guard</c-><c- p>;</c->
    <c- n>modifyMetrics</c-><c- p>();</c->
<c- p>}</c->
<c- c1>// [...]</c->
</pre>
   </table>
   <p>This is not what motivates this proposal, but comes as an added bonus, which
we thought was worth mentioning.</p>
   <h3 class="heading settled" data-level="2.5" id="motivation-teachability"><span class="secno">2.5. </span><span class="content">Teachability</span><a class="self-link" href="#motivation-teachability"></a></h3>
   <p>It is a matter of some confusion for learners that a "moved-from" object still exists and is
accessible, but has an unspecified state. This leads to so-called "use-after-move" bugs, and
requires static analysis passes and coding guidelines to prevent. "What does <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-></code> do?"
is, regrettably, a common "gotcha" question in a certain style of coding interview. In this
matter C++ compares unfavorably to other languages where the "move" operation is destructive
(if trivial) and bars further access to the source object.</p>
   <h3 class="heading settled" data-level="2.6" id="motivation-vs-trivial-relocation"><span class="secno">2.6. </span><span class="content">Versus trivial relocation</span><a class="self-link" href="#motivation-vs-trivial-relocation"></a></h3>
   <p>As will be seen below, trivial relocation provides an incomplete solution to the issues
presented in this section. The primary concern is that of composability; an aggregate of
a self-referential type that cannot be trivially relocated (e.g. <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>string</c-></code> in some
implementations) and a relocate-only type (e.g. a non-null <code class="highlight"><c- n>unique_ptr</c-></code>) can neither be
relocated by move-and-destroy nor trivially relocated. Thus non-trivial relocation
emerges as a requirement.</p>
   <h3 class="heading settled" data-level="2.7" id="motivation-performance"><span class="secno">2.7. </span><span class="content">Library performance</span><a class="self-link" href="#motivation-performance"></a></h3>
   <p>Finally, relocation and especially trivial relocation will bring performance boosts
in many situations. Other proposals make fine work at enumerating all the gains to be had
from trivial relocation (see in particular <a data-link-type="biblio" href="#biblio-p1144r8" title="std::is_trivially_relocatable">[P1144R8]</a>). To summarize, the performance gains
are mainly in containers (std::vector::resize and the likes)
and code size gains from functions that use <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>swap</c-></code>.</p>
   <h2 class="heading settled" data-level="3" id="nomenclature"><span class="secno">3. </span><span class="content">Nomenclature</span><a class="self-link" href="#nomenclature"></a></h2>
   <p>We refer to the <a href="https://wg21.link/intro.defs">Terms and definitions</a> of the C++ Standard,
and to nomenclature introduced therein,
in particular the <a href="https://wg21.link/intro.object">object model</a>.
In addition, we define:</p>
   <h3 class="heading settled" data-level="3.1" id="src-and-target"><span class="secno">3.1. </span><span class="content">Source and target objects</span><a class="self-link" href="#src-and-target"></a></h3>
   <p>Relocation is the act of constructing a new instance while ending the lifetime of an existing one.
This allows destructively stealing its resources, if any.</p>
   <p>The new instance is called the <em>target object</em>.
The existing instance whose lifetime is ended and whose resources
are stolen is called the <em>source object</em>.</p>
   <h3 class="heading settled" data-level="3.2" id="dtor-state"><span class="secno">3.2. </span><span class="content">Destructed state</span><a class="self-link" href="#dtor-state"></a></h3>
   <p>An object is to be in a <em>destructed state</em> if its lifetime has ended because:</p>
   <ul>
    <li data-md>
     <p>its destructor was called, or ;</p>
    <li data-md>
     <p>it was passed to as source object to its relocation constructor.</p>
   </ul>
   <p>It is a
programming error to call the destructor of an object if it is already in a <em>destructed state</em>.
As described in <a href="https://eel.is/c++draft/basic.life#9">[basic.life]</a>,
this has undefined behavior unless the object type is trivial, in which case its destructor
or pseudo-destructor is a no-op.</p>
   <h3 class="heading settled" data-level="3.3" id="parameter-ownership"><span class="secno">3.3. </span><span class="content">Parameter ownership</span><a class="self-link" href="#parameter-ownership"></a></h3>
   <p>The lifetime of function parameters is implementation-defined in C++, but it
is of most importance with relocation. Depending on the function call convention
or ABI, the function may or may not be in charge of the lifetime of its parameters.</p>
   <p>An object is said to be an <em>owned parameter</em> (respectively, an <em>unowned parameter</em>) with regards to a function <code class="highlight"><c- n>f</c-></code> if the object is a parameter of <code class="highlight"><c- n>f</c-></code>, passed by value, and that <code class="highlight"><c- n>f</c-></code> has control (respectively, does not have control) over its lifetime.</p>
   <p>We denote two main parameter passing conventions:</p>
   <ul>
    <li data-md>
     <p><em>caller-destroy</em>: the call site is in charge of the lifetime of the value parameter passed in the function call ;</p>
    <li data-md>
     <p><em>callee-destroy</em>: the function itself is in charge of the lifetime of its value parameters ;</p>
   </ul>
   <p>Depending on the ABI choice, the convention can be per parameter, or apply
to all the function parameters. Other conventions may exist, and they are
still compatible with this proposal.</p>
   <p>For instance, in a function with caller-destroy convention, all its value
parameters are <em>unowned parameters</em>.
Likewise, with callee-destroy, all of its parameters are <em>owned parameters</em>.</p>
   <h2 class="heading settled" data-level="4" id="compare"><span class="secno">4. </span><span class="content">Comparison with existing proposals</span><a class="self-link" href="#compare"></a></h2>
   <p>This proposal introduces the <code class="highlight"><c- n>reloc</c-></code> keyword, which allows users to explicitly
and safely relocate local variables in their code base.</p>
   <p>This proposal is also one of the few (with <a data-link-type="biblio" href="#biblio-p0308r0" title="Valueless Variants Considered Harmful">[P0308R0]</a>), to tackle the case of
relocate-only types. The <code class="highlight"><c- n>reloc</c-></code> keyword thus becomes necessary to safely pass
around such objects in user code.</p>
   <p>Also, all these proposals (but <a data-link-type="biblio" href="#biblio-p0308r0" title="Valueless Variants Considered Harmful">[P0308R0]</a>) aim to optimize the move and destruct
operations into a single memcpy. But there are places where this optimization
could not happen, and we are left with suboptimized move constructor and destructor calls.</p>
   <p>The relocation constructor that we propose offers a customization point, and
especially allows for a more optimized relocation technique than move and destruct.
If trivial, then it can be optimized into a <code class="highlight"><c- n>memcpy</c-></code>.</p>
   <h3 class="heading settled" data-level="4.1" id="compare-P1144R8"><span class="secno">4.1. </span><span class="content">P1144R8: Object relocation in terms of move plus destroy by Arthur O’Dwyer</span><a class="self-link" href="#compare-P1144R8"></a></h3>
   <p><a data-link-type="biblio" href="#biblio-p1144r8" title="std::is_trivially_relocatable">[P1144R8]</a> puts the focus on trivially relocatable types, and offers ways to
mark a type as trivially relocatable.</p>
   <p>The current proposal has its own take on trivial relocatability that does not
rely on a class attribute. Instead the trivial relocatability
trait flows naturally from the new relocation constructor that we introduce. In short:
if a class type has a relocation constructor that is (explicitly) declared as defaulted or
is implicitly defined and not defaulted as deleted, and all of
its subobjects are trivially relocatable (or fully trivial), then the type
is trivially relocatable.</p>
   <p>This approach is not prone to errors when compared to a class attribute,
which could be mistakenly overridden by some users on classes that are not
trivially relocatable.</p>
   <p>Also, <a data-link-type="biblio" href="#biblio-p1144r8" title="std::is_trivially_relocatable">[P1144R8]</a> does not account for relocate-only types. To some extend, trivially
relocatable types have minimal support as they could be trivially relocated in the
places where "move plus destroy" can be optimized. However:</p>
   <ul>
    <li data-md>
     <p>this only concerns trivially relocatable types ;</p>
    <li data-md>
     <p>there are places where the optimization cannot happen, and as such the object cannot be "relocated" ;</p>
    <li data-md>
     <p>this poses a composability issue. If a relocate-only (non-movable and non-copyable), trivially-relocatable type
is a data member of a class that also has other non-trivially-relocatable data members, then the
enclosing class becomes non trivially relocatable, while remaining relocate-only.
This renders the enclosing class impractical to use without proper support
for relocate-only types.</p>
   </ul>
   <p>In this proposal we reuse <a data-link-type="biblio" href="#biblio-p1144r8" title="std::is_trivially_relocatable">[P1144R8]</a>'s <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>relocate</c-></code> function, except that we
name it <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>reloc_and_uninitialize</c-></code>.</p>
   <h3 class="heading settled" data-level="4.2" id="compare-P0023R0"><span class="secno">4.2. </span><span class="content">P0023R0: Relocator: Efficiently moving objects by Denis Bider</span><a class="self-link" href="#compare-P0023R0"></a></h3>
   <p>The Relocator introduced in <a data-link-type="biblio" href="#biblio-p0023r0" title="Relocator: Efficiently moving objects">[P0023R0]</a> is similar to the proposed relocation constructor.
However P0023R0’s Relocator is not viewed as a constructor. Instead, it is a special
function that can be invoked in lieu of move plus destroy where possible.</p>
   <p>However this brings again suboptimal support for relocate-only types. Indeed <a data-link-type="biblio" href="#biblio-p0023r0" title="Relocator: Efficiently moving objects">[P0023R0]</a> does not force relocation to happen in all cases, and falls back to move+destroy paradigm
when relocation cannot happen.</p>
   <p>A typical example is when relocating a function parameter:</p>
<pre class="language-c++ highlight"><c- b>void</c-> <c- nf>sink</c-><c- p>(</c-><c- n>T</c-><c- p>);</c->
<c- b>void</c-> <c- nf>foo</c-><c- p>(</c-><c- n>T</c-> <c- n>x</c-><c- p>)</c-> <c- p>{</c-> <c- n>sink</c-><c- p>(</c-><c- n>x</c-><c- p>);</c-> <c- p>}</c->
</pre>
   <p>Here, under the terms of <a data-link-type="biblio" href="#biblio-p0023r0" title="Relocator: Efficiently moving objects">[P0023R0]</a>, relocation may not happen because of ABI
constraints (if <code class="highlight"><c- n>x</c-></code> is an unowned parameter).
This will cause <code class="highlight"><c- n>foo</c-></code> to fallback to a move+deferred detroy paradigm.</p>
   <p>This proposal has another take on this issue: if <code class="highlight"><c- n>T</c-></code> has a relocation constructor
but no move constructor, then any function
that takes a <code class="highlight"><c- n>T</c-></code> parameter by value is required to have an ABI that allows it to
relocate
its input parameter (e.g. callee-destroy ABI).</p>
   <p>This proposal also introduces the <code class="highlight"><c- n>reloc</c-></code> keyword that is here to trigger
the relocation, and protect against the reuse of the relocated object.
The solution then becomes:</p>
<pre class="language-c++ highlight"><c- b>void</c-> <c- nf>sink</c-><c- p>(</c-><c- n>T</c-><c- p>);</c->
<c- b>void</c-> <c- nf>foo</c-><c- p>(</c-><c- n>T</c-> <c- n>x</c-><c- p>)</c-> <c- p>{</c-> <c- n>sink</c-><c- p>(</c-><c- n>reloc</c-> <c- n>x</c-><c- p>);</c-> <c- d>/* x can no longer be used. */</c-> <c- p>}</c->
</pre>
   <p>Moreover, the proposed syntax for invoking <a data-link-type="biblio" href="#biblio-p0023r0" title="Relocator: Efficiently moving objects">[P0023R0]</a>'s relocator is low-level and
prone to error:</p>
<pre class="language-c++ highlight"><c- n>T</c-> <c- n>x</c-><c- p>;</c->
<c- k>alignas</c-><c- p>(</c-><c- n>T</c-><c- p>)</c-> <c- b>char</c-> <c- n>buf</c-><c- p>[</c-><c- k>sizeof</c-><c- p>(</c-><c- n>T</c-><c- p>)];</c->
<c- n>T</c-><c- o>*</c-> <c- n>y</c-> <c- o>=</c-> <c- n>new</c-> <c- p>(</c-><c- n>buf</c-><c- p>)</c-> <c- o>>></c-><c- n>T</c-><c- p>(</c-><c- n>x</c-><c- p>);</c->
</pre>
   <p>Here the lifetime of <code class="highlight"><c- n>x</c-></code> has been ended as if by a destructor call, but the language
is not aware of this,
so firstly the user may erreoneously refer to <code class="highlight"><c- n>x</c-></code> as if it was within its lifetime,
and secondly if an object is not recreated in <code class="highlight"><c- n>x</c-></code> by the time the block
exits, the behavior is undefined by <a href="https://eel.is/c++draft/basic.life#9">[basic.life]/9</a>.
Likewise, the language is not aware of the existence of <code class="highlight"><c- o>*</c-><c- n>y</c-></code> so will not call its
destructor; the behavior is then possibly undefined under <a href="https://eel.is/c++draft/basic.life#5">[basic.life]/5</a>.
In contrast, the present proposal would write the above as:</p>
<pre class="language-c++ highlight"><c- n>T</c-> <c- n>x</c-><c- p>;</c->
<c- n>T</c-> <c- n>y</c-> <c- o>=</c-> <c- n>reloc</c-> <c- n>x</c-><c- p>;</c->
</pre>
   <p>Here the use of the <code class="highlight"><c- n>reloc</c-></code> keyword ensures that the language is aware that the lifetime
of <code class="highlight"><c- n>x</c-></code> has finished, so the destructor only of <code class="highlight"><c- n>y</c-></code> is called at scope exit.</p>
   <h3 class="heading settled" data-level="4.3" id="compare-N4158"><span class="secno">4.3. </span><span class="content">N4158: Destructive Move by Pablo Halpern</span><a class="self-link" href="#compare-N4158"></a></h3>
   <p><a data-link-type="biblio" href="#biblio-n4158" title="Destructive Move">[N4158]</a> proposes a customizable function <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>uninitialized_destructive_move</c-></code>,
that is somewhat similar to the relocation constructor, but is a pure library solution.</p>
   <p>It has several drawbacks :</p>
   <ul>
    <li data-md>
     <p>relocation can only happen if this function is called explicitly. Typically this function
would be called in container implementation. But then we cannot relocate
local variables with this.</p>
    <li data-md>
     <p>users can write their own <code class="highlight"><c- n>uninitialized_destructive_move</c-></code> overload, but this
is terrible for composability. Classes that have a subobject with a
custom <code class="highlight"><c- n>uninitialized_destructive_move</c-></code> overload do not get a <code class="highlight"><c- n>uninitialized_destructive_move</c-></code> overload generated for free.</p>
    <li data-md>
     <p><code class="highlight"><c- n>uninitialized_destructive_move</c-></code> cannot be default-generated with memberwise
relocation.</p>
   </ul>
   <h3 class="heading settled" data-level="4.4" id="compare-P1029R3"><span class="secno">4.4. </span><span class="content">P1029R3: move = bitcopies by Niall Douglas</span><a class="self-link" href="#compare-P1029R3"></a></h3>
   <p><a data-link-type="biblio" href="#biblio-p1029r3" title="move = bitcopies">[P1029R3]</a> enables a special bitcopies move constructor for types that are trivially relocatable.</p>
   <p>Like the other proposals <a data-link-type="biblio" href="#biblio-p1029r3" title="move = bitcopies">[P1029R3]</a> does not provide support for relocate-only types
(it suffers from the same drawbacks as <a data-link-type="biblio" href="#biblio-p1144r8" title="std::is_trivially_relocatable">[P1144R8]</a> in that regard).</p>
   <h3 class="heading settled" data-level="4.5" id="compare-P0308R0"><span class="secno">4.5. </span><span class="content">P0308R0: Valueless Variants Considered Harmful by Peter Dimov</span><a class="self-link" href="#compare-P0308R0"></a></h3>
   <p>We only consider the "pilfering" proposition from <a data-link-type="biblio" href="#biblio-p0308r0" title="Valueless Variants Considered Harmful">[P0308R0]</a>.
P0308R0’s pilfering shares some similarities with the current proposal,
as it is an attempt to support relocate-only types as a pure library solution.</p>
   <p>We believe a language solution is best suited here:</p>
   <ul>
    <li data-md>
     <p>the source object is effectively destroyed by the relocation: its destructor
is not called. This can hardly be achieved by a library solution ;</p>
    <li data-md>
     <p>the <code class="highlight"><c- n>reloc</c-></code> keyword makes sure the relocated object is not reused,
while <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>pilfer</c-></code> does not ;</p>
    <li data-md>
     <p>the pilfering constructor is inconvenient to write as we need to unwrap from <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>pilfered</c-></code> and rewrap to propagate to base classes and data members ;</p>
    <li data-md>
     <p>as a library solution, the pilfering constructor cannot be defaulted ;</p>
    <li data-md>
     <p>trivial relocation is not possible with pilfering, which makes <a data-link-type="biblio" href="#biblio-p0308r0" title="Valueless Variants Considered Harmful">[P0308R0]</a> miss
the performance boost that is so longed for.</p>
   </ul>
   <h3 class="heading settled" data-level="4.6" id="compare-D2839"><span class="secno">4.6. </span><span class="content">D2839R1: Nontrivial Relocation via a New <em>owning reference</em> Type by Brian Bi and Joshua Berne</span><a class="self-link" href="#compare-D2839"></a></h3>
   <p><a data-link-type="biblio" href="#biblio-d2839r1" title="Nontrivial Relocation via a New owning reference Type">[D2839R1]</a> is very close in spirit and mechanism to this paper. We consider the
addition of an "owning reference" to be an unnecessary complication to the type
system that would impose a burden throughout library code. We refute the claim
that a prvalue occupying storage constitutes a fourth value category; in our
model, the lvalue that previously occupied that storage ceases to exist and a
new prvalue is formed, which may come to occupy that storage (if relocation is
elided) or distinct storage (in the general case).</p>
   <p>We are intrigued by the claim that an owning reference can provide superior
performance when passing a variable up the stack, compared to repeatedly relocating
it from caller to callee, but believe that in practice such gains would be minimal
and liable to be eliminated via optimization, while our model offers the possibility
of improved locality, since the relocated object will reside directly in the leafmost
function’s stack as opposed to being accessible only via indirection.</p>
   <p>Otherwise, the paper has some minor differences in naming (e.g. <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>force_relocate</c-></code> for what we call <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>reloc_and_uninitialize</c-></code>) that could easily be reconciled in either
direction.</p>
   <h2 class="heading settled" data-level="5" id="lg-changes"><span class="secno">5. </span><span class="content">Proposed language changes</span><a class="self-link" href="#lg-changes"></a></h2>
   <h3 class="heading settled" data-level="5.1" id="reloc-operator"><span class="secno">5.1. </span><span class="content">reloc operator</span><a class="self-link" href="#reloc-operator"></a></h3>
   <p>This paper suggests to introduce a new keyword, named <code class="highlight"><c- n>reloc</c-></code>. <code class="highlight"><c- n>reloc</c-></code> acts as a
unary operator that can be applied to named, local, complete objects (in other
words: function-local non-static variables and, with some restrictions,
function parameters and
identifiers introduced through the syntax of structured binding declarations).</p>
   <p><code class="highlight"><c- n>reloc</c-> <c- n>obj</c-></code> does the following:</p>
   <ul>
    <li data-md>
     <p>if <code class="highlight"><c- n>obj</c-></code> is ref-qualified, then performs perfect-forwarding
(as if by <code class="highlight"><c- k>static_cast</c-><c- o>&lt;</c-><c- k>decltype</c-><c- p>(</c-><c- n>obj</c-><c- p>)</c-><c- o>></c-><c- p>(</c-><c- n>obj</c-><c- p>)</c-></code>) ;</p>
    <li data-md>
     <p>otherwise returns a temporary obtained from the source object, constructed
from the relocation, move or copy constructor.</p>
     <ul>
      <li data-md>
       <p>If the relocation constructor
was called, then the source object has been destroyed.</p>
      <li data-md>
       <p>If not, then the destructor of the source object will be implicitly
invoked as soon as the implementation permits, if possible at the end
of the full-expression evaluation ;</p>
     </ul>
    <li data-md>
     <p>in all cases, marks the "early" end-of-scope of the variable <code class="highlight"><c- n>obj</c-></code>, preventing
reuses of the variable.</p>
   </ul>
   <h4 class="heading settled" data-level="5.1.1" id="reloc-perfect-fwd"><span class="secno">5.1.1. </span><span class="content">reloc to perfectly forward all value categories</span><a class="self-link" href="#reloc-perfect-fwd"></a></h4>
   <p><code class="highlight"><c- n>reloc</c-></code> can be used on ref-qualified objects to enable perfect forwarding.
If the source object is ref-qualified, then it performs the following cast: <code class="highlight"><c- k>static_cast</c-><c- o>&lt;</c-><c- k>decltype</c-><c- p>(</c-><c- n>obj</c-><c- p>)</c-><c- o>></c-><c- p>(</c-><c- n>obj</c-><c- p>)</c-></code>.</p>
   <p>This makes <code class="highlight"><c- n>reloc</c-></code> the one operator to use to perfectly forward objects, whether
they are ref-qualified or not.
It also prevents from use-after-move and use-after-relocation errors.</p>
   <h4 class="heading settled" data-level="5.1.2" id="reloc-constexpr"><span class="secno">5.1.2. </span><span class="content">reloc in constexpr</span><a class="self-link" href="#reloc-constexpr"></a></h4>
   <p><code class="highlight"><c- n>reloc</c-></code> can be used in constexpr functions and constant-evaluated expressions.</p>
   <h4 class="heading settled" data-level="5.1.3" id="reloc-value-change"><span class="secno">5.1.3. </span><span class="content">reloc produces a prvalue</span><a class="self-link" href="#reloc-value-change"></a></h4>
   <p>Unlike <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-></code>, <code class="highlight"><c- n>reloc</c-></code> does perform some form of relocation.
Through misuse of language, we say that <code class="highlight"><c- n>reloc</c-></code> returns a temporary object,
created by relocation, move or copy constructor. In truth,
given that the source object is not ref-qualified, <code class="highlight"><c- n>reloc</c-></code> merely
changes the value category of the source object from lvalue to prvalue
(if the source object is ref-qualified, see <a href="#reloc-perfect-fwd">above</a>).</p>
   <p>It is this value category change that <em>may</em> trigger the creation of a temporary
object. However, optimizations may happen that will elide the creation of the
temporary entirely.</p>
   <p>If the temporary is materialized, then it is ideally constructed by the relocation
constructor, destroying the source object in the process. However, <code class="highlight"><c- n>reloc</c-></code> does
not force the use of the relocation constructor. The constructor which will be used
to create the temporary is selected by overload resolution. <code class="highlight"><c- n>reloc</c-></code> merely enables
the relocation constructor to be selected because of the value category change
(the relocation constructor has the signature <code class="highlight"><c- n>T</c-><c- p>(</c-><c- n>T</c-><c- p>)</c-></code>, meaning it will be preferred
when constructed from a prvalue, with our new <a href="#overload-resolution">overload resolution rules</a>).</p>
   <h4 class="heading settled" data-level="5.1.4" id="reloc-with-function-param"><span class="secno">5.1.4. </span><span class="content">Relocation constructor discardment with function parameters</span><a class="self-link" href="#reloc-with-function-param"></a></h4>
   <p>Function parameters' lifetime ownership is implementation-defined in C++.
Depending on the ABI in use, a function parameter may be destroyed at caller-site
(upon function return, at the end of the full-expression evaluation),
or at callee-site (before the function exits).</p>
   <p>Enforcing the relocation constructor when <code class="highlight"><c- n>reloc</c-></code> is used on a function
parameter, which would effectively destroy the function parameter,
will not be compatible with all existing ABIs (see Itanium ABI for
instance). We could propose this nonetheless, by stating that the relocation
constructor must be used if declared.
However we fear this would propagate ABI changes with too little control
and the proposal would meet to much resistance to go further.</p>
   <p>We could take a very conservative approach, and mandate the ABI change
for <em>relocate-only</em> value parameters. Such types don’t exist today, so the
likelihood of breaking any existing ABI is relatively small. However this may
lead to suboptimized code, where <code class="highlight"><c- n>reloc</c-></code> would perform worse than move semantics.
Consider now the following code:</p>
   <table>
    <tbody>
     <tr>
      <th>With move semantics
      <th>With relocation
     <tr>
      <td valign="top">
<pre class="language-c++ highlight"><c- k>struct</c-> <c- nc>A</c->
<c- p>{</c->
    <c- c1>// [...]</c->
    <c- n>A</c-><c- p>(</c-><c- n>A</c-> <c- k>const</c-><c- o>&amp;</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
    <c- n>A</c-><c- p>(</c-><c- n>A</c-><c- o>&amp;&amp;</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
<c- p>};</c->

<c- b>void</c-> <c- nf>bar</c-><c- p>(</c-><c- n>A</c-><c- p>);</c->
<c- b>void</c-> <c- nf>foo</c-><c- p>(</c-><c- n>A</c-> <c- n>a</c-><c- p>)</c->
<c- p>{</c->
    <c- n>bar</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>a</c-><c- p>));</c->
<c- p>}</c->
</pre>
      <td valign="top">
<pre class="language-c++ highlight"><c- k>struct</c-> <c- nc>A</c->
<c- p>{</c->
    <c- c1>// [...]</c->
    <c- n>A</c-><c- p>(</c-><c- n>A</c-> <c- k>const</c-><c- o>&amp;</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
    <c- n>A</c-><c- p>(</c-><c- n>A</c-><c- o>&amp;&amp;</c-><c- p>)</c-> <c- o>=</c-> <c- n>delete</c-><c- p>;</c->
    <c- n>A</c-><c- p>(</c-><c- n>A</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
<c- p>};</c->

<c- b>void</c-> <c- nf>bar</c-><c- p>(</c-><c- n>A</c-><c- p>);</c->
<c- b>void</c-> <c- nf>foo</c-><c- p>(</c-><c- n>A</c-> <c- n>a</c-><c- p>)</c->
<c- p>{</c->
    <c- n>bar</c-><c- p>(</c-><c- n>reloc</c-> <c- n>a</c-><c- p>);</c->
<c- p>}</c->
</pre>
   </table>
   <p>Since <code class="highlight"><c- n>A</c-></code> has a copy constructor, it is not relocate-only. With the conservative
approach, we have no guarantee
that <code class="highlight"><c- n>foo</c-></code> has the ownership of <code class="highlight"><c- n>a</c-></code>. Hence <code class="highlight"><c- n>reloc</c-> <c- n>a</c-></code> here may simply call the copy
constructor, as the ABI may not permit otherwise.</p>
   <p>To prevent such a pessimization, developers will be tempted to add a move constructor
to <code class="highlight"><c- n>A</c-></code>, ensuring that at least the move constructor is called in such cases.
Doing so goes against what we are trying to achieve with this proposal. One
of our main motivation points is that the move constructor doesn’t fit all classes
that could yet still be moved. We don’t want users to declare one anyway
to avoid pitfalls.</p>
   <p>Thus in an attempt to make a compromise between ABI compatibility and acceptable
support for relocation, we take a slightly less conservative approach.
We would like function parameters passed by value, whose type declares
a relocation constructor but no move constructor, to be <em>owned parameters</em>.
As the C++ standard leaves this area implementation-defined, we are going to force
this another way, although the effect will likely be the same:</p>
   <p><strong>Rule:</strong> If the source object is a function parameter passed by value, and its type
provides an eligible move constructor, then the relocation constructor (if any)
may be discarded during overload resolution. Whether the relocation constructor
is discarded is <em>implementation-defined</em>.</p>
   <p class="note" role="note"><span class="marker">Note:</span> <em>eligible</em> is defined in <a href="http://wg21.link/special#def:special_member_function,eligible">[special]</a>.</p>
   <p>As consequences of that rule, we get the following:</p>
   <ul>
    <li data-md>
     <p>source objects which are not function parameters are always guaranteed that
their relocation constructor (if eligible) is called ;</p>
    <li data-md>
     <p>source objects which are <em>owned parameters</em> have the same guarantee as above ;</p>
    <li data-md>
     <p>source objects which are <em>unowned parameters</em>, and have both an eligible move
and relocation constructor, will not be relocated. Instead the move constructor
will be used by <code class="highlight"><c- n>reloc</c-></code>.</p>
    <li data-md>
     <p>source objects which are function parameters, and have an eligible relocation
constructor but no move constructor, are forcibly <em>owned parameters</em>.</p>
   </ul>
   <p class="note" role="note"><span class="marker">NOTE:</span> Types which have a relocation constructor but no move constructor
still don’t exist today, so the likelihood of breaking existing ABIs is still
small.</p>
   <p>With this updated rule, <code class="highlight"><c- n>reloc</c-> <c- n>a</c-></code> from our previous example will effectively
call the relocation constructor. And users can safely migrate from the move
constructor to the relocation constructor if they wish to without any gotchas.</p>
   <p>Note that this rule still isn’t optimal. Consider the following code,
having in mind a putative <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>pair</c-></code> with a relocation constructor:</p>
<pre class="language-c++ highlight"><c- b>void</c-> <c- nf>bar</c-><c- p>(</c-><c- n>pair</c-><c- o>&lt;</c-><c- k>const</c-> <c- n>string</c-><c- p>,</c-> <c- b>int</c-><c- o>></c-><c- p>);</c->

<c- b>void</c-> <c- nf>foo</c-><c- p>(</c-><c- n>pair</c-><c- o>&lt;</c-><c- k>const</c-> <c- n>string</c-><c- p>,</c-> <c- b>int</c-><c- o>></c-> <c- n>val</c-><c- p>)</c->
<c- p>{</c->
    <c- n>val</c-><c- p>.</c-><c- n>second</c-> <c- o>*=</c-> <c- mi>2</c-><c- p>;</c->
    <c- n>bar</c-><c- p>(</c-><c- n>reloc</c-> <c- n>val</c-><c- p>);</c->
<c- p>}</c->
</pre>
   <p><code class="highlight"><c- n>val</c-></code> has the three constructors, so our rule does not apply. The ownership
of <code class="highlight"><c- n>val</c-></code> by <code class="highlight"><c- n>foo</c-></code> is implementation-defined. If <code class="highlight"><c- n>foo</c-></code> doesn’t own <code class="highlight"><c- n>val</c-></code>, then <code class="highlight"><c- n>reloc</c-> <c- n>val</c-></code> will call the move constructor, making a full string copy
(because of <code class="highlight"><c- k>const</c-></code>). Contrary to our previous example which motivated us to
update the parameter ownership rule,
here <code class="highlight"><c- n>reloc</c-></code> may call <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-></code> so we haven’t worsened the situation.</p>
   <h4 class="heading settled" data-level="5.1.5" id="reloc-src-obj-lifetime"><span class="secno">5.1.5. </span><span class="content">Early end of scope</span><a class="self-link" href="#reloc-src-obj-lifetime"></a></h4>
   <p>As we have seen <code class="highlight"><c- n>reloc</c-></code> may trigger a call to the relocation constructor.
At the moment of the call, the source object is in a destructed state.
Thus it is unsafe to reuse it after the <code class="highlight"><c- n>reloc</c-></code> expression completes.</p>
   <p>To prevent uses of a potentially destructed object, we state that the program is <strong>ill-formed</strong> if the source object is reused after being passed to <code class="highlight"><c- n>reloc</c-></code>,
regardless of whether the relocation constructor was called. For a detailed
explanation of how this is enforced, please refer to <a href="#ill-formed-reuse">the dedicated section</a>.</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> The rest of this section only applies to <code class="highlight"><c- n>reloc</c-></code> operands that are
not ref-qualified.</p>
   <p>That early end of scope provides us with a strong guarantee. We know that the
source object cannot be reused, and as such we may be tempted to call the
destructor of the source object early (in cases where the relocation constructor
was not selected). For instance, we may want to destroy the
source object at the end of the full-expression evaluation, when temporaries are
destroyed. It would be the natural thing to do:</p>
   <ul>
    <li data-md>
     <p>for consistency, if the object had been relocated (with the relocation constructor),
then it already reached its end of life. The same could be expected for
copy and move constructor ;</p>
    <li data-md>
     <p>the source object cannot be reused anyway, why defer its destruction?</p>
   </ul>
   <p>Unfortunately, this cannot be done without breaking some ABIs. If the source
object is an <em>unowned parameter</em>, then the function cannot destroy it early.
The problem does not happen if the source object is a function-local variable
or an <em>owned parameter</em>.
Let us see what happens if we allow the early destruction of function parameters
to be <em>implementation-defined</em>:</p>
   <ul>
    <li data-md>
     <p>If <code class="highlight"><c- n>reloc</c-></code> calls the copy constructor:
all the resources owned by the source object are <em>copied</em> to the target object.
As such if the destructor has side-effects, they may be applied twice, once
for the destruction of each object. Depending on the ABI, the destructor
of the source object may be called at the end of full-expression, or deferred
until control returns to the caller.
We can see that the destruction time of the source object would be <em>implementation-defined</em> (as of today). Remember that we might have side-effects from the
destructor, so the moment those side-effects will be applied will also
be <em>implementation-defined</em>.</p>
    <li data-md>
     <p>If <code class="highlight"><c- n>reloc</c-></code> calls the move constructor:
all the resources owned by the source object are <em>transferred</em> to the target
object. As such if the destructor has side-effects, we expect them to be
applied only once, at the destruction of the target object. We expect the
source object destructor to detect the <em>moved-from state</em> and return, without
triggering any side-effects.
Under those reasonably safe assumptions, it doesn’t matter when the source
object is destroyed, be it at its natural end of scope, or at the end of the <code class="highlight"><c- n>reloc</c-></code> expression.</p>
   </ul>
   <p>As of today, the lifetime of function parameters is already <em>implementation-defined</em>.
As such, code that relies on the timing of a destructor side-effects of a
function parameter is already <em>implementation-defined</em>.
We don’t feel we will worsen the
situation with <code class="highlight"><c- n>reloc</c-></code>, even with copy-only source objects.
We prefer to keep this behavior implementation-defined, same as
today, except that the source object may also be destructed early, at the end
of the full-expression evaluation that contained <code class="highlight"><c- n>reloc</c-></code>.</p>
   <p>In conclusion, we establish the following rules when a <code class="highlight"><c- n>reloc</c-></code> expression
is evaluated:</p>
   <ul>
    <li data-md>
     <p><strong>Rule:</strong> If the source object passed to <code class="highlight"><c- n>reloc</c-></code> is not a function parameter, and
the source object has not been relocated by its relocation constructor, then
its lifetime ends (i.e. its destructor is implicitly invoked) at the end of the
full-expression evaluation containing <code class="highlight"><c- n>reloc</c-></code>.</p>
    <li data-md>
     <p><strong>Rule:</strong> If the source object passed to <code class="highlight"><c- n>reloc</c-></code> is a function parameter, and
the source object has not been relocated by its relocation constructor, then
its destructor must be implicitly invoked at the end of the full-expression
containing the evaluated <code class="highlight"><c- n>reloc</c-></code> expression, upon function exit,
or at the caller site at the end of the
full-expression evaluation. Which it is is <em>implementation-defined</em>.</p>
   </ul>
   <p>We acknowledge that with <code class="highlight"><c- n>reloc</c-></code> expressions we allow for more code to be executed between
the end of the full-expression which contained <code class="highlight"><c- n>reloc</c-></code>,
and when control returns to the caller site.
One might argue that we exacerbate this destruction time discrepancy between
implementations. However please keep in mind that:</p>
   <ul>
    <li data-md>
     <p>this only concerns copy-only value parameters, whose destructor have a side-effect, and
are passed to <code class="highlight"><c- n>reloc</c-></code> ;</p>
    <li data-md>
     <p>any arbitrary amount of code could still be executed today upon function exit,
at the end of the full-expression evaluation that made the function call,
at caller-site. Indeed, all function parameters need to be destructed,
and their destruction order remains <em>implementation-defined</em> as of today,
leaving the door open for any arbitrary code from a destructor,
to be executed before the destructor of our source object ;</p>
    <li data-md>
     <p>code that relies on a precise destruction timing of a function parameter is
poor code as this timing is implementation-defined, even today.</p>
   </ul>
   <h4 class="heading settled" data-level="5.1.6" id="reloc-illegal-uses"><span class="secno">5.1.6. </span><span class="content">Illegal uses of reloc</span><a class="self-link" href="#reloc-illegal-uses"></a></h4>
   <p>A <code class="highlight"><c- n>reloc</c-></code> statement is ill-formed if any of the following conditions is met:</p>
   <ul>
    <li data-md>
     <p>its parameter is not the name of a variable ;</p>
    <li data-md>
     <p>the source object is not a <em>complete object</em> ;</p>
    <li data-md>
     <p>the source object is not ref-qualified and does not have local storage
(i.e. not a local function variable and not a function parameter passed by
value) ;</p>
    <li data-md>
     <p>the source object is not ref-qualified and does not have an accessible relocation,
move, or copy constructor ;</p>
    <li data-md>
     <p>the source object is a structured binding (and not an identifier introduced in a <a href="#structured-decomposition">structured decomposition declaration</a>) ;</p>
    <li data-md>
     <p>the source object is a lambda capture (unless the lambda closure object has been <a href="#decompose-lambda">decomposed</a>) ;</p>
    <li data-md>
     <p>the source object is a virtual base of a <a href="#decomposed-state">decomposed object</a> ;</p>
   </ul>
   <p>In particular, the <code class="highlight"><c- n>reloc</c-></code> statement is well-formed if the source object is a
member of a function-local anonymous union.</p>
   <p>For instance:</p>
<pre class="language-cpp highlight"><c- b>void</c-> <c- nf>foo</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>str</c-><c- p>);</c->
<c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- nf>get_string</c-><c- p>();</c->
<c- n>std</c-><c- o>::</c-><c- n>pair</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>string</c-><c- o>></c-> <c- n>get_strings</c-><c- p>();</c->

<c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>gStr</c-> <c- o>=</c-> <c- s>"static string"</c-><c- p>;</c->

<c- b>void</c-> <c- nf>bar</c-><c- p>(</c-><c- b>void</c-><c- p>)</c->
<c- p>{</c->
  <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>str</c-> <c- o>=</c-> <c- s>"test string"</c-><c- p>;</c->
  <c- n>foo</c-><c- p>(</c-><c- n>reloc</c-> <c- n>str</c-><c- p>);</c-> <c- c1>// OK: relocation will happen given that std::string has a reloc ctor</c->
  <c- n>foo</c-><c- p>(</c-><c- n>reloc</c-> <c- n>gStr</c-><c- p>);</c-> <c- c1>// ill-formed: gStr does not have local storage</c->

  <c- n>std</c-><c- o>::</c-><c- n>pair</c-> <c- n>p</c-><c- p>{</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-><c- p>{},</c-> <c- n>std</c-><c- o>::</c-><c- n>string</c-><c- p>{}};</c->
  <c- n>foo</c-><c- p>(</c-><c- n>reloc</c-> <c- n>p</c-><c- p>.</c-><c- n>first</c-><c- p>);</c-> <c- c1>// ill-formed: p.first is not a complete object, and not the name of variable</c->

  <c- n>foo</c-><c- p>(</c-><c- n>reloc</c-> <c- n>get_string</c-><c- p>());</c-> <c- c1>// ill-formed: not the name of variable</c->
  <c- n>foo</c-><c- p>(</c-><c- n>reloc</c-> <c- n>get_strings</c-><c- p>().</c-><c- n>first</c-><c- p>);</c-> <c- c1>// ill-formed: not a complete object, and not the name of variable</c->
<c- p>}</c->

<c- b>void</c-> <c- nf>foobar</c-><c- p>(</c-><c- k>const</c-> <c- n>std</c-><c- o>::</c-><c- n>string</c-><c- o>&amp;</c-> <c- n>str</c-><c- p>)</c->
<c- p>{</c->
  <c- n>foo</c-><c- p>(</c-><c- n>reloc</c-> <c- n>str</c-><c- p>);</c-> <c- c1>// OK: str is passed by reference.</c->
  <c- c1>// Note that the lifetime of the referent of str is unaffected.</c->
<c- p>}</c->
<c- b>void</c-> <c- nf>foobar</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-><c- o>*</c-> <c- n>str</c-><c- p>)</c->
<c- p>{</c->
  <c- n>foo</c-><c- p>(</c-><c- n>reloc</c-> <c- o>*</c-><c- n>str</c-><c- p>);</c-> <c- c1>// ill-formed: *str is not the name of variable</c->
<c- p>}</c->
<c- b>void</c-> <c- nf>foobar2</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-><c- o>*</c-> <c- n>str</c-><c- p>)</c->
<c- p>{</c->
  <c- n>foobar</c-><c- p>(</c-><c- n>reloc</c-> <c- n>str</c-><c- p>);</c-> <c- c1>// OK, the pointer itself is relocated (not the pointed value)</c->
<c- p>}</c->

<c- k>class</c-> <c- nc>A</c->
<c- p>{</c->
  <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>_str</c-><c- p>;</c->
<c- k>public</c-><c- o>:</c->
  <c- b>void</c-> <c- n>bar</c-><c- p>()</c->
  <c- p>{</c->
    <c- n>foo</c-><c- p>(</c-><c- n>reloc</c-> <c- n>_str</c-><c- p>);</c-> <c- c1>// ill-formed: _str is not a complete object and does not have local storage</c->
  <c- p>}</c->
<c- p>};</c->
</pre>
   <h4 class="heading settled" data-level="5.1.7" id="reloc-elision"><span class="secno">5.1.7. </span><span class="content">Relocation elision</span><a class="self-link" href="#reloc-elision"></a></h4>
   <p>Whether performed by relocation, move or copy constructor, relocation
may be elided if the compiler can ensure that the source object is created at
the address to be occupied by the target object.
This is intended to work in much the same way as the named return value optimization;
for example:</p>
<pre class="language-c+ highlight"><c- b>void</c-> <c- nf>f</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>s</c-><c- p>);</c->
<c- b>void</c-> <c- nf>g</c-><c- p>()</c-> <c- p>{</c->
    <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>s</c-><c- p>;</c->  <c- c1>// may be created in f’s argument slot</c->
    <c- n>f</c-><c- p>(</c-><c- n>reloc</c-> <c- n>s</c-><c- p>);</c->  <c- c1>// relocation may be elided</c->
<c- p>}</c->
</pre>
   <h4 class="heading settled" data-level="5.1.8" id="discarded-reloc-expr"><span class="secno">5.1.8. </span><span class="content">Discarded reloc expressions</span><a class="self-link" href="#discarded-reloc-expr"></a></h4>
   <p><code class="highlight"><c- n>reloc</c-></code> expressions can be discarded: <code class="highlight"><c- n>reloc</c-> <c- n>obj</c-><c- p>;</c-></code> (note the semi-colon).
We expect this statement to have the same effect as <code class="highlight"><c- p>{</c-> <c- k>auto</c-> <c- n>_</c-> <c- o>=</c-> <c- n>reloc</c-> <c- n>obj</c-><c- p>;</c-> <c- p>}</c-></code>.
A temporary is constructed from the source object and is then destructed at scope
exit (that is right-away). The source object is destructed right-away,
or at later stage if it’s a function parameter (<em>implementation-defined</em>).
We will discuss here the effects of such expressions.</p>
   <p>Materializing a temporary whose only goal is to be
destroyed is suboptimal.
We might be tempted to optimize away the temporary
materialization, and only call the destructor of the source object.</p>
   <p>This optimization is authorized (whether it is performed is <em>implementation-defined</em>).
If the optimization does not happen, then
the temporary must be materialized and destroyed at the end of full-expression
evaluation. The lifetime of the source object follows <a href="#reloc-src-obj-lifetime">the established rules</a>.</p>
   <p>Note that, if the temporary is materialized and that the source object:</p>
   <ol>
    <li data-md>
     <p><em>has an eligible relocation or move constructor</em>: In this case,
all the owned
resources of the source object will be <em>transferred</em> to the temporary. For this
reason, we expect that destroying the temporary <em>will have the same effects
as</em> destroying the source object directly.</p>
    <li data-md>
     <p><em>only has an eligible copy constructor</em>:
all the owned resources of the source object will be <em>copied</em> to the temporary.
This is very likely a useless operation.</p>
    <li data-md>
     <p>Other cases need not to be considered, as the <code class="highlight"><c- n>reloc</c-></code> expression requires the
source object to declare one of the three constructors.</p>
   </ol>
   <p class="note" role="note"><span class="marker">NOTE:</span> If the source object is a copy-only function parameter, then implementations
are encouraged to emit a warning on discarded reloc statements, as if <code class="highlight"><c- n>reloc</c-></code> had the <code class="highlight"><c- p>[[</c-><c- n>nodiscard</c-><c- p>]]</c-></code> attribute. This is because the intent of this statement
is likely to trigger the destruction of the source object (or to trigger the
effect of the destructor, if a move-constructed temporary is materialized and
destroyed). But whether this statement indeed calls a destructor early
(or has any side-effect) for copy-only function parameters is <em>implementation-defined</em>.</p>
   <p>To summarize, it means that <code class="highlight"><c- n>reloc</c-> <c- n>obj</c-><c- p>;</c-></code> has the following behavior:</p>
   <ul>
    <li data-md>
     <p>If <code class="highlight"><c- n>obj</c-></code> is an <em>owned parameter</em> or a function-local variable then:</p>
     <ul>
      <li data-md>
       <p>The temporary is likely elided, effectively only calling the
destructor of <code class="highlight"><c- n>obj</c-></code>.</p>
      <li data-md>
       <p>Otherwise a temporary is initialized from the
source object, and then destructed.</p>
     </ul>
    <li data-md>
     <p>Otherwise (<code class="highlight"><c- n>obj</c-></code> is an <em>unowned parameter</em>):</p>
     <ul>
      <li data-md>
       <p>A temporary is move-or-copy-constructed and then destructed.</p>
      <li data-md>
       <p>The source object destruction is deferred until the function returns.</p>
     </ul>
   </ul>
   <p>For instance this gives:</p>
<pre class="language-c++ highlight"><c- b>void</c-> <c- nf>do_something_01</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>mutex</c-><c- o>&amp;</c-> <c- n>m</c-><c- p>)</c->
<c- p>{</c->
    <c- n>std</c-><c- o>::</c-><c- n>lock_guard</c-> <c- n>guard</c-><c- p>{</c-><c- n>m</c-><c- p>};</c->
    <c- k>if</c-> <c- p>(</c-><c- o>!</c-><c- n>some_test</c-><c- p>())</c->
    <c- p>{</c->
        <c- n>reloc</c-> <c- n>guard</c-><c- p>;</c-> <c- c1>// ill-formed: no relocation, move or copy constructor</c->
        <c- n>log</c-><c- p>(</c-><c- s>"thread "</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>this_thread</c-><c- o>::</c-><c- n>get_id</c-><c- p>(),</c-> <c- s>" failed"</c-><c- p>);</c->
        <c- k>return</c-><c- p>;</c->
    <c- p>}</c->
    <c- n>bar</c-><c- p>();</c->
<c- p>}</c->
<c- b>void</c-> <c- nf>do_something_02</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>unique_lock</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>mutex</c-><c- o>></c-> <c- n>guard</c-><c- p>)</c->
<c- p>{</c->
    <c- k>if</c-> <c- p>(</c-><c- o>!</c-><c- n>some_test</c-><c- p>())</c->
    <c- p>{</c->
        <c- n>reloc</c-> <c- n>guard</c-><c- p>;</c-> <c- d>/* well-formed: lock is released, either by calling the</c->
<c- d>            destructor directly, or by constructing a temporary from</c->
<c- d>            guard (by relocation or move) and destructing it. */</c->
        <c- n>log</c-><c- p>(</c-><c- s>"thread "</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>this_thread</c-><c- o>::</c-><c- n>get_id</c-><c- p>(),</c-> <c- s>" failed"</c-><c- p>);</c->
        <c- k>return</c-><c- p>;</c->
    <c- p>}</c->
    <c- n>bar</c-><c- p>();</c->
<c- p>}</c->
<c- b>void</c-> <c- nf>do_something_03</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>mutex</c-><c- o>&amp;</c-> <c- n>m</c-><c- p>)</c->
<c- p>{</c->
    <c- n>std</c-><c- o>::</c-><c- n>unique_lock</c-> <c- n>guard</c-><c- p>{</c-><c- n>m</c-><c- p>};</c->
    <c- k>if</c-> <c- p>(</c-><c- o>!</c-><c- n>some_test</c-><c- p>())</c->
    <c- p>{</c->
        <c- n>reloc</c-> <c- n>guard</c-><c- p>;</c-> <c- d>/* well-formed: temporary is likely elided regardless of</c->
<c- d>            do_something_03’s ABI, only calling the destructor of guard. */</c->
        <c- n>log</c-><c- p>(</c-><c- s>"thread "</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>this_thread</c-><c- o>::</c-><c- n>get_id</c-><c- p>(),</c-> <c- s>" failed"</c-><c- p>);</c->
        <c- k>return</c-><c- p>;</c->
    <c- p>}</c->
    <c- n>bar</c-><c- p>();</c->
    <c- d>/* guard destructor is called only if it wasn’t passed to reloc. */</c->
<c- p>}</c->
<c- c1>// assuming non_null does not have a relocation constructor</c->
<c- b>void</c-> <c- nf>do_something_04</c-><c- p>(</c-><c- n>non_null</c-><c- o>&lt;</c-><c- n>shared_ptr</c-><c- o>&lt;</c-><c- b>int</c-><c- o>>></c-> <c- n>copyOnlyObj</c-><c- p>)</c->
<c- p>{</c->
    <c- k>if</c-> <c- p>(</c-><c- o>!</c-><c- n>some_test</c-><c- p>())</c->
    <c- p>{</c->
        <c- n>reloc</c-> <c- n>copyOnlyObj</c-><c- p>;</c-> <c- d>/* well-formed but its effects are implementation</c->
<c- d>            defined. Will emit a warning. */</c->
        <c- k>return</c-><c- p>;</c->
    <c- p>}</c->
    <c- n>bar</c-><c- p>();</c->
<c- p>}</c->
</pre>
   <h3 class="heading settled" data-level="5.2" id="decomposed-object"><span class="secno">5.2. </span><span class="content">Object decomposition</span><a class="self-link" href="#decomposed-object"></a></h3>
   <p>This proposal introduces the concept of object decomposition.
Only complete objects can be <em>decomposed</em>. An object is <em>decomposed</em> if the <code class="highlight"><c- n>reloc</c-></code> keyword appears in its definition.
If an object is <em>decomposed</em>, then it ceases to exist, but all
its subobjects are considered as complete objects.</p>
   <h4 class="heading settled" data-level="5.2.1" id="decomposed-object-decl"><span class="secno">5.2.1. </span><span class="content">Declaration and definition</span><a class="self-link" href="#decomposed-object-decl"></a></h4>
   <p>In an object definition, the <code class="highlight"><c- n>reloc</c-></code> keyword can be specified after the
object name:</p>
<pre class="language-c++ highlight"><c- n>T</c-> <c- k>const</c-> <c- n>value</c-> <c- n>reloc</c-> <c- o>=</c-> <c- n>getValue</c-><c- p>();</c->
</pre>
   <p><code class="highlight"><c- n>reloc</c-></code> cannot be used in an object declaration or else the program is ill-formed.
Note that <code class="highlight"><c- n>reloc</c-></code> is not part of the C++ type system. This is emphasized by the
fact that <code class="highlight"><c- n>reloc</c-></code> can only be specified <em>after</em> the object name.</p>
   <p><code class="highlight"><c- n>reloc</c-></code> can only be used in an object definition
(with <code class="highlight"><c- n>T</c-></code> the type of the object being defined) if:</p>
   <ul>
    <li data-md>
     <p>the object is a complete object with automatic storage ;</p>
    <li data-md>
     <p>the object is a function parameter or a function-local object ;</p>
    <li data-md>
     <p><code class="highlight"><c- n>T</c-></code> is a non-union class-type ;</p>
    <li data-md>
     <p><code class="highlight"><c- n>T</c-></code> is not ref-qualified.</p>
   </ul>
   <p>If any of the above conditions is not verified, then the definition is ill-formed.
For instance:</p>
<pre class="language-c++ highlight"><c- k>struct</c-> <c- nc>X</c->
<c- p>{</c->
    <c- n>std</c-><c- o>::</c-><c- n>pair</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>string</c-><c- o>></c-> <c- n>m</c-> <c- n>reloc</c-><c- p>;</c-> <c- c1>// ill-formed</c->
<c- p>};</c->

<c- k>static</c-> <c- n>std</c-><c- o>::</c-><c- n>pair</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>string</c-><c- o>></c-> <c- n>g</c-> <c- n>reloc</c-><c- p>;</c-> <c- c1>// ill-formed</c->

<c- b>void</c-> <c- nf>foo</c-><c- p>(</c-><c- n>T</c-> <c- k>const</c-><c- o>&amp;</c-> <c- n>a</c-> <c- n>reloc</c-><c- p>)</c-> <c- p>{}</c-> <c- c1>// ill-formed (ref-qualified)</c->
<c- b>void</c-> <c- nf>foo</c-><c- p>(</c-><c- n>T</c-> <c- k>const</c-><c- o>*</c-> <c- n>a</c-> <c- n>reloc</c-><c- p>)</c-> <c- p>{}</c-> <c- c1>// ill-formed (not a class-type)</c->
<c- b>void</c-> <c- nf>foo</c-><c- p>()</c->
<c- p>{</c->
    <c- n>T</c-> <c- k>const</c-> <c- n>a</c-><c- p>[]</c-> <c- n>reloc</c-> <c- o>=</c-> <c- p>{</c-> <c- p>};</c-> <c- c1>// ill-formed (not a class-type)</c->
<c- p>}</c->

<c- c1>// But</c->
<c- b>void</c-> <c- nf>foo</c-><c- p>(</c-><c- n>T</c-> <c- k>const</c-> <c- n>obj</c-> <c- n>reloc</c-><c- p>)</c-> <c- c1>// well-formed if T is a class-type</c->
<c- p>{</c->
    <c- n>T</c-> <c- n>obj2</c-> <c- n>reloc</c-><c- p>;</c-> <c- c1>// well-formed if T is a class-type</c->
<c- p>}</c->
</pre>
   <p>In particular, functions must be declared without <code class="highlight"><c- n>reloc</c-></code> on their parameters,
while the function definition does. In other words, <code class="highlight"><c- n>reloc</c-></code> is not
part of the function signature, and is only effective in the function
definition. For instance:</p>
<pre class="language-c++ highlight"><c- k>struct</c-> <c- nc>X</c->
<c- p>{</c->
    <c- b>void</c-> <c- nf>foo</c-><c- p>(</c-><c- n>T</c-> <c- n>obj</c-><c- p>);</c->
<c- p>};</c->

<c- b>void</c-> <c- nf>X::foo</c-><c- p>(</c-><c- n>T</c-> <c- n>obj</c-> <c- n>reloc</c-><c- p>)</c-> <c- c1>// well-formed</c->
<c- p>{</c->
    <c- c1>// ...</c->
<c- p>}</c->

<c- k>static_assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>is_same_v</c-><c- o>&lt;</c-><c- n>decltype</c-><c- p>(</c-><c- o>&amp;</c-><c- n>X</c-><c- o>::</c-><c- n>foo</c-><c- p>),</c-> <c- b>void</c-> <c- p>(</c-><c- n>X</c-><c- o>::*</c-><c- p>)(</c-><c- n>T</c-><c- p>)</c-><c- o>></c-><c- p>);</c-> <c- c1>// ok</c->
</pre>
   <p>If several objects are declared in the same expression, then <code class="highlight"><c- n>reloc</c-></code> needs to be
repeated for each object which the user wants to decompose:</p>
<pre class="language-c++ highlight"><c- n>T</c-> <c- k>const</c-> <c- n>value</c-> <c- n>reloc</c-> <c- o>=</c-> <c- n>getValue</c-><c- p>(</c-><c- mi>0</c-><c- p>),</c-> <c- n>value2</c-> <c- o>=</c-> <c- n>getValue</c-><c- p>(</c-><c- mi>1</c-><c- p>),</c-> <c- n>value3</c-> <c- n>reloc</c-> <c- o>=</c-> <c- n>getValue</c-><c- p>(</c-><c- mi>2</c-><c- p>);</c->
<c- c1>// only "value" and "value3" are decomposed.</c->
<c- n>T</c-> <c- k>const</c-> <c- n>c</c-><c- p>,</c-> <c- o>*</c-><c- n>d</c-> <c- n>reloc</c-><c- p>;</c-> <c- c1>// ill-formed, d is not a class-type</c->
</pre>
   <h4 class="heading settled" data-level="5.2.2" id="decomposed-state"><span class="secno">5.2.2. </span><span class="content">Decomposition operation</span><a class="self-link" href="#decomposed-state"></a></h4>
   <p>When a complete object is defined as <em>decomposed</em>, then:</p>
   <ul>
    <li data-md>
     <p>The object is <em>initialized</em> using the existing rules ;</p>
    <li data-md>
     <p>All its direct bases and non-static data members are now considered as
distinct complete objects:</p>
     <ul>
      <li data-md>
       <p>the decomposition does not odr-use any of the copy, move or relocation
constructor of the subobjects. In particular, their address remains unchanged ;</p>
      <li data-md>
       <p>for all of the virtual and direct bases which have a runtime type information, they
now point to that of the base class, and no longer point to the type
of the <em>decomposed</em> object. This step is identical as to what happens with
the runtime type information of base classes once the destructor body
is executed ;</p>
      <li data-md>
       <p>all virtual bases, if any, keep the same address ; all pointers to such
virtual bases remain unchanged.</p>
     </ul>
    <li data-md>
     <p>All its subobjects are now introduced in a special namespace named after the
decomposed object:</p>
     <ul>
      <li data-md>
       <p>all its virtual and direct bases are introduced in that namespace with
an identifier identical to that of their class identifier ;</p>
      <li data-md>
       <p>all non-static data members are introduced in that namespace with
an identifier identical to that of their definition ;</p>
      <li data-md>
       <p>member functions are not introduced ;</p>
      <li data-md>
       <p>the introduced objects (i.e. the subobjects of the <em>decomposed</em> object)
have the same lifetime as the <em>decomposed</em> object,
had it not been <em>decomposed</em> ;</p>
      <li data-md>
       <p>the introduced objects still inherit from the cv-qualifiers,
if any, of the <em>decomposed</em> object ;</p>
      <li data-md>
       <p>all the virtual bases introduced in that namespace cannot be the operand
of the <code class="highlight"><c- n>reloc</c-></code> operator, or else the expression is ill-formed.</p>
     </ul>
    <li data-md>
     <p><em>The lifetime of the</em> decomposed <em>object ends</em>: its destructor is never invoked implicitly.
All its non-static subobjects, now considered as complete objects, are still
alive and will
follow normal destruction rules: their destructor will be
invoked implicitly at scope exit
unless they have been relocated before.</p>
   </ul>
   <p class="note" role="note"><span class="marker">Note:</span> If not for changing the runtime type of the direct bases that have one,
the decomposition operation would be a no-op.</p>
   <p>For instance:</p>
<pre class="language-c++ highlight"><c- b>void</c-> <c- nf>foo</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>pair</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- k>const</c-><c- p>,</c-> <c- b>int</c-><c- o>></c-> <c- n>kv</c-> <c- n>reloc</c-><c- p>)</c->
<c- p>{</c->
    <c- c1>// kv object no longer exists</c->
    <c- c1>// its subobjects are accessible in the special "kv" namespace:</c->
    <c- c1>// kv::first and kv::second</c->
    <c- n>bar</c-><c- p>(</c-><c- n>kv</c-><c- o>::</c-><c- n>second</c-><c- p>,</c-> <c- n>reloc</c-> <c- n>kv</c-><c- o>::</c-><c- n>first</c-><c- p>);</c->
    <c- c1>// kv::second destructor will be invoked implicitly</c->
<c- p>}</c->

<c- k>struct</c-> <c- nc>V</c-> <c- p>{</c-> <c- b>int</c-> <c- n>_v</c-><c- p>;</c-> <c- p>};</c->
<c- k>struct</c-> <c- nc>B</c-> <c- o>:</c-> <c- n>public</c-> <c- n>virtual</c-> <c- n>V</c-> <c- p>{</c-> <c- b>int</c-> <c- n>_b</c-><c- p>;</c-> <c- p>};</c->
<c- k>struct</c-> <c- nc>D</c-> <c- o>:</c-> <c- n>B</c-> <c- p>{</c-> <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>_d</c-><c- p>;</c-> <c- p>};</c->
<c- b>void</c-> <c- nf>foo</c-><c- p>(</c-><c- n>D</c-> <c- k>const</c-> <c- n>d</c-> <c- n>reloc</c-><c- p>)</c->
<c- p>{</c->
    <c- c1>// d::B designates the base of former d object</c->
    <c- k>static_assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>is_same_v</c-><c- o>&lt;</c-><c- n>decltype</c-><c- p>(</c-><c- n>d</c-><c- o>::</c-><c- n>V</c-><c- p>),</c-> <c- n>V</c-> <c- k>const</c-><c- o>></c-><c- p>);</c->
    <c- k>static_assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>is_same_v</c-><c- o>&lt;</c-><c- n>decltype</c-><c- p>(</c-><c- n>d</c-><c- o>::</c-><c- n>B</c-><c- p>),</c-> <c- n>B</c-> <c- k>const</c-><c- o>></c-><c- p>);</c->
    <c- k>static_assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>is_same_v</c-><c- o>&lt;</c-><c- n>decltype</c-><c- p>(</c-><c- n>d</c-><c- o>::</c-><c- n>_d</c-><c- p>),</c-> <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- k>const</c-><c- o>></c-><c- p>);</c->
    <c- n>bar</c-><c- p>(</c-><c- n>reloc</c-> <c- n>d</c-><c- o>::</c-><c- n>B</c-><c- p>);</c-> <c- c1>// well-formed</c->
    <c- n>bar</c-><c- p>(</c-><c- n>reloc</c-> <c- n>d</c-><c- o>::</c-><c- n>V</c-><c- p>);</c-> <c- c1>// ill-formed, cannot relocate virtual base</c->
<c- p>}</c->
</pre>
   <h5 class="heading settled" data-level="5.2.2.1" id="decomposed-obj-namespace"><span class="secno">5.2.2.1. </span><span class="content">Namespace of the decomposed object</span><a class="self-link" href="#decomposed-obj-namespace"></a></h5>
   <p>All the subobjects of the decomposed object are introduced in a special
namespace.</p>
   <ul>
    <li data-md>
     <p>This namespace is only accessible from within the scope of the
decomposed object, had it not been decomposed.</p>
    <li data-md>
     <p>This namespace cannot be aliased.</p>
    <li data-md>
     <p>This namespace cannot be the target of a <code class="highlight"><c- k>using</c-> <c- k>namespace</c-></code> directive.</p>
    <li data-md>
     <p>If the decomposed object is anonymous, then it remains decomposed but its
subobjects are not accessible through any special namespace. Their
destructor will be invoked implicitly at scope exit. <strong>Note:</strong> Alternatively,
its subobjects could have been introduced in an anonymous namespace,
but doing so would create name clashes between base class type identifiers and
base class subobject identifiers.</p>
    <li data-md>
     <p>It is not an error if the special namespace identifier clashes with an
existing namespace identifier. In this case, name resolution will look-up
the special namespace unless explicit disambiguation is specified (<code class="highlight"><c- o>::</c-></code>).</p>
    <li data-md>
     <p>It is also not an error if the special namespace identifier clashes with
another existing special namespace identifier, introduced by an enclosing
scope. In this case, name resolution will look-up
the special namespace in the least-enclosing scope.
This is similar as to what happens when a variable "shadows" another.</p>
   </ul>
<pre class="language-c++ highlight"><c- n>namespace</c-> <c- n>np1</c->
<c- p>{</c->

<c- n>namespace</c-> <c- n>np2</c->
<c- p>{</c->

<c- k>static</c-> <c- kr>inline</c-> <c- k>const</c-> <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>_b</c-> <c- o>=</c-> <c- s>""</c-><c- p>;</c->
<c- k>static</c-> <c- kr>inline</c-> <c- k>const</c-> <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>_d</c-> <c- o>=</c-> <c- s>""</c-><c- p>;</c->

<c- p>}</c->

<c- k>struct</c-> <c- nc>D</c-> <c- p>{</c-> <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>_d</c-><c- p>;</c-> <c- p>}</c->

<c- b>void</c-> <c- n>foo</c-><c- p>(</c-><c- n>D</c-> <c- n>np2</c-> <c- n>reloc</c-><c- p>)</c->
<c- p>{</c->
    <c- c1>// np2::_d refers to the subobject of the decomposed np2 object.</c->
    <c- c1>// np2::_b is an unknown identifier</c->
    <c- c1>// ::np1::np2::_d and ::np1::np2::_b refer to the static storage objects.</c->
    <c- n>bar</c-><c- p>(</c-><c- n>reloc</c-> <c- n>np2</c-><c- o>::</c-><c- n>_d</c-><c- p>);</c->

    <c- p>{</c->
        <c- n>D</c-> <c- n>np2</c-> <c- n>reloc</c-> <c- o>=</c-> <c- n>getD</c-><c- p>();</c->
        <c- c1>// np2:: now refers to the subobjects of the line above</c->
        <c- n>std</c-><c- o>::</c-><c- n>cout</c-> <c- o>&lt;&lt;</c-> <c- n>np2</c-><c- o>::</c-><c- n>_d</c-> <c- o>&lt;&lt;</c-> <c- n>std</c-><c- o>::</c-><c- n>endl</c-><c- p>;</c->
    <c- p>}</c->
<c- p>}</c->

<c- p>}</c->
</pre>
   <h4 class="heading settled" data-level="5.2.3" id="ill-formed-decomposition"><span class="secno">5.2.3. </span><span class="content">Illegal decomposition</span><a class="self-link" href="#ill-formed-decomposition"></a></h4>
   <p>The decomposition of an object <code class="highlight"><c- n>src</c-></code> of type <code class="highlight"><c- n>T</c-></code> is ill-formed if any of
the following conditions is not satisfied:</p>
   <ul>
    <li data-md>
     <p>all subobjects of <code class="highlight"><c- n>src</c-></code> are accessible. They all need to be
since their destructor will be called if not relocated ;</p>
    <li data-md>
     <p>all declared special member functions of <code class="highlight"><c- n>T</c-></code> are declared either as
defaulted or deleted, <strong>or</strong> the call-site has private access privilege to <code class="highlight"><c- n>T</c-></code>.</p>
   </ul>
   <p>These requirements ensure that we can only decompose (a) compound types,
where subobjects have no dependencies with one another (like an <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>pair</c-></code>),
or (b) types that we are in control of (because of the private access).</p>
   <h4 class="heading settled" data-level="5.2.4" id="decompose-lambda"><span class="secno">5.2.4. </span><span class="content">Decomposition of a lambda closure type</span><a class="self-link" href="#decompose-lambda"></a></h4>
   <p>Lambda objects can be decomposed with the rules defined above. The subobjects
of the closure type are all the lambda captures which are captured by copy.
The decomposition can only happen from the lambda body and not from outside
the lambda, as if its captures had private access.</p>
   <p>The following is well-formed:</p>
<pre class="language-c++ highlight"><c- n>non_null</c-><c- o>&lt;</c-><c- n>unique_ptr</c-><c- o>&lt;</c-><c- b>int</c-><c- o>>></c-> <c- n>ptr</c-><c- p>;</c->
<c- k>auto</c-> <c- k>const</c-> <c- n>getPtr</c-> <c- o>=</c-> <c- p>[</c-><c- n>p</c-> <c- o>=</c-> <c- n>reloc</c-> <c- n>ptr</c-><c- p>](</c-><c- n>this</c-> <c- k>auto</c-> <c- n>self</c-> <c- n>reloc</c-><c- p>)</c->
<c- p>{</c->
    <c- n>foo</c-><c- p>(</c-><c- n>reloc</c-> <c- n>self</c-><c- o>::</c-><c- n>p</c-><c- p>);</c->
<c- p>};</c->
<c- p>(</c-><c- n>reloc</c-> <c- n>getPtr</c-><c- p>)();</c->
</pre>
   <p>But this is ill-formed:</p>
<pre class="language-c++ highlight"><c- n>non_null</c-><c- o>&lt;</c-><c- n>unique_ptr</c-><c- o>&lt;</c-><c- b>int</c-><c- o>>></c-> <c- n>ptr</c-><c- p>;</c->
<c- k>auto</c-> <c- k>const</c-> <c- n>getPtr</c-> <c- n>reloc</c-> <c- o>=</c-> <c- p>[</c-><c- n>p</c-> <c- o>=</c-> <c- n>reloc</c-> <c- n>ptr</c-><c- p>](</c-><c- n>this</c-> <c- k>auto</c-> <c- n>self</c-> <c- n>reloc</c-><c- p>)</c->
<c- p>{</c->
    <c- n>foo</c-><c- p>(</c-><c- n>reloc</c-> <c- n>self</c-><c- o>::</c-><c- n>p</c-><c- p>);</c->
<c- p>};</c->
<c- k>auto</c-> <c- n>ptr2</c-> <c- o>=</c-> <c- n>reloc</c-> <c- n>getPtr</c-><c- o>::</c-><c- n>p</c-><c- p>;</c-> <c- c1>// ill-formed, no access privilege to the captures</c->
</pre>
   <h4 class="heading settled" data-level="5.2.5" id="decompose-tmp"><span class="secno">5.2.5. </span><span class="content">Implicit decomposition of temporaries</span><a class="self-link" href="#decompose-tmp"></a></h4>
   <p>Temporary objects can be implicitly decomposed to allow relocations in the following
scenarios (but non exclusively):</p>
<pre class="language-c++ highlight"><c- k>struct</c-> <c- nc>D</c-> <c- o>:</c-> <c- n>public</c-> <c- n>B</c-> <c- p>{};</c->
<c- n>D</c-> <c- nf>getD</c-><c- p>();</c->
<c- n>std</c-><c- o>::</c-><c- n>pair</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>string</c-><c- o>></c-> <c- n>getPair</c-><c- p>();</c->

<c- n>B</c-> <c- n>b</c-> <c- o>=</c-> <c- n>getD</c-><c- p>();</c-> <c- d>/* under conditions, equivalent to:</c->
<c- d>    auto d reloc = getD(); B b = reloc d::B; */</c->
<c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>s</c-> <c- o>=</c-> <c- n>getPair</c-><c- p>().</c-><c- n>first</c-><c- p>;</c-> <c- d>/* under conditions, equivalent to:</c->
<c- d>    auto pair reloc = getPair(); std::string s = reloc pair::first; */</c->
</pre>
   <p>Inspired by <a href="https://eel.is/c++draft/class.temporary#6.sentence-2">[class.temporary</a>]
we add a clause to when a subobject of a temporary is to be converted to a
prvalue (for instance because passed to the relocation constructor or relocation
assignment operator).</p>
   <p>In all the expressions listed in <a href="https://eel.is/c++draft/class.temporary#6.sentence-2">6</a>,
the resulting expression can be converted to a prvalue with <em>implicit decomposition</em>:</p>
   <ul>
    <li data-md>
     <p>In <a href="https://eel.is/c++draft/class.temporary#6.3">6.3</a>, the C-array case,
the array decomposition is always legal and each of its elements are considered
as complete objects (their destructor will be implicitly invoked).
It’s only if that array element is relocated or further implicitly decomposed
that its destructor will not
be implicitly invoked (for that element only).
It is the only situation where the decomposition of an
array-type is possible.</p>
    <li data-md>
     <p>In <a href="https://eel.is/c++draft/class.temporary#6.5">6.5</a>, the pointer to data
member case, <strong>the pointer to data member must be constant-evaluated</strong>.
The language will identify which data member is pointed at.
It’s only if that data member is relocated or further implicitly decomposed
that its destructor will not be implicitly invoked.
The pointer must be constant-evaluated, as it is otherwise impossible
to know at compile-time whether it refers to a direct data member or
to one of a base class (in which case further implicit decompositions will
happen). This information is required at compile-time to access the
well-formedness of the expression.
If the pointer is not constant evaluated, then no implicit decomposition
can happen.</p>
   </ul>
   <p>The <em>implicit decomposition</em> materializes the temporary complete object.
Further implicitly decompositions occur for each data member access
(or array element access for array-types) or cast to a base class,
to extract the desired subobject.</p>
   <p>If any <em>implicit decomposition</em> is illegal, then it does not cause the program
to be ill-formed, the expression simply cannot be converted
to a prvalue (e.g. any relocation constructor or assignment operator are
discarded from overload resolution).
All the incurred decompositions must be legal, as defined <a href="#ill-formed-decomposition">here</a>, or else the <em>implicit decomposition</em> is
illegal. In particular, if any virtual base is to be decomposed,
then the <em>implicit decomposition</em> is illegal.</p>
   <p>For instance:</p>
<pre class="language-c++ highlight"><c- n>class</c-> <c- n>T</c->
<c- p>{</c->
<c- n>public</c-><c- o>:</c->
    <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>_pub</c-><c- p>;</c->
<c- n>private</c-><c- o>:</c->
    <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>_priv</c-><c- p>;</c->
<c- p>};</c->
<c- n>class</c-> <c- n>U</c->
<c- p>{</c->
<c- n>public</c-><c- o>:</c->
    <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>_pub</c-><c- p>[</c-><c- mi>5</c-><c- p>];</c->
<c- p>};</c->

<c- n>T</c-> <c- nf>getT</c-><c- p>();</c->
<c- n>U</c-> <c- nf>getU</c-><c- p>();</c->

<c- n>std</c-><c- o>::</c-><c- n>pair</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>string</c-><c- o>></c-> <c- n>getPair</c-><c- p>();</c->


<c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>a</c-> <c- o>=</c-> <c- n>getT</c-><c- p>().</c-><c- n>_pub</c-><c- p>;</c-> <c- d>/* implicit-decomposition is ill-formed</c->
<c- d>    because T has a private member, move constructor is used */</c->
<c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>b</c-> <c- o>=</c-> <c- n>getU</c-><c- p>().</c-><c- n>_pub</c-><c- p>[</c-><c- mi>2</c-><c- p>];</c-> <c- d>/* implicit-decomposition is ill-formed</c->
<c- d>    as reloc cannot be used on array elements, move constructor is used */</c->
<c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>c</c-> <c- o>=</c-> <c- n>getPair</c-><c- p>().</c-><c- n>second</c-><c- p>;</c-> <c- d>/* implicit-decomposition is well-formed;</c->
<c- d>    std::string’s relocation constructor is used */</c->
</pre>
   <h4 class="heading settled" data-level="5.2.6" id="decompose-value-param"><span class="secno">5.2.6. </span><span class="content">Decomposition of value parameters</span><a class="self-link" href="#decompose-value-param"></a></h4>
   <p>As we have seen, decomposition ends the lifetime of the source object.
The reader may be concerned that this may break existing ABIs, should the source
object be a function parameter passed by value.
However we do not foresee any extra breakage other than what the support for
the <code class="highlight"><c- n>reloc</c-></code> operator does.</p>
   <p>Indeed if the decomposed object is an <em>unowned parameter</em>, then the function
may silently relocate its argument to some local storage before the function
body is entered. <em>This is a putative
workaround and is not part of the proposal.</em></p>
   <p>For instance:</p>
   <table>
    <tbody>
     <tr>
      <th>User-written code
      <th>Putative equivalent generated code
     <tr>
      <td valign="top">
<pre class="highlight" lang="cpp"><c- b>void</c-> <c- nf>foo01</c-><c- p>(</c-><c- n>T</c-> <c- n>obj</c-> <c- n>reloc</c-><c- p>)</c->
<c- p>{</c->
    <c- c1>// ...</c->
    <c- k>if</c-> <c- p>(</c-><c- n>test</c-><c- p>())</c->
    <c- p>{</c->
        <c- n>sink</c-><c- p>(</c-><c- n>reloc</c-> <c- n>obj</c-><c- o>::</c-><c- n>m</c-><c- p>);</c->
    <c- p>}</c->
    <c- c1>// ...</c->
<c- p>}</c->
</pre>
      <td valign="top">
<pre class="highlight" lang="cpp"><c- b>void</c-> <c- nf>foo01</c-><c- p>(</c-><c- n>T</c-> <c- n>__obj</c-><c- p>)</c->
<c- p>{</c->
    <c- k>auto</c-> <c- n>obj</c-> <c- n>reloc</c-><c- p>{</c-><c- n>reloc</c-> <c- n>__obj</c-><c- p>};</c->
    <c- c1>// ...</c->
    <c- k>if</c-> <c- p>(</c-><c- n>test</c-><c- p>())</c->
    <c- p>{</c->
        <c- n>sink</c-><c- p>(</c-><c- n>reloc</c-> <c- n>obj</c-><c- o>::</c-><c- n>m</c-><c- p>);</c->
    <c- p>}</c->
    <c- c1>// ...</c->
<c- p>}</c->
</pre>
     <tr>
      <td valign="top">
<pre class="highlight" lang="cpp"><c- b>void</c-> <c- nf>foo02</c-><c- p>(</c-><c- n>T</c-> <c- n>obj</c-> <c- n>reloc</c-><c- p>)</c-> <c- k>try</c->
<c- p>{</c->
    <c- c1>// ...</c->
    <c- k>if</c-> <c- p>(</c-><c- n>test</c-><c- p>())</c->
    <c- p>{</c->
        <c- n>sink</c-><c- p>(</c-><c- n>reloc</c-> <c- n>obj</c-><c- o>::</c-><c- n>m</c-><c- p>);</c->
    <c- p>}</c->
    <c- c1>// ...</c->
<c- p>}</c->
<c- k>catch</c-> <c- p>(...)</c-> <c- p>{}</c->
</pre>
      <td valign="top">
<pre class="highlight" lang="cpp"><c- b>void</c-> <c- nf>foo02</c-><c- p>(</c-><c- n>T</c-> <c- n>__obj</c-><c- p>)</c-> <c- k>try</c->
<c- p>{</c->
    <c- k>auto</c-> <c- n>obj</c-> <c- n>reloc</c-><c- p>{</c-><c- n>reloc</c-> <c- n>__obj</c-><c- p>};</c->
    <c- c1>// ...</c->
    <c- k>if</c-> <c- p>(</c-><c- n>test</c-><c- p>())</c->
    <c- p>{</c->
        <c- n>sink</c-><c- p>(</c-><c- n>reloc</c-> <c- n>obj</c-><c- o>::</c-><c- n>m</c-><c- p>);</c->
    <c- p>}</c->
    <c- c1>// ...</c->
<c- p>}</c->
<c- k>catch</c-> <c- p>(...)</c-> <c- p>{}</c->
</pre>
   </table>
   <h4 class="heading settled" data-level="5.2.7" id="dot-reloc-constexpr"><span class="secno">5.2.7. </span><span class="content">Decomposition in constexpr</span><a class="self-link" href="#dot-reloc-constexpr"></a></h4>
   <p>Object decomposition can be used in constexpr functions and
constant-evaluated expressions.</p>
   <h4 class="heading settled" data-level="5.2.8" id="decomposed-object-examples"><span class="secno">5.2.8. </span><span class="content">Examples</span><a class="self-link" href="#decomposed-object-examples"></a></h4>
   <h5 class="heading settled" data-level="5.2.8.1" id="decomposed-object-ex-nominal"><span class="secno">5.2.8.1. </span><span class="content">Nominal case</span><a class="self-link" href="#decomposed-object-ex-nominal"></a></h5>
   <p>One of the main practical uses of object decomposition is for compound types, such as <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>pair</c-></code>. Note that this code would not be feasible without relocation and
without decomposition.</p>
<pre class="language-c++ highlight"><c- b>void</c-> <c- nf>bar</c-><c- p>(</c-><c- n>string</c-><c- p>,</c-> <c- n>non_null</c-><c- o>&lt;</c-><c- n>unique_ptr</c-><c- o>&lt;</c-><c- b>int</c-><c- o>>></c-><c- p>);</c->

<c- b>void</c-> <c- nf>foo</c-><c- p>(</c-><c- n>pair</c-><c- o>&lt;</c-><c- n>string</c-> <c- k>const</c-><c- p>,</c-> <c- n>non_null</c-><c- o>&lt;</c-><c- n>unique_ptr</c-><c- o>&lt;</c-><c- b>int</c-><c- o>>>></c-> <c- n>p</c-> <c- n>reloc</c-><c- p>)</c->
<c- p>{</c->
    <c- n>bar</c-><c- p>(</c-><c- n>reloc</c-> <c- n>p</c-><c- o>::</c-><c- n>first</c-><c- p>,</c-> <c- n>reloc</c-> <c- n>p</c-><c- o>::</c-><c- n>second</c-><c- p>);</c->
<c- p>}</c->
</pre>
   <h5 class="heading settled" data-level="5.2.8.2" id="decomposed-object-ex-extractor"><span class="secno">5.2.8.2. </span><span class="content">Custom extractor</span><a class="self-link" href="#decomposed-object-ex-extractor"></a></h5>
<pre class="language-c++ highlight"><c- n>class</c-> <c- n>T</c->
<c- p>{</c->
<c- n>private</c-><c- o>:</c->
    <c- n>string</c-> <c- k>const</c-> <c- n>_key</c-><c- p>;</c->
    <c- n>non_null</c-><c- o>&lt;</c-><c- n>unique_ptr</c-><c- o>&lt;</c-><c- b>int</c-><c- o>>></c-> <c- n>_val</c-><c- p>;</c->

<c- n>public</c-><c- o>:</c->
    <c- c1>// [...]</c->
    <c- n>non_null</c-><c- o>&lt;</c-><c- n>unique_ptr</c-><c- o>&lt;</c-><c- b>int</c-><c- o>>></c-> <c- n>getVal</c-><c- p>(</c-><c- n>this</c-> <c- n>T</c-> <c- n>self</c-> <c- n>reloc</c-><c- p>)</c->
    <c- p>{</c->
        <c- k>return</c-> <c- n>self</c-><c- o>::</c-><c- n>_val</c-><c- p>;</c->
        <c- c1>// note that here the destructor of self is not called.</c->
        <c- c1>// however every non relocated data member is still destructed</c->
        <c- c1>// so self._key.~string() is called at function exit.</c->
    <c- p>}</c->
<c- p>};</c->
</pre>
   <p>This code may be invoked in the following situations:</p>
<pre class="language-c++ highlight"><c- c1>// with: T getT();</c->
<c- c1>//       T src;</c->

<c- k>auto</c-> <c- n>val1</c-> <c- o>=</c-> <c- n>getT</c-><c- p>().</c-><c- n>getVal</c-><c- p>();</c->
<c- k>auto</c-> <c- n>val2</c-> <c- o>=</c-> <c- p>(</c-><c- n>reloc</c-> <c- n>src</c-><c- p>).</c-><c- n>getVal</c-><c- p>();</c->
</pre>
   <h5 class="heading settled" data-level="5.2.8.3" id="decomposed-object-putative-release"><span class="secno">5.2.8.3. </span><span class="content">Putative std::unique_ptr::release</span><a class="self-link" href="#decomposed-object-putative-release"></a></h5>
<pre class="language-c++ highlight"><c- n>template</c-> <c- o>&lt;</c-><c- n>class</c-> <c- n>T</c-><c- p>,</c-> <c- n>class</c-> <c- n>Deleter</c-><c- o>></c->
<c- n>class</c-> <c- n>unique_ptr</c->
<c- p>{</c->
<c- c1>// ...</c->
<c- n>public</c-><c- o>:</c->
    <c- n>T</c-><c- o>*</c-> <c- n>release</c-><c- p>(</c-><c- n>this</c-> <c- n>T</c-> <c- n>self</c-> <c- n>reloc</c-><c- p>)</c->
    <c- p>{</c->
        <c- k>return</c-> <c- n>self</c-><c- o>::</c-><c- n>_ptr</c-><c- p>;</c->
    <c- p>}</c->
<c- p>};</c->
</pre>
   <p>Because of the decomposition, the destructor of <code class="highlight"><c- n>self</c-></code> is not called. This code
safely releases the guarded pointer. Note that this <code class="highlight"><c- n>release</c-></code> function
is not part of the proposal.</p>
   <h3 class="heading settled" data-level="5.3" id="ill-formed-reuse"><span class="secno">5.3. </span><span class="content">Ill-formed reuse of relocated objects</span><a class="self-link" href="#ill-formed-reuse"></a></h3>
   <h4 class="heading settled" data-level="5.3.1" id="variable-state-tracking"><span class="secno">5.3.1. </span><span class="content">Variable state tracking</span><a class="self-link" href="#variable-state-tracking"></a></h4>
   <p>The <code class="highlight"><c- n>reloc</c-></code> operator changes the state of its operand, imposing
restrictions of how the variable can be used in the next expressions.</p>
   <p>Let us formally introduce the new states a local variable can have:</p>
   <ul>
    <li data-md>
     <p><em>alive</em> (<strong>A</strong>): this is the default state. As of today in C++, all variables are in this
state.</p>
    <li data-md>
     <p><em>relocated</em> (<strong>R</strong>): the variable was passed as operand to the <code class="highlight"><c- n>reloc</c-></code> operator.</p>
    <li data-md>
     <p><em>alive-or-relocated</em> (<strong>A-R</strong>): the variable may be <em>relocated</em> or <em>alive</em>. For instance
the variable will have this state at the end of an if statement,
if the variable was <em>relocated</em> in one path and remained <em>alive</em> in the other.</p>
   </ul>
   <p>Those states are evaluated <em>at compile-time</em>, and their primary use is to verify
the well-formedness of expressions.</p>
   <p>The state of a given variable (including function parameters) is evaluated as follows:</p>
   <ul>
    <li data-md>
     <p>The variable starts in the <strong>A</strong> state.</p>
    <li data-md>
     <p>The state of the variable is tracked by <em>examining</em> potentially-evaluated expressions,
from one expression to the next, following the evaluation order.</p>
     <ul>
      <li data-md>
       <p>If two or more expressions have an unspecified evaluation order with
one another, then
expressions containing a <code class="highlight"><c- n>reloc</c-></code> operator with the tracked variable as
operand are examined first (in any order).</p>
      <li data-md>
       <p>Expressions that are part of <a href="https://eel.is/c++draft/expr.context#1">unevaluated operands</a> are not examined.</p>
      <li data-md>
       <p>Expressions that are part of a <a href="https://eel.is/c++draft/stmt.if#def:discarded_statement">discarded statement</a> of a <code class="highlight"><c- k>constexpr</c-> <c- k>if</c-></code> statement are not examined.</p>
     </ul>
    <li data-md>
     <p>The <em>id-expression</em> designating the tracked variable is ill-formed
if the expression is examined and the variable’s state is not <strong>A</strong>.</p>
     <ul>
      <li data-md>
       <p>If the <em>id-expression</em> is used as operand of the <code class="highlight"><c- n>reloc</c-></code> operator,
then the variable transitions to the <strong>R</strong> state after the <code class="highlight"><c- n>reloc</c-></code> expression examination.</p>
     </ul>
    <li data-md>
     <p>If the code path forks (for instance because of an if statement), then all the
different code branches need to be examined.</p>
    <li data-md>
     <p>If two or more code paths rejoin, then the resulting state of the variable
is the <strong>OR</strong>-combination of the state it had in all the joined code branches.</p>
    <li data-md>
     <p>On a code jump:</p>
     <ul>
      <li data-md>
       <p>if the code jumps before the variable declaration or after the variable
enclosing scope, then the state analysis for this code branch stops here
for this variable.</p>
      <li data-md>
       <p>otherwise the state of the variable after the jump is the <strong>OR</strong>-combination
of the state it had before the jump, and the state it would have had at the
destination code location without taking the jump.
If the destination code location cannot be reached without jump, then
the jump does not change the state the variable.
The state of the variable prior to the jump is memorized for this code jump.</p>
      <li data-md>
       <p>if a same code jump needs to be taken an extra time, then the state of the variable
is compared to the one previously memorized. If they are identical then
the state analysis for this code branch stops here for this variable.
Otherwise the new state prior the jump is updated and the jump re-examined.</p>
     </ul>
    <li data-md>
     <p>In a try block, if the variable was declared before the block: at the end of
an expression that may throw,
a code jump to each catch block may be examined.
This code jump is necessary:</p>
     <ul>
      <li data-md>
       <p>if the state of the variable has changed prior to when the last jumps
to the catch blocks were made.</p>
      <li data-md>
       <p>or if no last jumps to catch blocks were made, then compare the state
the variable had when entering the try block against the current state
and perform the jumps if they differ.</p>
     </ul>
    <li data-md>
     <p>This state analysis stops until code reaches the natural end of scope of the
variable.</p>
   </ul>
   <p class="note" role="note"><span class="marker">NOTE:</span> We don’t expect this analysis to be costly. It is only necessary in functions
for the variables that are relocated or decomposed. If none of the two are used,
then this analysis is not needed.</p>
   <h4 class="heading settled" data-level="5.3.2" id="unevaluated-operands"><span class="secno">5.3.2. </span><span class="content">reloc in unevaluated operands</span><a class="self-link" href="#unevaluated-operands"></a></h4>
   <p>The <code class="highlight"><c- n>reloc</c-></code> operator can be used in <a href="https://eel.is/c++draft/expr.context#1">unevaluated operands</a>.
Such expressions are ignored by the code analysis described <a href="#variable-state-tracking">above</a>.
If <code class="highlight"><c- n>reloc</c-></code> is used in an unevaluated operands,
then (a) their operands are always considered to have the <em>alive</em> state,
and (b) the state of their operands do not change.</p>
   <p>For instance:</p>
<pre class="language-c++ highlight"><c- b>void</c-> <c- nf>foo</c-><c- p>(</c-><c- n>T</c-> <c- n>x</c-><c- p>)</c->
<c- p>{</c->
    <c- n>decltype</c-><c- p>(</c-><c- n>reloc</c-> <c- n>x</c-><c- p>)</c-> <c- n>y</c-> <c- o>=</c-> <c- n>reloc</c-> <c- n>x</c-><c- p>;</c-> <c- c1>// well-formed</c->
    <c- n>decltype</c-><c- p>(</c-><c- n>reloc</c-> <c- n>x</c-><c- p>,</c-> <c- p>(</c-><c- n>reloc</c-> <c- n>x</c-><c- p>).</c-><c- n>m</c-><c- p>)</c-> <c- n>z</c-> <c- o>=</c-> <c- n>y</c-><c- p>.</c-><c- n>m</c-><c- p>;</c-> <c- c1>// well-formed</c->
<c- p>}</c->
</pre>
   <h4 class="heading settled" data-level="5.3.3" id="reloc-dot-reloc-ill-formed-showcase"><span class="secno">5.3.3. </span><span class="content">Examples</span><a class="self-link" href="#reloc-dot-reloc-ill-formed-showcase"></a></h4>
   <p>Consider the following examples:</p>
<pre class="language-cpp highlight"><c- b>void</c-> <c- nf>reloc_showcase_01</c-><c- p>()</c->
<c- p>{</c->
  <c- k>const</c-> <c- n>T</c-> <c- n>var</c-> <c- o>=</c-> <c- n>getT</c-><c- p>();</c->
  <c- n>bar</c-><c- p>(</c-><c- n>reloc</c-> <c- n>var</c-><c- p>);</c->
  <c- k>if</c-> <c- p>(</c-><c- n>sometest</c-><c- p>(</c-><c- n>var</c-><c- p>))</c-> <c- c1>// ill-formed: state of 'var' is relocated</c->
    <c- n>do_smth</c-><c- p>(</c-><c- n>var</c-><c- p>);</c-> <c- c1>// ill-formed: state of 'var' is relocated</c->
<c- p>}</c->
</pre>
   <p><code class="highlight"><c- n>var</c-></code> cannot be reused after the <code class="highlight"><c- n>reloc</c-></code> call.</p>
<pre class="language-cpp highlight"><c- b>void</c-> <c- nf>reloc_showcase_02</c-><c- p>()</c->
<c- p>{</c->
  <c- k>const</c-> <c- n>T</c-> <c- n>var</c-><c- p>;</c->
  <c- p>{</c->
    <c- k>const</c-> <c- n>T</c-> <c- n>var</c-><c- p>;</c->
    <c- n>bar</c-><c- p>(</c-><c- n>reloc</c-> <c- n>var</c-><c- p>);</c->
    <c- n>do_smth</c-><c- p>(</c-><c- n>var</c-><c- p>);</c-> <c- c1>// #1 ill-formed: state of 'var' is relocated</c->
    <c- p>{</c->
      <c- k>const</c-> <c- n>T</c-> <c- n>var</c-><c- p>;</c->
      <c- n>do_smth</c-><c- p>(</c-><c- n>var</c-><c- p>);</c-> <c- c1>// OK</c->
    <c- p>}</c->
    <c- n>do_smth</c-><c- p>(</c-><c- n>var</c-><c- p>);</c-> <c- c1>// #2 ill-formed: state of 'var' is relocated</c->
  <c- p>}</c->
  <c- n>do_smth</c-><c- p>(</c-><c- n>var</c-><c- p>);</c-> <c- c1>// OK</c->
<c- p>}</c->
</pre>
   <p>At #1 and #2, the calls to <code class="highlight"><c- n>do_smth</c-><c- p>(</c-><c- n>var</c-><c- p>)</c-></code> are allowed because the name <code class="highlight"><c- n>var</c-></code> does not resolve to the relocated object.</p>
<pre class="language-cpp highlight"><c- b>void</c-> <c- nf>reloc_showcase_03</c-><c- p>()</c->
<c- p>{</c->
  <c- k>const</c-> <c- n>T</c-> <c- n>var</c-> <c- o>=</c-> <c- n>getT</c-><c- p>();</c->
  <c- k>if</c-> <c- p>(</c-><c- n>sometest</c-><c- p>(</c-><c- n>var</c-><c- p>))</c->
    <c- n>bar</c-><c- p>(</c-><c- n>reloc</c-> <c- n>var</c-><c- p>);</c-> <c- c1>// #1, var state is relocated</c->
  <c- k>else</c->
    <c- n>do_smth</c-><c- p>(</c-><c- n>var</c-><c- p>);</c-> <c- c1>// #2, var state is alive</c->
  <c- c1>// var state is alive-or-relocated</c->
<c- p>}</c->
</pre>
   <p>At #2 <code class="highlight"><c- n>do_smth</c-><c- p>(</c-><c- n>var</c-><c- p>)</c-></code> is allowed because <code class="highlight"><c- n>var</c-></code> state is not affected by the <code class="highlight"><c- n>reloc</c-></code> call at #1 (they occur in different code branches).</p>
<pre class="language-cpp highlight"><c- b>void</c-> <c- nf>reloc_showcase_04</c-><c- p>()</c->
<c- p>{</c->
  <c- k>const</c-> <c- n>T</c-> <c- n>var</c-> <c- o>=</c-> <c- n>getT</c-><c- p>();</c->
  <c- k>if</c-> <c- p>(</c-><c- n>sometest</c-><c- p>(</c-><c- n>var</c-><c- p>))</c->
    <c- n>bar</c-><c- p>(</c-><c- n>reloc</c-> <c- n>var</c-><c- p>);</c-> <c- c1>// #1</c->
  <c- k>else</c->
    <c- n>do_smth</c-><c- p>(</c-><c- n>var</c-><c- p>);</c-> <c- c1>// OK</c->
  <c- c1>// [...]</c->
  <c- n>do_smth_else</c-><c- p>(</c-><c- n>var</c-><c- p>);</c-> <c- c1>// #2, ill-formed: state of 'var' is A-R</c->
<c- p>}</c->
</pre>
   <p>At #2, <code class="highlight"><c- n>do_smth_else</c-><c- p>(</c-><c- n>var</c-><c- p>)</c-></code> is an error because <code class="highlight"><c- n>var</c-></code> is mentioned after the <code class="highlight"><c- n>reloc</c-></code> call at #1.</p>
<pre class="language-cpp highlight"><c- b>void</c-> <c- nf>reloc_showcase_05</c-><c- p>()</c->
<c- p>{</c->
  <c- k>const</c-> <c- n>T</c-> <c- n>var</c-> <c- o>=</c-> <c- n>getT</c-><c- p>();</c->
  <c- k>if</c-> <c- p>(</c-><c- n>sometest</c-><c- p>(</c-><c- n>var</c-><c- p>))</c->
    <c- n>bar</c-><c- p>(</c-><c- n>reloc</c-> <c- n>var</c-><c- p>);</c->
  <c- k>else</c->
    <c- n>do_smth</c-><c- p>(</c-><c- n>reloc</c-> <c- n>var</c-><c- p>);</c-> <c- c1>// OK</c->
    <c- c1>// var state is relocated</c->
<c- p>}</c->
</pre>
   <p>Both <code class="highlight"><c- n>reloc</c-></code> are okay as they happen on different code paths.</p>
<pre class="language-cpp highlight"><c- b>void</c-> <c- nf>reloc_showcase_06</c-><c- p>()</c->
<c- p>{</c->
  <c- k>const</c-> <c- n>T</c-> <c- n>var</c-> <c- o>=</c-> <c- n>getT</c-><c- p>();</c->
  <c- b>bool</c-> <c- n>relocated</c-> <c- o>=</c-> false<c- p>;</c->
  <c- k>if</c-> <c- p>(</c-><c- n>sometest</c-><c- p>(</c-><c- n>var</c-><c- p>))</c->
  <c- p>{</c->
    <c- n>bar</c-><c- p>(</c-><c- n>reloc</c-> <c- n>var</c-><c- p>);</c->
    <c- n>relocated</c-> <c- o>=</c-> true<c- p>;</c->
  <c- p>}</c->
  <c- k>else</c->
    <c- n>do_smth</c-><c- p>(</c-><c- n>var</c-><c- p>);</c-> <c- c1>// OK</c->
  <c- c1>// [...]</c->
  <c- k>if</c-> <c- p>(</c-><c- o>!</c-><c- n>relocated</c-><c- p>)</c->
    <c- n>do_smth_else</c-><c- p>(</c-><c- n>var</c-><c- p>);</c-> <c- c1>// ill-formed: state of 'var' is A-R</c->
<c- p>}</c->
</pre>
   <p>It does not matter that the developer tried to do the safe thing with the <code class="highlight"><c- n>relocated</c-></code> variable. The code-path analysis disregards run-time values and
explores all branches of an <code class="highlight"><c- k>if</c-></code> statement.</p>
<pre class="language-cpp highlight"><c- b>void</c-> <c- nf>reloc_showcase_07</c-><c- p>()</c->
<c- p>{</c->
  <c- k>constexpr</c-> <c- b>bool</c-> <c- n>relocated_v</c-> <c- o>=</c-> <c- n>my_can_relocate</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-><c- p>{}();</c->
  <c- k>const</c-> <c- n>T</c-> <c- n>var</c-> <c- o>=</c-> <c- n>getT</c-><c- p>();</c->
  <c- k>if</c-> <c- k>constexpr</c-><c- p>(</c-><c- n>relocated_v</c-><c- p>)</c->
  <c- p>{</c->
    <c- n>bar</c-><c- p>(</c-><c- n>reloc</c-> <c- n>var</c-><c- p>);</c->
  <c- p>}</c->
  <c- k>else</c->
    <c- n>do_smth</c-><c- p>(</c-><c- n>var</c-><c- p>);</c-> <c- c1>// OK</c->
  <c- c1>// [...]</c->
  <c- c1>// var state is R if relocated_v is true, A otherwise</c->
  <c- k>if</c-> <c- k>constexpr</c-><c- p>(</c-><c- o>!</c-><c- n>relocated_v</c-><c- p>)</c->
    <c- n>do_smth_else</c-><c- p>(</c-><c- n>var</c-><c- p>);</c-> <c- c1>// OK</c->
<c- p>}</c->
</pre>
   <p>The above example is safe because of the use of <code class="highlight"><c- k>if</c-> <c- k>constexpr</c-></code>.</p>
<pre class="language-cpp highlight"><c- b>void</c-> <c- nf>reloc_showcase_08</c-><c- p>()</c->
<c- p>{</c->
  <c- k>const</c-> <c- n>T</c-> <c- n>var</c-> <c- o>=</c-> <c- n>getT</c-><c- p>();</c->
  <c- k>if</c-> <c- p>(</c-><c- n>sometest</c-><c- p>(</c-><c- n>var</c-><c- p>))</c->
  <c- p>{</c->
    <c- n>bar</c-><c- p>(</c-><c- n>reloc</c-> <c- n>var</c-><c- p>);</c->
    <c- k>return</c-><c- p>;</c->
  <c- p>}</c->
  <c- n>do_smth</c-><c- p>(</c-><c- n>var</c-><c- p>);</c-> <c- c1>// OK</c->
<c- p>}</c->
</pre>
   <p>This example is also safe thanks to the <code class="highlight"><c- k>return</c-></code> statement right after the <code class="highlight"><c- n>reloc</c-></code> instruction, which prevents from running <code class="highlight"><c- n>do_smth</c-><c- p>(</c-><c- n>var</c-><c- p>);</c-></code>.</p>
<pre class="language-cpp highlight"><c- b>void</c-> <c- nf>reloc_showcase_09</c-><c- p>()</c->
<c- p>{</c->
  <c- k>const</c-> <c- n>T</c-> <c- n>var</c-> <c- o>=</c-> <c- n>getT</c-><c- p>();</c->
  <c- k>for</c-> <c- p>(</c-><c- b>int</c-> <c- n>i</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>i</c-> <c- o>!=</c-> <c- mi>10</c-><c- p>;</c-> <c- o>++</c-><c- n>i</c-><c- p>)</c->
    <c- n>do_smth</c-><c- p>(</c-><c- n>reloc</c-> <c- n>var</c-><c- p>);</c-> <c- c1>// ill-formed: state of 'var' is A-R (on second iteration)</c->
<c- p>}</c->
</pre>
   <p>This is ill-formed as each iteration reuses <code class="highlight"><c- n>var</c-></code> which is declared before
the loop body.</p>
   <p>In the code path analysis:</p>
   <ol>
    <li data-md>
     <p>At the first loop iteration, the variable gains the <em>relocated</em> state.</p>
    <li data-md>
     <p>The loop increment is examined, and it does not change the state of <code class="highlight"><c- n>var</c-></code>.</p>
    <li data-md>
     <p>The loop condition is examined, and it does not change the state of <code class="highlight"><c- n>var</c-></code>.</p>
    <li data-md>
     <p>The code jump is examined for the first time, memorizing the state of <code class="highlight"><c- n>var</c-></code> at that moment (<em>relocated</em>).</p>
    <li data-md>
     <p>The new state of <code class="highlight"><c- n>var</c-></code> is now <strong>A-R</strong>.</p>
    <li data-md>
     <p><code class="highlight"><c- n>do_smth</c-><c- p>(</c-><c- n>reloc</c-> <c- n>var</c-><c- p>)</c-></code> is examined, and <code class="highlight"><c- n>reloc</c-> <c- n>var</c-></code> is ill-formed as <code class="highlight"><c- n>var</c-></code> is not in the <em>alive</em> state.</p>
   </ol>
<pre class="language-cpp highlight"><c- b>void</c-> <c- nf>reloc_showcase_10</c-><c- p>()</c->
<c- p>{</c->
  <c- k>const</c-> <c- n>T</c-> <c- n>var</c-> <c- o>=</c-> <c- n>getT</c-><c- p>();</c->
  <c- k>for</c-> <c- p>(</c-><c- b>int</c-> <c- n>i</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>i</c-> <c- o>!=</c-> <c- mi>10</c-><c- p>;</c-> <c- o>++</c-><c- n>i</c-><c- p>)</c->
  <c- p>{</c->
    <c- k>if</c-> <c- p>(</c-><c- n>i</c-> <c- o>==</c-> <c- mi>9</c-><c- p>)</c->
      <c- n>do_smth</c-><c- p>(</c-><c- n>reloc</c-> <c- n>var</c-><c- p>);</c-> <c- c1>// ill-formed: state of 'var' is A-R (on second iteration)</c->
    <c- k>else</c->
      <c- n>do_smth</c-><c- p>(</c-><c- n>var</c-><c- p>);</c-> <c- c1>// ill-formed: state of 'var' is A-R (on second iteration)</c->
  <c- p>}</c->
<c- p>}</c->
</pre>
   <p>This is ill-formed for the same reason as above.</p>
<pre class="language-cpp highlight"><c- b>void</c-> <c- nf>reloc_showcase_11</c-><c- p>()</c->
<c- p>{</c->
  <c- k>const</c-> <c- n>T</c-> <c- n>var</c-> <c- o>=</c-> <c- n>getT</c-><c- p>();</c->
  <c- k>for</c-> <c- p>(</c-><c- b>int</c-> <c- n>i</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>i</c-> <c- o>!=</c-> <c- mi>10</c-><c- p>;</c-> <c- o>++</c-><c- n>i</c-><c- p>)</c->
  <c- p>{</c->
    <c- k>if</c-> <c- p>(</c-><c- n>i</c-> <c- o>==</c-> <c- mi>9</c-><c- p>)</c-> <c- p>{</c->
      <c- n>do_smth</c-><c- p>(</c-><c- n>reloc</c-> <c- n>var</c-><c- p>);</c-> <c- c1>// OK, var state is relocated</c->
      <c- k>break</c-><c- p>;</c->
    <c- p>}</c->
    <c- k>else</c->
      <c- n>do_smth</c-><c- p>(</c-><c- n>var</c-><c- p>);</c-> <c- c1>// OK, var state is alive</c->
  <c- p>}</c->
  <c- c1>// var state is A-R</c->
<c- p>}</c->
</pre>
   <p>Adding the break statement right after the <code class="highlight"><c- n>reloc</c-></code> call makes the code snippet well-formed.
Indeed the <code class="highlight"><c- k>break</c-></code> statement forces the loop exit, which implies that the
conditional jump at the end of loop (that may start the next iteration) is no
longer part of the code path that follows the <code class="highlight"><c- n>reloc</c-></code> instruction.</p>
<pre class="language-cpp highlight"><c- b>void</c-> <c- nf>reloc_showcase_12</c-><c- p>()</c->
<c- p>{</c->
  <c- k>for</c-> <c- p>(</c-><c- b>int</c-> <c- n>i</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>i</c-> <c- o>!=</c-> <c- mi>10</c-><c- p>;</c-> <c- o>++</c-><c- n>i</c-><c- p>)</c->
  <c- p>{</c->
    <c- k>const</c-> <c- n>T</c-> <c- n>var</c-> <c- o>=</c-> <c- n>getT</c-><c- p>();</c->
    <c- n>do_smth</c-><c- p>(</c-><c- n>reloc</c-> <c- n>var</c-><c- p>);</c-> <c- c1>// OK</c->
  <c- p>}</c->
<c- p>}</c->
</pre>
   <p><code class="highlight"><c- n>var</c-></code> is local to the for-loop body, so <code class="highlight"><c- n>reloc</c-></code> is well-formed here.
The code path analysis for this variable does not require several loop iterations,
as the variable scope ends before the code jump leading to the next iteration
is evaluated.</p>
<pre class="language-cpp highlight"><c- b>void</c-> <c- nf>reloc_showcase_13</c-><c- p>()</c->
<c- p>{</c->
  <c- k>const</c-> <c- n>T</c-> <c- n>var</c-> <c- o>=</c-> <c- n>getT</c-><c- p>();</c->
<c- nl>from</c-><c- p>:</c-> <c- c1>// #1</c->
  <c- k>if</c-> <c- p>(</c-><c- n>sometest</c-><c- p>(</c-><c- n>var</c-><c- p>))</c-> <c- c1>// #2, ill-formed: var state is A-R after the jump</c->
  <c- p>{</c->
    <c- n>do_smth</c-><c- p>(</c-><c- n>var</c-><c- p>);</c-> <c- c1>// #3, ill-formed: var state is A-R after the jump</c->
    <c- k>return</c-><c- p>;</c->
  <c- p>}</c->
  <c- k>else</c->
  <c- p>{</c->
    <c- n>do_smth</c-><c- p>(</c-><c- n>reloc</c-> <c- n>var</c-><c- p>);</c-> <c- c1>// #4, ill-formed: var state is A-R after the jump</c->
  <c- p>}</c->
  <c- c1>// #5</c->
  <c- k>goto</c-> <c- n>from</c-><c- p>;</c->
<c- p>}</c->
</pre>
   <p>Because of #4, the state of <code class="highlight"><c- n>var</c-></code> at #5 is <strong>R</strong>. The goto statement is executed
and we are back at #1. <code class="highlight"><c- n>var</c-></code> state is then the OR combination of the <strong>A</strong> state
and the <strong>R</strong> state, which is <strong>A-R</strong>.
Then the expressions #2, #3 and #4 are ill-formed because <code class="highlight"><c- n>var</c-></code> is not in the <strong>A</strong> state.</p>
<pre class="language-cpp highlight"><c- b>void</c-> <c- nf>reloc_showcase_14</c-><c- p>()</c->
<c- p>{</c->
  <c- k>const</c-> <c- n>T</c-> <c- n>var</c-> <c- o>=</c-> <c- n>getT</c-><c- p>();</c->
<c- nl>from</c-><c- p>:</c->
  <c- k>if</c-> <c- p>(</c-><c- n>sometest</c-><c- p>(</c-><c- n>var</c-><c- p>))</c-> <c- c1>// var state is alive</c->
  <c- p>{</c->
    <c- n>do_smth</c-><c- p>(</c-><c- n>var</c-><c- p>);</c-> <c- c1>// var state is alive</c->
    <c- k>goto</c-> <c- n>from</c-><c- p>;</c->
  <c- p>}</c->
  <c- k>else</c->
  <c- p>{</c->
    <c- n>do_smth</c-><c- p>(</c-><c- n>reloc</c-> <c- n>var</c-><c- p>);</c->
  <c- p>}</c->
<c- p>}</c->
</pre>
   <p>In this scenario <code class="highlight"><c- k>goto</c-></code> is placed in a way that does not trigger the reuse of relocated <code class="highlight"><c- n>var</c-></code>.</p>
<pre class="language-cpp highlight"><c- b>void</c-> <c- nf>reloc_showcase_15</c-><c- p>()</c->
<c- p>{</c->
  <c- k>union</c-> <c- p>{</c-> <c- n>T</c-> <c- n>x</c-><c- p>;</c-> <c- n>U</c-> <c- n>y</c-><c- p>;</c-> <c- p>};</c->
  <c- n>x</c-> <c- o>=</c-> <c- n>getT</c-><c- p>();</c->
  <c- k>if</c-> <c- p>(</c-><c- n>sometest</c-><c- p>(</c-><c- n>x</c-><c- p>))</c->
  <c- p>{</c->
    <c- n>do_smth</c-><c- p>(</c-><c- n>reloc</c-> <c- n>x</c-><c- p>);</c->
    <c- n>x</c-> <c- o>=</c-> <c- n>getT</c-><c- p>();</c-> <c- c1>// well-formed</c->
  <c- p>}</c->
  <c- k>else</c->
  <c- p>{</c->
    <c- n>reloc</c-> <c- n>x</c-><c- p>;</c-> <c- c1>// destroy x</c->
    <c- n>y</c-> <c- o>=</c-> <c- n>getU</c-><c- p>();</c->
    <c- n>do_smth_else</c-><c- p>(</c-><c- n>reloc</c-> <c- n>y</c-><c- p>);</c-> <c- c1>// well-formed</c->
    <c- n>x</c-> <c- o>=</c-> <c- n>getT</c-><c- p>();</c-> <c- c1>// well-formed</c->
  <c- p>}</c->
  <c- n>do_smth_else</c-><c- p>(</c-><c- n>reloc</c-> <c- n>y</c-><c- p>);</c-> <c- c1>// well-formed</c->
<c- p>}</c->
</pre>
   <p><code class="highlight"><c- n>reloc</c-></code> does not prevent from reusing the names of anonymous union members.</p>
<pre class="language-cpp highlight"><c- b>void</c-> <c- nf>reloc_showcase_16</c-><c- p>()</c->
<c- p>{</c->
  <c- n>T</c-> <c- n>x</c-><c- p>;</c->
  <c- k>if</c-> <c- p>(</c-><c- n>sometest</c-><c- p>(</c-><c- n>x</c-><c- p>))</c->
  <c- p>{</c->
    <c- n>do_smth</c-><c- p>(</c-><c- n>reloc</c-> <c- n>x</c-><c- p>);</c->
  <c- p>}</c->
  <c- k>else</c->
  <c- p>{</c->
    <c- k>auto</c-> <c- k>const</c-> <c- n>y</c-> <c- n>reloc</c-> <c- o>=</c-> <c- n>reloc</c-> <c- n>x</c-><c- p>;</c->
    <c- n>do_smth_else</c-><c- p>(</c-><c- n>reloc</c-> <c- n>y</c-><c- o>::</c-><c- n>m</c-><c- p>);</c-> <c- c1>// well-formed</c->
    <c- c1>// equivalent to: do_smth_else((reloc x).m);</c->
  <c- p>}</c->
  <c- n>do_another_thing</c-><c- p>(</c-><c- n>x</c-><c- p>);</c-> <c- c1>// ill-formed: state is now R</c->
<c- p>}</c->
</pre>
   <p><code class="highlight"><c- n>do_another_thing</c-><c- p>(</c-><c- n>x</c-><c- p>)</c-></code> is ill-formed as <code class="highlight"><c- n>x</c-></code> is relocated.</p>
<pre class="language-cpp highlight"><c- b>void</c-> <c- nf>reloc_showcase_17</c-><c- p>()</c->
<c- p>{</c->
  <c- n>T</c-> <c- n>x</c-><c- p>;</c->
  <c- k>if</c-> <c- p>(</c-><c- n>sometest</c-><c- p>(</c-><c- n>x</c-><c- p>)</c-> <c- o>||</c-> <c- n>sometest</c-><c- p>(</c-><c- n>reloc</c-> <c- n>x</c-><c- p>))</c-> <c- c1>// well-formed: x state is A-R</c->
  <c- p>{</c->
    <c- n>do_smth</c-><c- p>(</c-><c- n>x</c-><c- p>);</c-> <c- c1>// ill-formed: x state is A-R</c->
  <c- p>}</c->
  <c- k>else</c-> <c- k>if</c-> <c- p>(</c-><c- n>othertest</c-><c- p>(</c-><c- n>x</c-><c- p>))</c-> <c- c1>// ill-formed: x state is A-R</c->
  <c- p>{</c->
    <c- n>foo</c-><c- p>();</c->
  <c- p>}</c->
<c- p>}</c->
</pre>
<pre class="language-cpp highlight"><c- b>void</c-> <c- nf>reloc_showcase_18</c-><c- p>()</c->
<c- p>{</c->
  <c- c1>// unspecified evaluation order</c->
  <c- p>{</c-> <c- n>T</c-> <c- n>x</c-><c- p>;</c-> <c- k>auto</c-> <c- n>y</c-> <c- o>=</c-> <c- n>reloc</c-> <c- n>x</c-> <c- o>+</c-> <c- n>reloc</c-> <c- n>x</c-><c- p>;</c-> <c- p>}</c-> <c- c1>// ill-formed</c->
  <c- p>{</c-> <c- n>T</c-> <c- n>x</c-><c- p>;</c-> <c- k>auto</c-> <c- n>y</c-> <c- o>=</c-> <c- n>x</c-> <c- o>+</c-> <c- n>reloc</c-> <c- n>x</c-><c- p>;</c-> <c- p>}</c-> <c- c1>// ill-formed</c->
  <c- p>{</c-> <c- n>T</c-> <c- n>x</c-><c- p>;</c-> <c- k>auto</c-> <c- n>y</c-> <c- o>=</c-> <c- n>reloc</c-> <c- n>x</c-> <c- o>+</c-> <c- n>x</c-><c- p>;</c-> <c- p>}</c-> <c- c1>// ill-formed</c->
  <c- p>{</c-> <c- n>T</c-> <c- n>x</c-><c- p>;</c-> <c- k>auto</c-> <c- n>y</c-> <c- o>=</c-> <c- n>x</c-><c- p>[</c-><c- n>reloc</c-> <c- n>x</c-><c- p>];</c-> <c- p>}</c-> <c- c1>// ill-formed</c->

  <c- c1>// sequenced evaluation order</c->
  <c- p>{</c-> <c- n>T</c-> <c- n>x</c-><c- p>;</c-> <c- k>auto</c-> <c- n>y</c-> <c- o>=</c-> <c- n>x</c-><c- p>,</c-> <c- n>reloc</c-> <c- n>x</c-><c- p>;</c-> <c- p>}</c-> <c- c1>// well-formed</c->
  <c- p>{</c-> <c- n>T</c-> <c- n>x</c-><c- p>;</c-> <c- k>auto</c-> <c- n>y</c-> <c- o>=</c-> <c- n>reloc</c-> <c- n>x</c-><c- p>,</c-> <c- n>x</c-><c- p>;</c-> <c- p>}</c-> <c- c1>// ill-formed</c->
  <c- p>{</c-> <c- n>T</c-> <c- n>x</c-><c- p>;</c-> <c- k>auto</c-> <c- n>y</c-> <c- o>=</c-> <c- n>x</c-> <c- n>or</c-> <c- n>reloc</c-> <c- n>x</c-><c- p>;</c-> <c- p>}</c-> <c- c1>// well-formed</c->
  <c- p>{</c-> <c- n>T</c-> <c- n>x</c-><c- p>;</c-> <c- k>auto</c-> <c- n>y</c-> <c- o>=</c-> <c- n>reloc</c-> <c- n>x</c-> <c- n>or</c-> <c- n>x</c-><c- p>;</c-> <c- p>}</c-> <c- c1>// ill-formed</c->

  <c- c1>// unspecified evaluation order with ternary</c->
  <c- p>{</c-> <c- n>T</c-> <c- n>x</c-><c- p>;</c-> <c- n>foo</c-><c- p>(</c-><c- n>x</c-><c- p>,</c-> <c- n>reloc</c-> <c- n>x</c-><c- p>);</c-> <c- p>}</c-> <c- c1>// ill-formed</c->
  <c- p>{</c-> <c- n>T</c-> <c- n>x</c-><c- p>;</c-> <c- n>foo</c-><c- p>(</c-><c- n>x</c-><c- p>,</c-> <c- n>test</c-><c- p>()</c-> <c- o>?</c-> <c- n>reloc</c-> <c- n>x</c-> <c- o>:</c-> <c- n>x</c-><c- p>);</c-> <c- p>}</c-> <c- c1>// ill-formed</c->
  <c- p>{</c-> <c- n>T</c-> <c- n>x</c-><c- p>;</c-> <c- n>foo</c-><c- p>(</c-><c- n>test</c-><c- p>()</c-> <c- o>?</c-> <c- n>reloc</c-> <c- n>x</c-> <c- o>:</c-> <c- n>x</c-><c- p>);</c-> <c- p>}</c-> <c- c1>// well-formed</c->
<c- p>}</c->
</pre>
   <p>If two or more expressions have an unspecified evaluation order,
then to determine their well-formedness
we examine the expressions containing <code class="highlight"><c- n>reloc</c-></code> first, and
examine the rest after (in any order).</p>
<pre class="language-cpp highlight"><c- b>void</c-> <c- nf>reloc_showcase_19</c-><c- p>()</c->
<c- p>{</c->
  <c- n>T</c-> <c- n>x</c-> <c- o>=</c-> <c- n>getT</c-><c- p>();</c->
  <c- k>try</c->
  <c- p>{</c->
    <c- n>foo</c-><c- p>();</c->
    <c- n>bar</c-><c- p>(</c-><c- n>reloc</c-> <c- n>x</c-><c- p>);</c->
  <c- p>}</c->
  <c- k>catch</c-> <c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>exception</c-> <c- k>const</c-><c- o>&amp;</c-> <c- n>excp</c-><c- p>)</c->
  <c- p>{</c->
    <c- n>std</c-><c- o>::</c-><c- n>cerr</c-> <c- o>&lt;&lt;</c-> <c- n>excp</c-><c- p>.</c-><c- n>what</c-><c- p>()</c-> <c- o>&lt;&lt;</c-> <c- s>" for "</c-> <c- o>&lt;&lt;</c-> <c- n>x</c-> <c- o>&lt;&lt;</c-> <c- n>std</c-><c- o>::</c-><c- n>endl</c-><c- p>;</c->
    <c- c1>// ill-formed: x state is alive or relocated</c->
  <c- p>}</c->
<c- p>}</c->
</pre>
   <h4 class="heading settled" data-level="5.3.4" id="conditional-reloc"><span class="secno">5.3.4. </span><span class="content">Conditional destruction</span><a class="self-link" href="#conditional-reloc"></a></h4>
   <p class="note" role="note"><span class="marker">NOTE:</span> This section only applies to variables that are not ref-qualified.</p>
   <p>The variable state analysis described <a href="#variable-state-tracking">here</a> may be used to know what kind of cleanup is necessary at scope exit
(i.e. if the end of scope is reached or an exception is emitted).</p>
   <p>When this happens, if the variable is in <strong>A-R</strong> state, and that its type is
not trivial, then
implementations must track <em>at runtime</em> the actual state of the variable
(<strong>A</strong> or <strong>R</strong>)
and process its destruction accordingly:</p>
   <ul>
    <li data-md>
     <p>If the variable was the operand in an evaluated <code class="highlight"><c- n>reloc</c-></code> expression, then
the variable may need to be destructed following the rules described <a href="#reloc-src-obj-lifetime">here</a>.</p>
    <li data-md>
     <p>Otherwise the variable must be destructed by its destructor following normal
rules.</p>
   </ul>
   <p class="note" role="note"><span class="marker">NOTE:</span> If the variable was the operand of a <code class="highlight"><c- n>reloc</c-></code> expression,
    but that expression was <em>not evaluated</em>, then <em>its lifetime is not affected</em> and the variable must still be destroyed
    normally.</p>
   <p>How this runtime tracking is done is <em>implementation-defined</em>, although it will probably take the form of extra flags
in the function stack.</p>
   <p>For instance:</p>
<pre class="language-c++ highlight"><c- b>void</c-> <c- nf>foo</c-><c- p>()</c->
<c- p>{</c->
    <c- n>T</c-> <c- n>obj</c-> <c- o>=</c-> <c- d>/* ... */</c-><c- p>;</c->
    <c- k>if</c-> <c- p>(</c-><c- n>some_test</c-><c- p>())</c->
        <c- n>bar</c-><c- p>(</c-><c- n>reloc</c-> <c- n>obj</c-><c- p>);</c-> <c- c1>// obj state is relocated</c->
    <c- k>else</c->
        <c- n>handle_error</c-><c- p>();</c-> <c- c1>// obj state is alive</c->
    <c- n>live_on</c-><c- p>();</c-> <c- c1>// obj state is alive-or-relocated</c->
<c- p>}</c->
</pre>
   <p>After the call to <code class="highlight"><c- n>live_on</c-><c- p>()</c-></code>, or should <code class="highlight"><c- n>live_on</c-></code> throw, <code class="highlight"><c- n>obj</c-></code> destructor
is only implicitly invoked if <code class="highlight"><c- n>reloc</c-> <c- n>obj</c-></code> was not evaluated. Implementations may simply turn on
a flag right before the evaluation of the <code class="highlight"><c- n>reloc</c-></code> expression.</p>
   <p>Concerns have been expressed that extra flags would violate the "don’t pay for
what you don’t use" principle. We acknowledge this concern, but feel that the
user is getting at least something out of this. Alternatives would be for the source
object to be destroyed implicitly at the opening or closing brace of the <code class="highlight"><c- k>else</c-></code>,
for the code to be ill-formed unless the source object is relocated within the <code class="highlight"><c- k>else</c-></code>, or for the code to be ill-formed unconditionally. Note that in each of these
cases, the user can recover our preferred behavior in library, using <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>optional</c-></code> to add the tracking flags that in our proposal would be provided by the language.</p>
   <h3 class="heading settled" data-level="5.4" id="reloc-ctor"><span class="secno">5.4. </span><span class="content">Relocation constructor</span><a class="self-link" href="#reloc-ctor"></a></h3>
   <p>Now that we have introduced the <code class="highlight"><c- n>reloc</c-></code> operator and object decomposition, we
introduce the relocation constructor, which is built upon those new concepts.
As relocation happens from prvalues,
the constructor takes a prvalue as parameter: <code class="highlight"><c- n>T</c-><c- p>(</c-><c- n>T</c-><c- p>)</c-></code>.</p>
   <p>This signature was picked as it completes the C++ tripartite value system.
The copy constructor creates a new instance from an lvalue, the move constructor
from an xvalue, and then the relocation constructor from a prvalue.</p>
   <p class="note" role="note"><span class="marker">Note:</span> a further benefit of this syntax is that it is currently ill-formed <a href="http://wg21.link/class.copy.ctor#5">[class.copy.ctor]/5</a>, and
thus available for extension.</p>
   <p>A point of confusion may be that the syntax implies an infinite regress: the
parameter must be constructed, which requires a prior call to the relocation
constructor, and so on. This is not the case; if the source object was previously
the operand of the <code class="highlight"><c- n>reloc</c-></code> operator, it was transformed into a prvalue
immediately before entering the relocation constructor, and the parameter of the
relocation constructor is that same prvalue. (If the source object was already a
prvalue, there is no issue; the parameter is that prvalue.)</p>
   <p>An attractive intuition is that the parameter aliases the source object in the
same way as a reference or a structured binding declaration.
However, this is misleading; the lifetime of a source object glvalue has already
ended and so use of a pointer or reference referring to the source object has
undefined behavior, except as provided by [basic.life] and [class.cdtor].</p>
   <p class="note" role="note"><span class="marker">Note:</span> this behavior matches that for the destructor of a class type; see <a href="https://wg21.link/basic.life#1.4">[basic.life]</a> paragraph 1.</p>
   <p>This intuition is only useful in so far as the ABI for a relocation
constructor prvalue parameter is likely to be the same as that for a copy or move
constructor parameter, since the prvalue parameter may have the same storage
location as a previously existing glvalue.</p>
   <p class="note" role="note"><span class="marker">Note:</span> it does not matter that the ABI for the relocation constructor parameter
differs from that for a prvalue parameter in normal functions, since it is not
possible to take the address of a constructor.</p>
   <p>The role of the relocation constructor is to construct a new instance by <em>destructively
stealing</em> the resources from the source object. Unlike the move
constructor, the relocation constructor needs not to leave the source object in
valid state.</p>
   <h4 class="heading settled" data-level="5.4.1" id="reloc-ctor-is-2nd-dtor"><span class="secno">5.4.1. </span><span class="content">The relocation constructor is a second destructor</span><a class="self-link" href="#reloc-ctor-is-2nd-dtor"></a></h4>
   <p>The relocation constructor <strong>is a second destructor</strong> of the class-type
with regards to the source object. Indeed, the lifetime of the source object
was ended immediately prior to entering the relocation constructor, and thus
the source object is considered as destructed thereafter.
In particular, once an object has been passed to its relocation constructor, its
destructor must not be implicitly invoked.
See <a href="#reloc-ctor-dtor-def">destruction of the source object</a> section
for more details.</p>
   <h4 class="heading settled" data-level="5.4.2" id="reloc-ctor-declaration"><span class="secno">5.4.2. </span><span class="content">Declaration</span><a class="self-link" href="#reloc-ctor-declaration"></a></h4>
   <p>The relocation constructor can be declared (implicitly or explicitly), defaulted
and deleted like any other constructor.</p>
   <p>The relocation constructor of a class-type <code class="highlight"><c- n>T</c-></code> implicitly gets a <code class="highlight"><c- k>noexcept</c-><c- p>(</c->true<c- p>)</c-></code> exception specification unless:</p>
   <ul>
    <li data-md>
     <p>it is explicitly declared with <code class="highlight"><c- k>noexcept</c-><c- p>(</c->false<c- p>)</c-></code> ;</p>
    <li data-md>
     <p>or one <code class="highlight"><c- n>T</c-></code>’s subobjects has a <code class="highlight"><c- k>noexcept</c-><c- p>(</c->false<c- p>)</c-></code> relocation constructor ;</p>
    <li data-md>
     <p>or one <code class="highlight"><c- n>T</c-></code>’s subobjects does not declare a relocation constructor and has
a <code class="highlight"><c- k>noexcept</c-><c- p>(</c->false<c- p>)</c-></code> move constructor.</p>
   </ul>
   <p>These rules are similar to that of the destructor’s implicit exception specification.</p>
   <p>A class-type that provides a relocation constructor has some impact on the program
ABI. See the <a href="#abi">ABI section</a>.</p>
   <h5 class="heading settled" data-level="5.4.2.1" id="reloc-ctor-declaration-implicit"><span class="secno">5.4.2.1. </span><span class="content">Implicit declaration</span><a class="self-link" href="#reloc-ctor-declaration-implicit"></a></h5>
   <p>If a class-type follows the Rule of Zero (updated to account for the relocation
constructor and relocation assignment operator), then the compiler will declare
a non-explicit inline public relocation constructor,
i.e. if none of the following are user-declared:</p>
   <ul>
    <li data-md>
     <p>copy constructor</p>
    <li data-md>
     <p>copy assignment operator</p>
    <li data-md>
     <p>move constructor</p>
    <li data-md>
     <p>move assignment operator</p>
    <li data-md>
     <p>destructor</p>
    <li data-md>
     <p>relocation assignment operator</p>
   </ul>
   <h5 class="heading settled" data-level="5.4.2.2" id="reloc-ctor-declaration-deleted"><span class="secno">5.4.2.2. </span><span class="content">Deleted implicitly-declared or defaulted relocation constructor</span><a class="self-link" href="#reloc-ctor-declaration-deleted"></a></h5>
   <p>The implicitly-declared or defaulted relocation constructor for class <code class="highlight"><c- n>T</c-></code> is defined as deleted:</p>
   <ul>
    <li data-md>
     <p>if <code class="highlight"><c- n>T</c-></code> has subobjects that explicitly declare a deleted relocation constructor ;</p>
    <li data-md>
     <p>or <code class="highlight"><c- n>T</c-></code> has subobjects with missing relocation and move constructors (i.e.
that are deleted, inaccessible, or ambiguous).</p>
    <li data-md>
     <p>or <code class="highlight"><c- n>T</c-></code> has subobjects with deleted or unaccessible destructor.</p>
   </ul>
   <p>As for move constructors, a defaulted relocation constructor that is deleted is
ignored by overload resolution.</p>
   <p class="note" role="note"><span class="marker">Note:</span> this means that a class with an explictly deleted relocation constructor
will still be relocated if necessary, but through the move (or copy) constructor
and destructor.</p>
   <h5 class="heading settled" data-level="5.4.2.3" id="trivial-relocation"><span class="secno">5.4.2.3. </span><span class="content">Trivial relocation</span><a class="self-link" href="#trivial-relocation"></a></h5>
   <p>A relocation constructor of a class type <code class="highlight"><c- n>X</c-></code> is <em>trivial</em> if it is not user-provided and
if:</p>
   <ul>
    <li data-md>
     <p><code class="highlight"><c- n>X</c-></code> has no virtual functions and no virtual base classes, and</p>
    <li data-md>
     <p>for each direct base class and direct non-static data member of class type or array thereof,
the relocation operation (which may be a relocation constructor or
synthesized from copy/move constructor plus destructor) selected
to relocate that base or member is trivial.</p>
   </ul>
   <p>A <em>trivially relocatable class</em> is one which:</p>
   <ul>
    <li data-md>
     <p>has a trivial, eligible relocation constructor, or</p>
    <li data-md>
     <p>does not have a relocation constructor (including one that is deleted),
and is trivially copyable.</p>
   </ul>
   <p class="note" role="note"><span class="marker">Note:</span> <em>eligible</em> is defined in <a href="http://wg21.link/special#def:special_member_function,eligible">[special]</a>.</p>
   <p>Scalar types, trivially relocatable class types, and arrays and cv-qualified versions
thereof are <em>trivially relocatable</em>.</p>
   <p><strong class="advisement"> We also tighten the definition of "trivial class" (and thus "trivial") to
require that the class in question be trivially relocatable as well as trivially
copyable. This is to ensure that if the user wants code to be called on relocation,
the library does not bypass said code by, say, using <code class="highlight"><c- n>memmove</c-></code>.</strong></p>
   <h4 class="heading settled" data-level="5.4.3" id="reloc-ctor-definition"><span class="secno">5.4.3. </span><span class="content">Definition</span><a class="self-link" href="#reloc-ctor-definition"></a></h4>
   <h5 class="heading settled" data-level="5.4.3.1" id="reloc-ctor-dtor-def"><span class="secno">5.4.3.1. </span><span class="content">Destruction of the source object</span><a class="self-link" href="#reloc-ctor-dtor-def"></a></h5>
   <p>As mentioned above, the relocation constructor <strong>is a second destructor</strong> of
the class-type.
Once its body has been executed,
the relocation constructor proceeds with the
destruction of the source object in a similar manner as the destructor:</p>
   <ul>
    <li data-md>
     <p>All its subobjects will be destructed in reverse declaration
order, unless they got relocated.</p>
    <li data-md>
     <p>If not already decomposed, the runtime type information of all its base
classes is adjusted to that of their base class.</p>
    <li data-md>
     <p>If the constructor initialization sequence or body exits because of an
exception, this destruction sequence
is triggered by stack unwinding.</p>
   </ul>
   <h5 class="heading settled" data-level="5.4.3.2" id="reloc-dtor-virtual-bases"><span class="secno">5.4.3.2. </span><span class="content">Virtual bases</span><a class="self-link" href="#reloc-dtor-virtual-bases"></a></h5>
   <p>Virtual bases have a special treatment in constructors and destructors:
they are only contructed and destructed by the class-type of the complete object,
and not by its base classes.
The relocation constructor has the same behavior.
Hence it must be passed with the same extra information
that is passed today to any constructor and to the destructor:
(a) whether it is in charge of the construction of the virtual bases, and
(b) whether it is in charge of the destructon of the virtual bases of the source object.</p>
   <p>It follows that the relocation constructor will construct the virtual
bases of the target object (respectively destroy them from the source object)
only if the extra information <em>(a)</em> (respectively <em>(b)</em>) states so.</p>
   <p>For instance:</p>
<pre class="language-c++ highlight"><c- n>class</c-> <c- n>B</c->
<c- p>{</c->
    <c- n>B</c-><c- p>(</c-><c- n>B</c-> <c- n>src</c-><c- p>);</c->
    <c- c1>// [...]</c->
<c- p>};</c->
<c- n>class</c-> <c- n>C</c-> <c- o>:</c-> <c- n>public</c-> <c- n>virtual</c-> <c- n>B</c->
<c- p>{</c->
    <c- n>C</c-><c- p>(</c-><c- n>C</c-> <c- n>src</c-><c- p>);</c->
    <c- c1>// [...]</c->
<c- p>};</c->
<c- n>class</c-> <c- n>D</c-> <c- o>:</c-> <c- n>public</c-> <c- n>C</c->
<c- p>{</c->
    <c- n>D</c-><c- p>(</c-><c- n>D</c-> <c- n>src</c-><c- p>);</c->
    <c- c1>// [...]</c->
<c- p>};</c->

<c- b>void</c-> <c- nf>foo</c-><c- p>(</c-><c- n>C</c-><c- p>);</c->

<c- b>void</c-> <c- nf>bar</c-><c- p>()</c->
<c- p>{</c->
    <c- n>D</c-> <c- k>const</c-> <c- n>d</c-> <c- n>reloc</c-> <c- o>=</c-> <c- n>getD</c-><c- p>();</c->
    <c- n>foo</c-><c- p>(</c-><c- n>reloc</c-> <c- n>d</c-><c- o>::</c-><c- n>C</c-><c- p>);</c-> <c- c1>// #1</c->
<c- p>}</c->
</pre>
   <p>Here, at #1 when <code class="highlight"><c- n>bar</c-></code> calls the <code class="highlight"><c- n>C</c-></code>’s relocation constructor to build the
parameter of <code class="highlight"><c- n>foo</c-></code>:</p>
   <ul>
    <li data-md>
     <p><code class="highlight"><c- n>C</c-><c- p>(</c-><c- n>C</c-><c- p>)</c-></code> is in charge of constructing the virtual base <code class="highlight"><c- n>B</c-></code> ;</p>
    <li data-md>
     <p><code class="highlight"><c- n>C</c-><c- p>(</c-><c- n>C</c-><c- p>)</c-></code> is <strong>not</strong> in charge of destroying the virtual base <code class="highlight"><c- n>B</c-></code> of its parameter. <code class="highlight"><c- n>src</c-><c- p>.</c-><c- o>~</c-><c- n>B</c-><c- p>()</c-></code> is not called by the relocation constructor ;</p>
    <li data-md>
     <p>The default implementation of <code class="highlight"><c- n>C</c-><c- p>(</c-><c- n>C</c-><c- p>)</c-></code> will move-construct the virtual base ;</p>
    <li data-md>
     <p><code class="highlight"><c- n>foo</c-></code> gets a <code class="highlight"><c- n>C</c-></code> object owning its virtual base.</p>
   </ul>
   <p>After #1:</p>
   <ul>
    <li data-md>
     <p><code class="highlight"><c- n>d</c-><c- o>::</c-><c- n>B</c-></code> still points to valid data, albeit that it was likely moved-from
in <code class="highlight"><c- n>C</c-><c- p>(</c-><c- n>C</c-><c- p>)</c-></code> ;</p>
    <li data-md>
     <p><code class="highlight"><c- n>d</c-><c- o>::</c-><c- n>B</c-></code> destructor will be implicitly invoked, as it will be for all the data
members of <code class="highlight"><c- n>d</c-><c- o>::</c-><c- n>D</c-></code> ;</p>
   </ul>
   <h5 class="heading settled" data-level="5.4.3.3" id="reloc-ctor-default-definition"><span class="secno">5.4.3.3. </span><span class="content">Default definition</span><a class="self-link" href="#reloc-ctor-default-definition"></a></h5>
   <p>The default relocation constructor implementation for a class-type <code class="highlight"><c- n>T</c-></code> depends
on <code class="highlight"><c- n>T</c-></code>’s type traits.</p>
   <p>If <code class="highlight"><c- n>T</c-></code> is trivially relocatable then the relocation constructor
effectively (ignoring padding) performs
a <code class="highlight"><c- n>memcpy</c-></code> over its entire memory layout.</p>
   <p>Otherwise the constructor implementation first decomposes
the source object, and then performs
memberwise relocations. In the relocation constructor <code class="highlight"><c- n>T</c-><c- p>(</c-><c- n>T</c-> <c- n>src</c-> <c- n>reloc</c-><c- p>)</c-></code>,
for each subobject <code class="highlight"><c- n>s</c-></code> (of type <code class="highlight"><c- n>S</c-></code>) of <code class="highlight"><c- n>T</c-></code>, in declaration order:</p>
   <ul>
    <li data-md>
     <p>if <code class="highlight"><c- n>S</c-></code> is a virtual base, then <code class="highlight"><c- n>S</c-></code> is move-or-copy-constructed as if by: <code class="highlight"><c- n>S</c-><c- p>{</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>src</c-><c- o>::</c-><c- n>S</c-><c- p>)}</c-></code> ;</p>
    <li data-md>
     <p>otherwise we construct <code class="highlight"><c- n>s</c-></code> (or <code class="highlight"><c- n>S</c-></code> for direct base classes)
by calling its own relocation, move or copy
constructor, as if by: <code class="highlight"><c- n>s</c-><c- p>{</c-><c- n>reloc</c-> <c- n>src</c-><c- o>::</c-><c- n>s</c-><c- p>}</c-></code> (or <code class="highlight"><c- n>S</c-><c- p>{</c-><c- n>reloc</c-> <c- n>src</c-><c- o>::</c-><c- n>S</c-><c- p>}</c-></code>);</p>
   </ul>
   <p class="note" role="note"><span class="marker">NOTE:</span> If the relocation constructor is defaulted, then the <code class="highlight"><c- n>reloc</c-></code> keyword
marking the decomposition of the source object does not need to be specified.
All the following definitions are well-formed and equivalent:</p>
<pre class="language-c++ highlight"><c- n>T</c-><c- p>(</c-><c- n>T</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
<c- n>T</c-><c- p>(</c-><c- n>T</c-> <c- n>src</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
<c- n>T</c-><c- p>(</c-><c- n>T</c-> <c- n>src</c-> <c- n>reloc</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
<c- n>T</c-><c- p>(</c-><c- n>T</c-> <c- n>reloc</c-><c- p>)</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
</pre>
   <h5 class="heading settled" data-level="5.4.3.4" id="reloc-ctor-user-definition"><span class="secno">5.4.3.4. </span><span class="content">User-provided definition</span><a class="self-link" href="#reloc-ctor-user-definition"></a></h5>
   <p>Although the default definition should cover almost all cases, users can provide
their own definition of the relocation constructor. Doing so is relatively
straightforward thanks to the object decomposition feature.
The only reason we have found to write a custom relocation constructor is to adjust some
self-referencing pointers, otherwise the default implementation should suffice.</p>
   <p>Consider the following examples:</p>
<pre class="language-c++ highlight"><c- k>struct</c-> <c- nc>T</c->
<c- p>{</c->
    <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>_a</c-><c- p>,</c-> <c- n>_b</c-><c- p>,</c-> <c- n>_c</c-><c- p>;</c->

    <c- c1>// Dummy example to explain all the steps of the relocation constructor.</c->
    <c- n>T</c-><c- p>(</c-><c- n>T</c-> <c- n>src</c-> <c- n>reloc</c-><c- p>)</c-> <c- o>:</c->
        <c- n>_a</c-><c- p>{</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>src</c-><c- o>::</c-><c- n>_a</c-><c- p>)},</c-> <c- n>_c</c-><c- p>{</c-><c- n>reloc</c-> <c- n>src</c-><c- o>::</c-><c- n>_c</c-><c- p>}</c-> <c- p>{}</c-> <c- d>/*</c->
<c- d>        1. T::_a is constructed using the move constructor.</c->
<c- d>        2. T::_b is default constructed.</c->
<c- d>        3. T::_c is constructed using std::string’s relocation</c->
<c- d>           constructor, from src._c.</c->
<c- d>        4. src._b and src._a are destructed (in that order)</c->
<c- d>           when the constructor body exits.</c->
<c- d>    */</c->
<c- p>};</c->

<c- k>struct</c-> <c- nc>U</c->
<c- p>{</c->
    <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>_a</c-><c- p>;</c->

    <c- o>~</c-><c- n>U</c-><c- p>();</c->

    <c- c1>// Second dummy example.</c->
    <c- n>U</c-><c- p>(</c-><c- n>U</c-> <c- n>src</c-><c- p>)</c-> <c- p>{}</c-> <c- d>/*</c->
<c- d>        1. U::_a is default-constructed.</c->
<c- d>        2. Although src is not explicitly decomposed, and that</c->
<c- d>           src has a user-provided destructor,</c->
<c- d>           src destructor is not called, only src._a is.</c->
<c- d>    */</c->
<c- p>};</c->

<c- c1>// Motivating example</c->
<c- n>template</c-> <c- o>&lt;</c-><c- n>class</c-> <c- n>T</c-><c- o>></c->
<c- n>class</c-> <c- n>BinaryTree</c->
<c- p>{</c->
<c- n>public</c-><c- o>:</c->
    <c- c1>// works also if T is relocate-only</c->
    <c- n>BinaryTree</c-><c- p>(</c-><c- n>BinaryTree</c-> <c- n>src</c-> <c- n>reloc</c-><c- p>)</c-> <c- o>:</c-> <c- n>_root</c-><c- p>{</c-><c- n>reloc</c-> <c- n>src</c-><c- o>::</c-><c- n>_root</c-><c- p>}</c->
    <c- p>{</c->
        <c- d>/* fixup references */</c->
        <c- k>if</c-> <c- p>(</c-><c- n>_root</c-><c- p>.</c-><c- n>_left</c-><c- p>)</c->
            <c- n>_root</c-><c- p>.</c-><c- n>_left</c-><c- o>-></c-><c- n>_parent</c-> <c- o>=</c-> <c- o>&amp;</c-><c- n>_root</c-><c- p>;</c->
        <c- k>if</c-> <c- p>(</c-><c- n>_root</c-><c- p>.</c-><c- n>_right</c-><c- p>)</c->
            <c- n>_root</c-><c- p>.</c-><c- n>_right</c-><c- o>-></c-><c- n>_parent</c-> <c- o>=</c-> <c- o>&amp;</c-><c- n>_root</c-><c- p>;</c->
    <c- p>}</c->
<c- n>private</c-><c- o>:</c->
    <c- k>struct</c-> <c- nc>BTNode</c-> <c- p>{</c->
        <c- n>BTNode</c-><c- o>*</c-> <c- n>_parent</c-> <c- o>=</c-> <c- n>nullptr</c-><c- p>;</c->
        <c- n>BTNode</c-><c- o>*</c-> <c- n>_left</c->   <c- o>=</c-> <c- n>nullptr</c-><c- p>;</c->
        <c- n>BTNode</c-><c- o>*</c-> <c- n>_right</c->  <c- o>=</c-> <c- n>nullptr</c-><c- p>;</c->
        <c- n>T</c-> <c- n>_value</c-><c- p>;</c->
    <c- p>};</c->
    <c- n>BTNode</c-> <c- n>_root</c-><c- p>;</c->
<c- p>};</c->
</pre>
   <h5 class="heading settled" data-level="5.4.3.5" id="reloc-ctor-delegate"><span class="secno">5.4.3.5. </span><span class="content">Delegating relocation constructor</span><a class="self-link" href="#reloc-ctor-delegate"></a></h5>
   <p>We do not support writing a delegating relocation constructor. Doing would raise
several problems that are difficult to solve:</p>
   <ul>
    <li data-md>
     <p><code class="highlight"><c- n>T</c-><c- p>(</c-><c- n>T</c-> <c- n>src</c-><c- p>,</c-> <c- p>[...])</c-></code> with non-defaulted extra parameters after <code class="highlight"><c- n>src</c-></code> is a valid
syntax today and considering this as a putative relocation constructor may
break existing code ;</p>
    <li data-md>
     <p>When relocation constructor delegates to another relocation constructor,
the source object needs to be relocated in the parameter slot of the
delegating relocation constructor, causing infinite regress ;</p>
    <li data-md>
     <p>It’s the relocation constructor responsibility to properly destruct
non-relocated subobjects of the source object.
This rule would need to be clarified if a delegating relocation constructor
is called somehow or else we will have double destruction.</p>
   </ul>
   <p>For all those reasons, using <code class="highlight"><c- n>reloc</c-></code> on the source object of the relocation
constructor is likely wrong, and compiler vendors are encouraged to emit a
warning in that case.</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> We do not consider this as a blocking issue. <a href="#reloc-ctor-additional-params">Additional default parameters</a> are supported with the relocation constructor. And the relocation constructor
may still delegate to another non-relocating constructor:</p>
<pre class="language-c++ highlight"><c- k>struct</c-> <c- nc>T</c->
<c- p>{</c->
    <c- n>T</c-><c- p>(</c-><c- n>T</c-> <c- n>src</c-><c- p>)</c-> <c- o>:</c-> <c- n>T</c-><c- p>{</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>src</c-><c- p>),</c-> <c- n>Helper</c-><c- p>{}}</c-> <c- p>{}</c-> <c- d>/*</c->
<c- d>        all subobjects of src are destroyed upon exit */</c->
    <c- c1>// [...]</c->
<c- n>private</c-><c- o>:</c->
    <c- n>T</c-><c- p>(</c-><c- n>T</c-><c- o>&amp;&amp;</c-> <c- n>src</c-><c- p>,</c-> <c- n>Helper</c-><c- p>);</c-> <c- d>/* can only be called from the relocation constructor.</c->
<c- d>        may leave src in a dirty state, as we know src destructor body will not</c->
<c- d>        be called. */</c->
<c- p>};</c->
</pre>
   <h5 class="heading settled" data-level="5.4.3.6" id="reloc-ctor-additional-params"><span class="secno">5.4.3.6. </span><span class="content">Additional parameters</span><a class="self-link" href="#reloc-ctor-additional-params"></a></h5>
   <p>As with copy and move constructors, it is permissible to add additional parameters
to a relocation constructor, on condition they have a default initializer.</p>
   <p>One case where this can be of use is if the user needs space to store information
and/or resources
for the duration of the relocation constructor, for a contrived example:</p>
<pre class="language-c++ highlight"><c- n>class</c-> <c- n>T</c->
<c- p>{</c->
<c- n>public</c-><c- o>:</c->
    <c- n>class</c-> <c- n>Helper</c-> <c- p>{</c->
    <c- n>public</c-><c- o>:</c->
        <c- n>Helper</c-><c- p>()</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
        <c- o>~</c-><c- n>Helper</c-><c- p>()</c-> <c- p>{</c-> <c- n>delete</c-> <c- n>p</c-><c- p>;</c-> <c- p>}</c->
    <c- n>private</c-><c- o>:</c->
        <c- n>friend</c-> <c- n>T</c-><c- p>;</c->
        <c- b>int</c-><c- o>*</c-> <c- n>p</c-><c- p>;</c->
    <c- p>};</c->

    <c- n>T</c-><c- p>(</c-><c- n>T</c-> <c- n>src</c-> <c- n>reloc</c-><c- p>,</c-> <c- n>Helper</c-> <c- n>storage</c-> <c- o>=</c-> <c- p>{})</c-> <c- n>noexcept</c-><c- p>(</c->false<c- p>)</c->
        <c- o>:</c-> <c- n>_p</c-><c- p>(</c-><c- n>storage</c-><c- p>.</c-><c- n>p</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>exchange</c-><c- p>(</c-><c- n>src</c-><c- o>::</c-><c- n>_p</c-><c- p>,</c-> <c- n>nullptr</c-><c- p>))</c->
        <c- p>,</c-> <c- n>_q</c-><c- p>{</c-><c- n>reloc</c-> <c- n>src</c-><c- o>::</c-><c- n>_q</c-><c- p>}</c->
        <c- p>,</c-> <c- n>_r</c-><c- p>{</c-><c- n>reloc</c-> <c- n>src</c-><c- o>::</c-><c- n>_r</c-><c- p>}</c->
    <c- p>{</c->
        <c- n>storage</c-><c- p>.</c-><c- n>p</c-> <c- o>=</c-> <c- n>nullptr</c-><c- p>;</c->
    <c- p>}</c->

    <c- o>~</c-><c- n>T</c-><c- p>()</c-> <c- p>{</c->
        <c- n>delete</c-> <c- n>_p</c-><c- p>;</c->
    <c- p>}</c->

<c- n>private</c-><c- o>:</c->
    <c- b>int</c-><c- o>*</c-> <c- n>_p</c-><c- p>;</c->
    <c- n>RelocateOnly</c-> <c- n>_q</c-><c- p>;</c->
    <c- n>ThrowingRelocate</c-> <c- n>_r</c-><c- p>;</c->
<c- p>};</c->
</pre>
   <p>In the above, <code class="highlight"><c- n>T</c-><c- o>::</c-><c- n>_p</c-></code> does not manage its own lifetime,
but the presence of <code class="highlight"><c- n>T</c-><c- o>::</c-><c- n>_r</c-></code> means that <code class="highlight"><c- n>T</c-><c- o>::</c-><c- n>T</c-><c- p>(</c-><c- n>T</c-><c- p>)</c-></code> is not noexcept so we need to
release its resources if an exception is thrown during relocation.</p>
   <h4 class="heading settled" data-level="5.4.4" id="reloc-ctor-invoke"><span class="secno">5.4.4. </span><span class="content">Invocation</span><a class="self-link" href="#reloc-ctor-invoke"></a></h4>
   <p>The relocation constructor is invoked <em>as necessary</em> to relocate a prvalue
from one storage location to another. Use of the <code class="highlight"><c- n>reloc</c-></code> operator does not
guarantee that a relocation constructor (if present) will be called,
since it may be elided
if the compiler can arrange that the source glvalue was constructed at the
appropriate address.</p>
   <p>In particular, code of the form <code class="highlight"><c- n>T</c-> <c- n>x</c-> <c- o>=</c-> <c- n>reloc</c-> <c- n>y</c-><c- p>;</c-></code> is <em>highly</em> likely to be a
no-op, simply renaming an existing object. This is however likely to find use
for "sealing" objects with complex initialization, replacing the idiom of
immediately-invoked function expressions (IIFEs, <a data-link-type="biblio" href="#biblio-iife" title="IIFE for Complex Initialization - C++ Stories">[IIFE]</a>):</p>
   <table>
    <tbody>
     <tr>
      <th>Before
      <th>After
     <tr>
      <td valign="top">
<pre class="highlight" lang="cpp"><c- n>T</c-> <c- k>const</c-> <c- n>x</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>invoke</c-><c- p>([</c-><c- o>&amp;</c-><c- p>]</c->
<c- p>{</c->
    <c- n>T</c-> <c- n>x</c-><c- p>;</c->
    <c- n>x</c-><c- p>.</c-><c- n>modify</c-><c- p>(</c-><c- n>y</c-><c- p>,</c-> <c- n>z</c-><c- p>);</c->
    <c- k>return</c-> <c- n>x</c-><c- p>;</c->
<c- p>});</c->
</pre>
      <td valign="top">
<pre class="highlight" lang="cpp"><c- n>T</c-> <c- n>x_mut</c-><c- p>;</c->
<c- n>x_mut</c-><c- p>.</c-><c- n>modify</c-><c- p>(</c-><c- n>y</c-><c- p>,</c-> <c- n>z</c-><c- p>);</c->
<c- n>T</c-> <c- k>const</c-> <c- n>x</c-> <c- o>=</c-> <c- n>reloc</c-> <c- n>x_mut</c-><c- p>;</c->
</pre>
   </table>
   <p>Or, consider:</p>
<pre class="language-c++ highlight"><c- n>C</c-> <c- nf>f</c-><c- p>(</c-><c- b>int</c-> <c- n>i</c-><c- p>)</c-> <c- p>{</c->
    <c- n>C</c-> <c- n>c1</c-><c- p>,</c-> <c- n>c2</c-><c- p>;</c->
    <c- k>if</c-> <c- p>(</c-><c- n>i</c-> <c- o>==</c-> <c- mi>0</c-><c- p>)</c->
        <c- p>[[</c-><c- n>likely</c-><c- p>]]</c-> <c- k>return</c-> <c- n>reloc</c-> <c- n>c1</c-><c- p>;</c->  <c- c1>// #1</c->
    <c- k>else</c-> <c- k>if</c-> <c- p>(</c-><c- n>i</c-> <c- o>==</c-> <c- mi>1</c-><c- p>)</c->
        <c- p>[[</c-><c- n>likely</c-><c- p>]]</c-> <c- k>return</c-> <c- n>c1</c-><c- p>;</c->  <c- c1>// #2</c->
    <c- k>else</c->
        <c- p>[[</c-><c- n>unlikely</c-><c- p>]]</c-> <c- k>return</c-> <c- n>c2</c-><c- p>;</c->  <c- c1>// #3</c->
<c- p>}</c->
</pre>
   <p>At <code class="highlight"><c- cp>#1</c-></code> the <code class="highlight"><c- n>reloc</c-></code> is largely redundant; the end-of-life optimization means
the compiler is entitled to treat <code class="highlight"><c- n>c1</c-></code> as a prvalue anyway, as in <code class="highlight"><c- cp>#2</c-></code>. Indeed,
the likelihood annotation encourages the compiler to construct <code class="highlight"><c- n>c1</c-></code> in the
return slot, such that both <code class="highlight"><c- cp>#1</c-></code> and <code class="highlight"><c- cp>#2</c-></code> are a no-op. It is only <code class="highlight"><c- cp>#3</c-></code> that is
likely to invoke the relocation constructor.</p>
   <p>The relocation constructor may also be invoked by library functions, for example <a href="#std-reloc_and_uninitialize">§ 6.1.2 std::reloc_and_uninitialize and std::reloc_and_reclaim</a>.</p>
   <h4 class="heading settled" data-level="5.4.5" id="virtual-reloc-ctor"><span class="secno">5.4.5. </span><span class="content">Virtual relocation constructor</span><a class="self-link" href="#virtual-reloc-ctor"></a></h4>
   <p>As the relocation constructor is a second destructor, it can be declared as <code class="highlight"><c- k>virtual</c-></code>.
The virtual relocation constructor is useful when relocating from dynamic
storage, to prevent leaky object-slicing. Consider the following scenario:</p>
<pre class="language-c++ highlight"><c- n>class</c-> <c- n>D</c-> <c- o>:</c-> <c- n>public</c-> <c- n>B</c-> <c- p>{</c-> <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>_str</c-><c- p>;</c-> <c- p>};</c->

<c- n>B</c-><c- o>*</c-> <c- n>b</c-> <c- o>=</c-> <c- n>new</c-> <c- n>D</c-><c- p>;</c->

<c- n>B</c-> <c- n>sliced</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>reloc_and_reclaim</c-><c- p>(</c-><c- n>b</c-><c- p>);</c->
<c- c1>// reloc_and_reclaim relocates the given address to</c->
<c- c1>// its return value and deallocates the memory.</c->
</pre>
   <p>If <code class="highlight"><c- n>B</c-></code>’s relocation constructor is not virtual, then only the <code class="highlight"><c- n>B</c-></code> part of <code class="highlight"><c- o>*</c-><c- n>b</c-></code> will
be relocated, leaking the rest.</p>
   <p>User code cannot make a virtual call to the relocation constructor, only STL
functions can (like <a href="#std-reloc_and_uninitialize">std::reloc_and_uninitialize and std::reloc_and_reclaim</a>).
In other words, how to make a virtual function call to the relocation constructor
is implementation-defined.</p>
   <h5 class="heading settled" data-level="5.4.5.1" id="virtual-reloc-ctor-decl"><span class="secno">5.4.5.1. </span><span class="content">Declaration</span><a class="self-link" href="#virtual-reloc-ctor-decl"></a></h5>
   <p>A relocation constructor can be declared as virtual by adding the <code class="highlight"><c- k>virtual</c-></code> keyword before the declaration. In derived classes, the relocation constructor
signature must not change: the parameter type must still match the class-type:</p>
<pre class="language-c++ highlight"><c- k>struct</c-> <c- nc>B</c->
<c- p>{</c->
    <c- n>virtual</c-> <c- nf>B</c-><c- p>(</c-><c- n>B</c-><c- p>);</c->
<c- p>};</c->
<c- k>struct</c-> <c- nc>D</c-> <c- o>:</c-> <c- n>public</c-> <c- n>B</c->
<c- p>{</c->
    <c- n>D</c-><c- p>(</c-><c- n>D</c-><c- p>)</c-> <c- n>override</c-><c- p>;</c->
    <c- c1>// and not D(B)!</c->
<c- p>};</c->
</pre>
   <p>If a class-type <code class="highlight"><c- n>T</c-></code> derives from a class-type which declares a virtual relocation
constructor, and that the class-type <code class="highlight"><c- n>T</c-></code> has no user-declared relocation constructor,
then the class-type <code class="highlight"><c- n>T</c-></code> gets a public, defaulted implicitly-declared relocation
constructor.</p>
   <h5 class="heading settled" data-level="5.4.5.2" id="virtual-reloc-ctor-def"><span class="secno">5.4.5.2. </span><span class="content">Definition</span><a class="self-link" href="#virtual-reloc-ctor-def"></a></h5>
   <p>Let <code class="highlight"><c- n>T</c-></code> be a class-type with a virtual relocation constructor.
If <code class="highlight"><c- n>T</c-></code> relocation constructor has been called normally (not through a
virtual function call), then it proceeds normally as if non-virtual.</p>
   <p>Otherwise, the virtual relocation constructor must know
(they may be passed as extra parameters):</p>
   <ul>
    <li data-md>
     <p>the target type of the object to construct, which we will call <code class="highlight"><c- n>U</c-></code>. <code class="highlight"><c- n>U</c-></code> is by construction, either <code class="highlight"><c- n>T</c-></code> or a (maybe non-direct) base class of <code class="highlight"><c- n>T</c-></code> ;</p>
    <li data-md>
     <p>the address where it is to be constructed, which we will call <code class="highlight"><c- n>u</c-></code>.</p>
   </ul>
   <p>The virtual relocation constructor <code class="highlight"><c- n>T</c-><c- p>(</c-><c- n>T</c-> <c- n>src</c-><c- p>)</c-></code> then proceeds recursively as follows:</p>
   <ol>
    <li data-md>
     <p>If <code class="highlight"><c- n>U</c-></code> is the same as <code class="highlight"><c- n>T</c-></code>, then proceeds with the relocation constructor
as if non-virtual.</p>
    <li data-md>
     <p>If <code class="highlight"><c- n>U</c-></code> is a direct base of <code class="highlight"><c- n>T</c-></code>:</p>
     <ol>
      <li data-md>
       <p>If <code class="highlight"><c- n>U</c-></code> is a virtual base, then use move semantics to initialize <code class="highlight"><c- n>u</c-></code>: <code class="highlight"><c- k>new</c-> <c- p>(</c-><c- n>u</c-><c- p>)</c-> <c- n>U</c-><c- p>{</c-><c- k>static_cast</c-><c- o>&lt;</c-><c- n>U</c-><c- o>&amp;&amp;></c-><c- p>(</c-><c- n>src</c-><c- p>)};</c-></code> and return.</p>
      <li data-md>
       <p>Otherwise, decompose <code class="highlight"><c- n>src</c-></code> and initialize <code class="highlight"><c- n>u</c-></code>: <code class="highlight"><c- k>new</c-> <c- p>(</c-><c- n>u</c-><c- p>)</c-> <c- n>U</c-><c- p>{</c-><c- n>reloc</c-> <c- n>src</c-><c- o>::</c-><c- n>U</c-><c- p>};</c-></code> and return.</p>
      <li data-md>
       <p>When the constructor exits, the destructors of all non-relocated subobjects
of <code class="highlight"><c- n>src</c-></code> are implicitly invoked.</p>
     </ol>
    <li data-md>
     <p>Let <code class="highlight"><c- n>V</c-></code> be the direct base of <code class="highlight"><c- n>T</c-></code> which is on the inheritance path from <code class="highlight"><c- n>T</c-></code> to <code class="highlight"><c- n>U</c-></code>:</p>
     <ol>
      <li data-md>
       <p>If <code class="highlight"><c- n>V</c-></code> is a virtual base, then move-construct a local object <code class="highlight"><c- n>v</c-></code> (<code class="highlight"><c- n>V</c-> <c- n>v</c-><c- p>{</c-><c- k>static_cast</c-><c- o>&lt;</c-><c- n>V</c-><c- o>&amp;&amp;></c-><c- p>(</c-><c- n>src</c-><c- p>)};</c-></code>). Then make a virtual relocation
constructor call, passing <code class="highlight"><c- n>v</c-></code> as source object, and forwarding the target type <code class="highlight"><c- n>U</c-></code> and its target address <code class="highlight"><c- n>u</c-></code>. Return.</p>
      <li data-md>
       <p>Otherwise, decompose <code class="highlight"><c- n>src</c-></code> and call the virtual relocation constructor of <code class="highlight"><c- n>V</c-></code>,
passing the base class <code class="highlight"><c- n>V</c-></code> of <code class="highlight"><c- n>src</c-></code> as the source object
(as if by <code class="highlight"><c- n>reloc</c-> <c- n>src</c-><c- o>::</c-><c- n>V</c-></code>), and forwarding the target type <code class="highlight"><c- n>U</c-></code> and its target address <code class="highlight"><c- n>u</c-></code>. Return.</p>
      <li data-md>
       <p>When the constructor exits, the destructors of all non-relocated subobjects
of <code class="highlight"><c- n>src</c-></code> are implicitly invoked.</p>
     </ol>
   </ol>
   <p>As you can see when the virtual relocation constructor completes,
all the non-relocated subobjects of <code class="highlight"><c- n>src</c-></code> are destroyed normally, and the target
subobject is relocated at the desired location.</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> To detect how the relocation constructor is called,
implementations may emit two relocation constructor definitions, one virtual
and one non-virtual. User code can only call the non-virtual version, which
ensures the virtual one is only called through virtual function calls.</p>
   <h5 class="heading settled" data-level="5.4.5.3" id="virtual-reloc-ctor-def-ill-formed"><span class="secno">5.4.5.3. </span><span class="content">Ill-fomed definition</span><a class="self-link" href="#virtual-reloc-ctor-def-ill-formed"></a></h5>
   <p>A virtual relocation constructor definition of a class-type <code class="highlight"><c- n>T</c-></code> is ill-formed if:</p>
   <ul>
    <li data-md>
     <p>any of the direct base of <code class="highlight"><c- n>T</c-></code>, which declares (maybe implicitly) a virtual
relocation constructor, has a non-accessible relocation constructor ;</p>
    <li data-md>
     <p>or if any of the subobject of <code class="highlight"><c- n>T</c-></code> have an inaccessible destructor.</p>
   </ul>
   <h3 class="heading settled" data-level="5.5" id="reloc-assign-operator"><span class="secno">5.5. </span><span class="content">Relocation assignment operator</span><a class="self-link" href="#reloc-assign-operator"></a></h3>
   <p>We further introduce the relocation assignment operator. Its signature shall be: <code class="highlight"><c- n>T</c-><c- o>&amp;</c-> <c- n>T</c-><c- o>::</c-><c- k>operator</c-><c- o>=</c-><c- p>(</c-><c- n>T</c-><c- p>)</c-></code>. Such operators may already be defined in existing codebases,
but the proposed changes will not interfere with them.</p>
   <p>Sometimes we also make mentions to the <em>prvalue-assignment operator</em>.
It refers to the same function,
but further indicates that this function existed prior to the proposal.</p>
   <h4 class="heading settled" data-level="5.5.1" id="reloc-assign-declaration"><span class="secno">5.5.1. </span><span class="content">Declaration</span><a class="self-link" href="#reloc-assign-declaration"></a></h4>
   <p>The relocation assignment operator becomes a special member function. As such,
declaring one breaks the Rule of Zero, which was not the case previously.</p>
   <p>The relocation assignment operator may be implicitly declared, and may be
defaulted or deleted.</p>
   <h5 class="heading settled" data-level="5.5.1.1" id="reloc-assign-operator-implicit"><span class="secno">5.5.1.1. </span><span class="content">Implicit declaration</span><a class="self-link" href="#reloc-assign-operator-implicit"></a></h5>
   <p>If a class-type follows the Rule of Zero, then the compiler will declare
an inline public relocation assignment operator.</p>
   <h5 class="heading settled" data-level="5.5.1.2" id="reloc-assign-declaration-deleted"><span class="secno">5.5.1.2. </span><span class="content">Deleted implicitly-declared or defaulted relocation assignment operator</span><a class="self-link" href="#reloc-assign-declaration-deleted"></a></h5>
   <p>The implicitly-declared or defaulted relocation assignment operator for class <code class="highlight"><c- n>T</c-></code> is defined as deleted:</p>
   <ul>
    <li data-md>
     <p>if <code class="highlight"><c- n>T</c-></code> has subobjects that have an implicitly or explicitly deleted relocation assignment operator ;</p>
    <li data-md>
     <p>or <code class="highlight"><c- n>T</c-></code> has no relocation, move, or copy constructor ;</p>
    <li data-md>
     <p>or <code class="highlight"><c- n>T</c-></code> has subobjects that have inaccessible relocation or move assignment operators ;</p>
    <li data-md>
     <p>or <code class="highlight"><c- n>T</c-></code> has subobjects with deleted or unaccessible destructor.</p>
   </ul>
   <p>A defaulted relocation assignment operator that is deleted is ignored by overload
resolution.</p>
   <h4 class="heading settled" data-level="5.5.2" id="aliased-reloc-assign"><span class="secno">5.5.2. </span><span class="content">Relocation assignment operator parameter relocation elision</span><a class="self-link" href="#aliased-reloc-assign"></a></h4>
   <p>As with the relocation constructor, it is desirable that the parameter should be
the source object <em>converted to</em> a prvalue, and not a temporary prvalue relocated <em>from</em> the source object. This is particularly critical for
the default definition of the operator, which
(as you might suspect) performs memberwise calls to other relocation assignment operators.
Without elision, that would imply recursive relocation of each subobject, down to
their smallest unbreakable parts (incurring O(N<sup>2</sup>) byte copies, <em>N</em> being the size in
bytes of the source object).</p>
   <p>However, this poses a problem since it is possible to take the address of a
relocation assignment operator, yielding a pointer (or reference) with (typical)
signature <code class="highlight"><c- n>T</c-><c- o>&amp;</c-> <c- p>(</c-><c- n>T</c-><c- o>::</c-><c- p>)(</c-><c- n>T</c-><c- p>)</c-></code>, implying that the source object must occupy a parameter slot,
which may not find it possible to have the same storage address as the source object,
and/or which the caller may expect to destroy (see <a href="#abi">§ 7.1 Potential ABI changes</a>).</p>
   <p>Nevertheless, we mandate elision where possible:</p>
   <ul>
    <li data-md>
     <p>If the class-type (possibly implicitly) declares a non-deleted relocation constructor,
or declares a defaulted relocation assignment operator, then elision is
mandated at declaration level ;</p>
    <li data-md>
     <p>Otherwise, if the class-type defines a relocation assignment operator as
defaulted, then elision is mandated at definition level ;</p>
    <li data-md>
     <p>Otherwise elision is not mandated.</p>
   </ul>
   <p>Elision is performed in such a way as to avoid ABI break (more on that on the <a href="#prvalue-assign-op-abi">ABI
section</a>).</p>
   <h5 class="heading settled" data-level="5.5.2.1" id="aliased-reloc-assign-declaration"><span class="secno">5.5.2.1. </span><span class="content">Elision at declaration level</span><a class="self-link" href="#aliased-reloc-assign-declaration"></a></h5>
   <p>If elision is mandated at declaration level, then the assignment operator
declaration actually declares two member functions:</p>
   <ul>
    <li data-md>
     <p>the non-eliding one, which takes its input parameter by value.
This is the function that will get called when user-code calls the
assignment operator. It is the prvalue-assignment operator as we know it
today ;</p>
    <li data-md>
     <p>the eliding one, which takes its input parameter as if by reference, and has the
same return type as the non-eliding one. The eliding
function has no identifier and does not participate in overload resolution.
Users cannot take its address.
The eliding operator is forced to have callee-destroy ABI: the operator
is in charge of the lifetime of the source object.</p>
   </ul>
   <p>The definition of the assignment operator (which is user-provided or
defaulted) will serve as the definition of the eliding operator.</p>
   <p>The non-eliding operator definition is generated by the compiler, and merely wraps
the call to the eliding one:</p>
   <ul>
    <li data-md>
     <p>If the source object passed to the non-eliding operator is an <em>owned parameter</em>,
then the operator:</p>
     <ol>
      <li data-md>
       <p>Calls the eliding operator, passing the source object as if by reference.</p>
      <li data-md>
       <p>It forwards as return value whatever the eliding operator returns.</p>
     </ol>
    <li data-md>
     <p>Otherwise (the source object is an <em>unowned parameter</em>), then the operator:</p>
     <ol>
      <li data-md>
       <p>Creates a local copy of the source object, using move or copy constructor.</p>
      <li data-md>
       <p>Calls the eliding operator, passing that copy by reference.</p>
      <li data-md>
       <p>It forwards as return value whatever the eliding operator returns.</p>
      <li data-md>
       <p>It does not call the destructor of that local copy.</p>
     </ol>
   </ul>
   <p>If the address of the assignment operator is queried, then the address of the
non-eliding version is returned. If the assignment operator is virtual, then only
the non-eliding version is considered to be <code class="highlight"><c- k>virtual</c-></code> and is added to the vtable entry.</p>
   <h5 class="heading settled" data-level="5.5.2.2" id="aliased-reloc-assign-definition"><span class="secno">5.5.2.2. </span><span class="content">Elision at definition level</span><a class="self-link" href="#aliased-reloc-assign-definition"></a></h5>
   <p>If elision is mandated at definition level, then the two versions of the operator
are generated (eliding and non-eliding) in the translation unit where the operator
is defined. The visibility of the eliding operator symbol to other translation
units is <em>implementation-defined</em>.</p>
   <p>The eliding operator has an ABI where it takes its input parameter by reference,
and is in charge of the lifetime of the source object (callee-destroy).</p>
   <p>The definition of the two functions are the same as if elision was mandated at
declaration level.</p>
   <p>Typically, we expect code in the same translation unit to befenit from the
elided-version. Code outside the translation unit may also benefit from it
through link time optimizations.</p>
   <h4 class="heading settled" data-level="5.5.3" id="reloc-assign-definition"><span class="secno">5.5.3. </span><span class="content">Definition</span><a class="self-link" href="#reloc-assign-definition"></a></h4>
   <h5 class="heading settled" data-level="5.5.3.1" id="reloc-assign-default-definition"><span class="secno">5.5.3.1. </span><span class="content">Default definition</span><a class="self-link" href="#reloc-assign-default-definition"></a></h5>
   <p>As you would expect, the default definition merely delegates to the relocation
assignment operator of all its subobjects.</p>
   <p>In <code class="highlight"><c- n>T</c-></code>’s default assignment operator, the source object <code class="highlight"><c- n>src</c-></code> of type <code class="highlight"><c- n>T</c-></code> is
decomposed, and for all its subobjects <code class="highlight"><c- n>s</c-></code> of type <code class="highlight"><c- n>S</c-></code>:</p>
   <ul>
    <li data-md>
     <p>if <code class="highlight"><c- n>S</c-></code> is a virtual base, then <code class="highlight"><c- n>S</c-></code> is move-or-copy-assigned as if by: <code class="highlight"><c- k>static_cast</c-><c- o>&lt;</c-><c- n>S</c-><c- o>&amp;></c-><c- p>(</c-><c- o>*</c-><c- k>this</c-><c- p>)</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>src</c-><c- o>::</c-><c- n>S</c-><c- p>);</c-></code> ;</p>
    <li data-md>
     <p>otherwise we construct <code class="highlight"><c- n>s</c-></code> (or <code class="highlight"><c- n>S</c-></code>) by calling its own relocation, move or copy
assignment operator, as if by: <code class="highlight"><c- n>s</c-> <c- o>=</c-> <c- n>reloc</c-> <c- n>src</c-><c- o>::</c-><c- n>s</c-><c- p>;</c-></code> (or <code class="highlight"><c- k>static_cast</c-><c- o>&lt;</c-><c- n>S</c-><c- o>&amp;></c-><c- p>(</c-><c- o>*</c-><c- k>this</c-><c- p>)</c-> <c- o>=</c-> <c- n>reloc</c-> <c- n>src</c-><c- o>::</c-><c- n>S</c-><c- p>;</c-></code> for base classes);</p>
   </ul>
   <p>Thanks to the relocation-assignment operator special eliding,
no copies or relocations of the source subobjects are performed.</p>
   <h5 class="heading settled" data-level="5.5.3.2" id="reloc-assign-user-definition"><span class="secno">5.5.3.2. </span><span class="content">Possible user definitions</span><a class="self-link" href="#reloc-assign-user-definition"></a></h5>
   <p>User-provided operators can still perform memberwise relocation as it is
done with the defaulted version.</p>
   <p>Other definitions are possible, notably the famous <em>copy-and-swap</em> (now <em>relocate-and-swap</em>) and the <em>destroy-and-construct</em> idioms.</p>
   <p>Note that the most optimal implementation will result in a single destructor
call and a single memcpy call (given that the class-type is trivially
relocatable).</p>
   <p><strong>Memberwise relocation</strong></p>
<pre class="language-c++ highlight"><c- n>T</c-><c- o>&amp;</c-> <c- n>T</c-><c- o>::</c-><c- n>operator</c-><c- o>=</c-><c- p>(</c-><c- n>T</c-> <c- n>src</c-> <c- n>reloc</c-><c- p>)</c->
<c- p>{</c->
    <c- n>static_cast</c-><c- o>&lt;</c-><c- n>B</c-><c- o>&amp;></c-><c- p>(</c-><c- o>*</c-><c- n>this</c-><c- p>)</c-> <c- o>=</c-> <c- n>reloc</c-> <c- n>src</c-><c- o>::</c-><c- n>B</c-><c- p>;</c-> <c- c1>// relocate base</c->
    <c- n>this</c-><c- o>-></c-><c- n>_a</c-> <c- o>=</c-> <c- n>reloc</c-> <c- n>src</c-><c- o>::</c-><c- n>_a</c-><c- p>;</c->
    <c- k>return</c-> <c- o>*</c-><c- n>this</c-><c- p>;</c->
<c- p>}</c->
</pre>
   <p>This implementation is the best possible given that memberwise relocation
matches the need of the class-type. It has a strong exception safety
and has optimal performance (memberwise, one resource clean-up and one memcpy).</p>
   <p><strong>destroy-and-construct</strong></p>
<pre class="language-c++ highlight"><c- n>T</c-><c- o>&amp;</c-> <c- n>T</c-><c- o>::</c-><c- n>operator</c-><c- o>=</c-><c- p>(</c-><c- n>T</c-> <c- n>src</c-><c- p>)</c-> <c- n>noexcept</c->
<c- p>{</c->
    <c- n>std</c-><c- o>::</c-><c- n>destroy_at</c-><c- p>(</c-><c- n>this</c-><c- p>);</c->
    <c- k>return</c-> <c- o>*</c-><c- n>std</c-><c- o>::</c-><c- n>construct_at</c-><c- p>(</c-><c- n>this</c-><c- p>,</c-> <c- n>reloc</c-> <c- n>src</c-><c- p>);</c->
<c- p>}</c->
</pre>
   <p>Or an exception-safe version, necessary if the destructor or the relocation
constructor throws:</p>
<pre class="language-c++ highlight"><c- n>T</c-><c- o>&amp;</c-> <c- n>T</c-><c- o>::</c-><c- n>operator</c-><c- o>=</c-><c- p>(</c-><c- n>T</c-> <c- n>src</c-><c- p>)</c-> <c- n>requires</c-> <c- n>std</c-><c- o>::</c-><c- n>is_default_constructible_v</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c->
<c- p>{</c->
    <c- n>std</c-><c- o>::</c-><c- n>experimental</c-><c- o>::</c-><c- n>scope_fail</c-> <c- n>_</c-><c- p>{[</c-><c- n>this</c-><c- p>]</c-> <c- p>{</c-> <c- n>new</c-> <c- p>(</c-><c- n>this</c-><c- p>)</c-> <c- n>T</c-><c- p>;</c-> <c- p>}};</c->
    <c- n>std</c-><c- o>::</c-><c- n>destroy_at</c-><c- p>(</c-><c- n>this</c-><c- p>);</c->
    <c- k>return</c-> <c- o>*</c-><c- n>std</c-><c- o>::</c-><c- n>construct_at</c-><c- p>(</c-><c- n>this</c-><c- p>,</c-> <c- n>reloc</c-> <c- n>src</c-><c- p>);</c->
<c- p>}</c->
</pre>
   <p>This idiom is as optiomal as we could hope for, merely destructing the object
and reconstructing it thanks to the relocation constructor.</p>
   <p>Exception safety is a bit tricky and requires
to be able to reconstruct a valid instance of the object from scratch, should
an exception be thrown. Of course, this is not possible in the general case as
not all classes are default-constructible.</p>
   <p>Note that if <code class="highlight"><c- n>T</c-></code> is trivially
relocatable, then the operator is as optimal as we would like, as it merely
translates into a destructor call and a memcpy call.</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> If the assignment operator needs no further logic than a simple memberwise
assignment, then users should instead use the defaulted version of the operator
as it will provide better exception safety for similar performance.</p>
   <p><strong>relocate-and-swap</strong></p>
<pre class="language-c++ highlight"><c- n>T</c-><c- o>&amp;</c-> <c- n>T</c-><c- o>::</c-><c- n>operator</c-><c- o>=</c-><c- p>(</c-><c- n>T</c-> <c- n>src</c-><c- p>)</c->
<c- p>{</c->
    <c- n>using</c-> <c- n>std</c-><c- o>::</c-><c- n>swap</c-><c- p>;</c->
    <c- n>swap</c-><c- p>(</c-><c- o>*</c-><c- n>this</c-><c- p>,</c-> <c- n>src</c-><c- p>);</c->
    <c- k>return</c-> <c- o>*</c-><c- n>this</c-><c- p>;</c->
<c- p>}</c->
</pre>
   <p>This version is exception-safe, although it may not be the most efficient approach.</p>
   <p>Should <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>swap</c-></code> be optimized to perform memcpy on trivially relocatable
objects, then it results in one destructor call (<code class="highlight"><c- n>src</c-></code>’s) and three memcpy calls.</p>
   <p><strong>Union trick</strong></p>
   <p>If for some reason, the implementation needs to prevent the destructor call
on the source object, it is still possible to perform the "union trick":</p>
<pre class="language-c++ highlight"><c- n>T</c-><c- o>&amp;</c-> <c- n>operator</c-><c- o>=</c-><c- p>(</c-><c- n>T</c-> <c- n>src</c-><c- p>)</c->
<c- p>{</c->
    <c- k>union</c-> <c- p>{</c-> <c- n>T</c-> <c- n>tmp</c-> <c- p>}</c-> <c- o>=</c-> <c- p>{</c-> <c- p>.</c-><c- n>tmp</c-> <c- o>=</c-> <c- n>reloc</c-> <c- n>src</c-><c- p>;</c-> <c- p>};</c->
    <c- d>/* do some stuff with tmp (like calling std::reloc_and_uninitialize),</c->
<c- d>     * knowing its destructor will not be called by the language */</c->
    <c- k>return</c-> <c- o>*</c-><c- n>this</c-><c- p>;</c->
<c- p>}</c->
</pre>
   <h4 class="heading settled" data-level="5.5.4" id="reloc-assign-invoke"><span class="secno">5.5.4. </span><span class="content">Invocation</span><a class="self-link" href="#reloc-assign-invoke"></a></h4>
<pre class="language-c++ highlight"><c- n>T</c-> <c- n>x</c-><c- p>,</c-> <c- n>y</c-><c- p>;</c->
<c- n>x</c-> <c- o>=</c-> <c- n>reloc</c-> <c- n>y</c-><c- p>;</c->
</pre>
   <p>Every call to the relocation assignment operator follows normal rules.</p>
   <p>If the call site detects that an eliding version of the operator is available
(either because the eliding happened at declaration level, or because it
happened at definition level and the call site is in the same
translation unit as the definition, or through link-time optimization),
then which version of the operator
is called is implementation-defined.</p>
   <p>The nominal case is to call the non-eliding version. The implementation is allowed
to call the eliding version instead, as long as it can elide the call to the
destructor on the source object.</p>
   <h3 class="heading settled" data-level="5.6" id="overload-resolution"><span class="secno">5.6. </span><span class="content">Overload resolution</span><a class="self-link" href="#overload-resolution"></a></h3>
   <p>The current overload resolution rules are not suitable for relocation by prvalue.</p>
   <p>Indeed, consider the following scenario:</p>
<pre class="language-c++ highlight"><c- b>void</c-> <c- nf>bar</c-><c- p>(</c-><c- n>T</c-><c- o>&amp;&amp;</c-><c- p>);</c-> <c- c1>// same issue with: bar(T const&amp;);</c->
<c- b>void</c-> <c- nf>bar</c-><c- p>(</c-><c- n>T</c-><c- p>);</c->

<c- b>void</c-> <c- nf>foo</c-><c- p>(</c-><c- n>T</c-> <c- n>val</c-><c- p>)</c->
<c- p>{</c->
    <c- n>bar</c-><c- p>(</c-><c- n>reloc</c-> <c- n>val</c-><c- p>);</c-> <c- d>/* ambiguous call using today’s rules */</c->
<c- p>}</c->
</pre>
   <p>Hence we propose a change in the overload resolution rules to prefer passing by
value for prvalue arguments.</p>
   <p>Specifically, we would amend <a href="https://eel.is/c++draft/over.ics.rank#3.2.3">[over.ics.rank]/3.2.3</a> to read:</p>
   <ul>
    <li data-md>
     <p>neither of S1 and S2 bind a reference to an implicit object parameter of a
non-static member function declared without a ref-qualifier, and either:</p>
     <ul>
      <li data-md>
       <p>S1 binds an lvalue reference to an lvalue, and S2 does not, or:</p>
      <li data-md>
       <p>S1 binds an rvalue reference to an xvalue, and S2 does not, or:</p>
      <li data-md>
       <p>S1 does not bind a reference, and S2 binds a reference to a prvalue, or:</p>
      <li data-md>
       <p>S1 binds an rvalue reference to a prvalue, and S2 binds an lvalue reference [Example:</p>
<pre class="language-c++ highlight"><c- b>int</c-> <c- n>i</c-><c- p>;</c->
<c- b>int</c-> <c- nf>f1</c-><c- p>();</c->
<c- b>int</c-><c- o>&amp;&amp;</c-> <c- nf>f2</c-><c- p>();</c->
<c- p>...</c->
<c- b>int</c-> <c- n>g2</c-><c- p>(</c-><c- k>const</c-> <c- b>int</c-><c- o>&amp;</c-><c- p>);</c->
<c- b>int</c-> <c- nf>g2</c-><c- p>(</c-><c- b>int</c-><c- p>);</c->
<c- b>int</c-> <c- nf>g2</c-><c- p>(</c-><c- b>int</c-><c- o>&amp;&amp;</c-><c- p>);</c->
<c- b>int</c-> <c- n>j2</c-> <c- o>=</c-> <c- n>g2</c-><c- p>(</c-><c- n>i</c-><c- p>);</c-> <c- c1>// calls g2(const int&amp;)</c->
<c- b>int</c-> <c- n>k2</c-> <c- o>=</c-> <c- n>g2</c-><c- p>(</c-><c- n>f1</c-><c- p>());</c-> <c- c1>// calls g2(int)</c->
<c- b>int</c-> <c- n>l2</c-> <c- o>=</c-> <c- n>g2</c-><c- p>(</c-><c- n>f2</c-><c- p>());</c-> <c- c1>// calls g2(int&amp;&amp;)</c->
<c- p>...</c->
</pre>
       <p>- end example]</p>
     </ul>
   </ul>
   <h4 class="heading settled" data-level="5.6.1" id="overload-against-P2665R0"><span class="secno">5.6.1. </span><span class="content">Comparison against P2665R0</span><a class="self-link" href="#overload-against-P2665R0"></a></h4>
   <p><a data-link-type="biblio" href="#biblio-p2665r0" title="Allow calling overload sets containing T, const T&amp;">[P2665R0]</a> "Allow calling overload sets containing T, const T&amp;" also proposes
to modify the overload resolution rules. It allows overload sets containing
both <code class="highlight"><c- n>T</c-></code> and <code class="highlight"><c- n>T</c-> <c- k>const</c-><c- o>&amp;</c-></code> to exist, and which overload is selected is
implementation-defined. The main motivation is for performance: "small" trivial
types, such as built-in integral types, are best passed by value than by
reference.</p>
   <p>In what we propose, overload sets with <code class="highlight"><c- n>T</c-></code>, <code class="highlight"><c- n>T</c-> <c- k>const</c-><c- o>&amp;</c-></code> and <code class="highlight"><c- n>T</c-><c- o>&amp;&amp;</c-></code> can also exist.
However, which is picked is (almost always, unowned parameters left aside)
specified clearly by the standard
(depending on the value category of the parameter) and
not <em>implementation-defined</em>.</p>
   <p>The <code class="highlight"><c- n>reloc</c-></code> operator can be used to turn not-ref-qualified
automatic variables into prvalues, which allows the user to force the right
overload.</p>
   <p>The only situation where the overload being selected is implementation-defined,
is when a function parameter passed by value is being relocated. Whether the
relocation constructor is considered in the overload resolution is
implementation-defined, as it depends on the ABI capabilities. Consider:</p>
<pre class="language-c++ highlight"><c- b>void</c-> <c- nf>foo</c-><c- p>(</c-><c- n>T</c-><c- p>);</c->
<c- b>void</c-> <c- nf>foo</c-><c- p>(</c-><c- n>T</c-><c- o>&amp;&amp;</c-><c- p>);</c->

<c- b>void</c-> <c- nf>bar</c-><c- p>(</c-><c- n>T</c-> <c- n>value</c-><c- p>)</c->
<c- p>{</c->
    <c- n>foo</c-><c- p>(</c-><c- n>reloc</c-> <c- n>value</c-><c- p>);</c-> <c- d>/* always calls foo(T),</c->
<c- d>        but how foo’s parameter is constructed</c->
<c- d>        is implementation-defined (reloc, move or copy ctor) */</c->
<c- p>}</c->
</pre>
   <p>In this example, <code class="highlight"><c- n>bar</c-></code> will always call the <code class="highlight"><c- n>foo</c-><c- p>(</c-><c- n>T</c-><c- p>)</c-></code> overload, as <code class="highlight"><c- n>reloc</c-> <c- n>value</c-></code> is always a prvalue. However, the materialization of this prvalue is
implementation-defined, the relocation constructor being potentially
evicted.</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> This proposal and P2665R0 can co-exist. Even with the updated overload
resolution rules that we propose, compilers may still be allowed to pick the
prvalue overload if they analyse it may bring a performance boost, as P2665R0
suggests.</p>
   <h3 class="heading settled" data-level="5.7" id="structured-decomposition"><span class="secno">5.7. </span><span class="content">Structured decomposition</span><a class="self-link" href="#structured-decomposition"></a></h3>
   <h4 class="heading settled" data-level="5.7.1" id="structured-decomposition-discussion"><span class="secno">5.7.1. </span><span class="content">Discussion</span><a class="self-link" href="#structured-decomposition-discussion"></a></h4>
   <p><code class="highlight"><c- k>auto</c-> <c- p>[</c-><c- n>x</c-><c- p>,</c-> <c- n>y</c-><c- p>]</c-> <c- o>=</c-> <c- n>foo</c-><c- p>();</c-> <c- n>sink</c-><c- p>(</c-><c- n>reloc</c-> <c- n>y</c-><c- p>);</c-></code> is ill-formed given the rules we
established for <code class="highlight"><c- n>reloc</c-></code>. <code class="highlight"><c- n>x</c-></code> and <code class="highlight"><c- n>y</c-></code> are not complete objects but aliases to
some anonymous object which the language creates behind the scene.</p>
   <p>As this proposal aims to provide support for relocate-only types, this support
would be partial, if not impractical, without allowing some form of
relocation from a structured binding.</p>
   <p>In our experience, most C++ developers believe that a structured binding is
a complete, separate object, and not a name alias to some subobject. As such
it would feel unnatural for them if they cannot relocate from a structured binding.</p>
   <p>We propose "structured decomposition" as an alternative to structured bindings.
Instead of binding the subobjects of the initializer (<code class="highlight"><c- n>foo</c-><c- p>()</c-></code> in the example)
to the new identifiers, the initializer is <em>decomposed</em> into the new identifiers.
The new identifiers, being individual complete objects, can then be relocated.</p>
   <h4 class="heading settled" data-level="5.7.2" id="structured-decomposition-declaration"><span class="secno">5.7.2. </span><span class="content">Structured decomposition declaration</span><a class="self-link" href="#structured-decomposition-declaration"></a></h4>
   <p>A structured decomposition declaration is syntactically identical to a structured
binding, with the exception that no ref-qualifiers are allowed after the <code class="highlight"><c- k>auto</c-></code> type specifier.</p>
<pre class="language-c++ highlight"><c- n>T</c-> <c- nf>foo</c-><c- p>();</c->
<c- n>T</c-> <c- k>const</c-><c- o>&amp;</c-> <c- n>bar</c-><c- p>();</c->
<c- n>T</c-> <c- nf>foobar</c-><c- p>();</c->

<c- c1>// [...]</c->

<c- k>auto</c-> <c- p>[</c-><c- n>x</c-><c- p>,</c-> <c- n>y</c-><c- p>]</c-> <c- o>=</c-> <c- n>foo</c-><c- p>();</c-> <c- c1>// matches structured decomposition declaration</c->
<c- k>auto</c-> <c- k>const</c-> <c- p>[</c-><c- n>w</c-><c- p>,</c-> <c- n>z</c-><c- p>]</c-> <c- o>=</c-> <c- n>bar</c-><c- p>();</c-> <c- c1>// matches structured decomposition declaration</c->
<c- k>auto</c-><c- o>&amp;&amp;</c-> <c- p>[</c-><c- n>a</c-><c- p>,</c-> <c- n>b</c-><c- p>]</c-> <c- o>=</c-> <c- n>foobar</c-><c- p>();</c-> <c- c1>// structured bindings will be used</c->
</pre>
   <p>The structured decomposition declaration further requires that the type of the
expression that is used to initialize it
supports any of the <a href="#structured-decomposition-obj-decomposition">structured decomposition protocol</a>. <strong>If not, then the declaration is simply a structured bindings declaration and will
follow structured bindings rules.</strong></p>
   <h4 class="heading settled" data-level="5.7.3" id="structured-decomposition-obj-decomposition"><span class="secno">5.7.3. </span><span class="content">Structured decomposition protocols</span><a class="self-link" href="#structured-decomposition-obj-decomposition"></a></h4>
   <p>As there are three binding protocols for structured bindings, there are likewise
three "structured decomposition" protocols. If none
of those protocols match, then the declaration is not a
structured decomposition declaration, and structured bindings are considered.</p>
   <p>The protocols are tested in the following order:</p>
   <ol>
    <li data-md>
     <p>The <em>array</em> protocol ;</p>
    <li data-md>
     <p>The <em>get_all</em> protocol ;</p>
    <li data-md>
     <p>The <em>data members</em> protocol ;</p>
   </ol>
   <p>In what follows, let <code class="highlight"><c- n>E</c-></code> be the type of the initializer expression (the type
of the expression used to initialize the structured decomposition).</p>
   <ul>
    <li data-md>
     <p>If <code class="highlight"><c- n>E</c-></code> is a glvalue, then let <code class="highlight"><c- n>S</c-></code> be the same as <code class="highlight"><c- n>E</c-></code>, but deprived of its
ref-qualifiers.
If one of the three protocols applies, then an anonymous object of type <code class="highlight"><c- n>S</c-></code> is
constructed from the initializer, using the appropriate constructor.
This anonymous object will be considered as the prvalue source object ;</p>
    <li data-md>
     <p>Otherwise (<code class="highlight"><c- n>E</c-></code> is a prvalue), then let <code class="highlight"><c- n>S</c-></code> be the same as <code class="highlight"><c- n>E</c-></code>. The initializer
expression will be used as source object.</p>
   </ul>
   <h5 class="heading settled" data-level="5.7.3.1" id="structured-decomposition-array"><span class="secno">5.7.3.1. </span><span class="content">array protocol</span><a class="self-link" href="#structured-decomposition-array"></a></h5>
   <p>The <em>array</em> protocol is quite similar to that of structured bindings.
For this protocol to apply, all the following conditions must be satisfied:</p>
   <ul>
    <li data-md>
     <p><code class="highlight"><c- n>S</c-></code> must be an array-type of known bound ;</p>
    <li data-md>
     <p>the number of identifiers must equal the number of array elements ;</p>
   </ul>
   <p>If this protocol applies, then the <em>i</em>-th identifier is constructed by
relocation, move or copy constructor using the <em>i</em>-th array element as source object.</p>
<pre class="language-c++ highlight"><c- b>void</c-> <c- nf>foo</c-><c- p>()</c->
<c- p>{</c->
    <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- k>const</c-> <c- n>strs</c-><c- p>[</c-><c- mi>3</c-><c- p>]</c-> <c- o>=</c-> <c- p>{</c-> <c- d>/* ... */</c-> <c- p>};</c->
    <c- c1>// [...]</c->
    <c- k>auto</c-> <c- k>const</c-> <c- p>[</c-><c- n>str1</c-><c- p>,</c-> <c- n>str2</c-><c- p>,</c-> <c- n>str3</c-><c- p>]</c-> <c- o>=</c-> <c- n>reloc</c-> <c- n>strs</c-><c- p>;</c->
    <c- n>bar</c-><c- p>(</c-><c- n>reloc</c-> <c- n>str2</c-><c- p>);</c->
<c- p>}</c->
</pre>
   <h5 class="heading settled" data-level="5.7.3.2" id="structured-decomposition-get_all"><span class="secno">5.7.3.2. </span><span class="content">get_all protocol</span><a class="self-link" href="#structured-decomposition-get_all"></a></h5>
   <p>The function <code class="highlight"><c- n>get_all</c-><c- p>(</c-><c- n>S</c-><c- p>)</c-></code> is looked-up using ADL-lookup. If there is
no match, then this protocol does not apply.</p>
   <p>If there is a match, then this function is called (copy-elision will happen, <code class="highlight"><c- n>S</c-></code> prvalue will share the same address as <code class="highlight"><c- n>get_all</c-></code> parameter slot).
The returned type is tested recursively:</p>
   <ol>
    <li data-md>
     <p>If <em>get_all</em> matches for the returned type, then we reapply it again ;</p>
    <li data-md>
     <p>If <em>data members</em> protocol matches for the
returned type, then it is applied ;</p>
    <li data-md>
     <p>If no protocol matches for the returned type, then the expression is <strong>ill-formed</strong> (structured bindings is not tried).</p>
   </ol>
   <p>This follows the same recursive logic as <code class="highlight"><c- k>operator</c-><c- o>-></c-><c- p>()</c-></code>.
We recursively call <code class="highlight"><c- n>get_all</c-></code> as long as the <em>get_all</em> protocol applies.
When the recursion ends, we end up with a type which
matches the <em>data member</em> protocol, or else the expression is ill-formed.</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> If there are concerns that <code class="highlight"><c- n>get_all</c-><c- p>(</c-><c- n>S</c-><c- p>)</c-></code> may clash with existing functions,
then other names may be used, such as <code class="highlight"><c- n>__get_all__</c-></code> or <code class="highlight"><c- n>__decompose__</c-></code>.</p>
   <h5 class="heading settled" data-level="5.7.3.3" id="structured-decomposition-dm"><span class="secno">5.7.3.3. </span><span class="content">data members protocol</span><a class="self-link" href="#structured-decomposition-dm"></a></h5>
   <p>The <em>data members</em> protocol is also similar to that of structured bindings.
For this protocol to apply, all the following conditions must be satisfied:</p>
   <ul>
    <li data-md>
     <p>every non-static data member of <code class="highlight"><c- n>S</c-></code> must be a direct member of <code class="highlight"><c- n>S</c-></code> or of the same
base class of <code class="highlight"><c- n>S</c-></code> ;</p>
    <li data-md>
     <p>the number of identifiers must equal the number of non-static data members ;</p>
    <li data-md>
     <p><code class="highlight"><c- n>S</c-></code> may not have an anonymous union member ;</p>
    <li data-md>
     <p><em>specific to structured decomposition:</em> for every base class, between <code class="highlight"><c- n>S</c-></code> and the base
class the data members are found in, its decomposition is <a href="#ill-formed-decomposition">well-formed</a>.</p>
   </ul>
   <p>If this protocol applies, then the <em>i</em>-th identifier is constructed as if by <code class="highlight"><c- n>reloc</c-> <c- n>s</c-><c- o>::</c-><c- n>i</c-></code>, <code class="highlight"><c- n>s</c-></code> being the decomposed base class holding all the data members
and <code class="highlight"><c- n>i</c-></code> the <em>i</em>-th identifier.</p>
   <h5 class="heading settled" data-level="5.7.3.4" id="structured-decomposition-tuple"><span class="secno">5.7.3.4. </span><span class="content">Implementation-defined library support</span><a class="self-link" href="#structured-decomposition-tuple"></a></h5>
   <p><code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>pair</c-></code>, <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>tuple</c-></code>, and <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>array</c-></code> shall provide their own implementation
of <code class="highlight"><c- n>get_all</c-></code>. The return type is implementation-defined (may rely on compiler magic).</p>
   <p>This allows us to write things like:</p>
<pre class="language-c++ highlight"><c- b>void</c-> <c- nf>bar</c-><c- p>(</c-><c- n>T</c-><c- p>);</c->
<c- b>void</c-> <c- nf>foo</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>T</c-><c- o>>&amp;</c-> <c- n>v</c-><c- p>)</c->
<c- p>{</c->
    <c- d>/* This code uses a putative vector::pilfer(const_iterator) (not proposed),</c->
<c- d>     * which removes a vector element at given iterator, and</c->
<c- d>     * returns a pair with next valid iterator and relocated vector element. */</c->
    <c- k>auto</c-> <c- p>[</c-><c- n>val</c-><c- p>,</c-> <c- n>it</c-><c- p>]</c-> <c- o>=</c-> <c- n>v</c-><c- p>.</c-><c- n>pilfer</c-><c- p>(</c-><c- n>v</c-><c- p>.</c-><c- n>begin</c-><c- p>()</c-> <c- o>+</c-> <c- mi>1</c-><c- p>);</c-> <c- d>/* calls get_all behind</c->
<c- d>        the scene. */</c->
    <c- n>bar</c-><c- p>(</c-><c- n>reloc</c-> <c- n>val</c-><c- p>);</c-> <c- d>/* can call reloc on val as it is not a structured binding */</c->
<c- p>}</c->
</pre>
   <p>This code works even if <code class="highlight"><c- n>T</c-></code> is relocate-only.</p>
   <h5 class="heading settled" data-level="5.7.3.5" id="structured-decomposition-implem"><span class="secno">5.7.3.5. </span><span class="content">Possible get_all implementations</span><a class="self-link" href="#structured-decomposition-implem"></a></h5>
   <p>Thanks to <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>tuple</c-></code>’s <code class="highlight"><c- n>get_all</c-></code> we can easily write
a <code class="highlight"><c- n>get_all</c-></code> implementation for a custom class:</p>
<pre class="language-c++ highlight"><c- n>class</c-> <c- n>MyType</c->
<c- p>{</c->
<c- n>public</c-><c- o>:</c->
    <c- n>MyType</c-><c- p>();</c->
    <c- n>MyType</c-><c- p>(</c-><c- n>MyType</c-><c- p>);</c->

    <c- c1>// Possible implementation:</c->
    <c- k>auto</c-> <c- n>get_all</c-><c- p>(</c-><c- n>this</c-> <c- n>MyType</c-> <c- n>self</c-> <c- n>reloc</c-><c- p>)</c->
    <c- p>{</c->
        <c- k>return</c-> <c- n>std</c-><c- o>::</c-><c- n>tuple</c-><c- p>{</c-><c- n>reloc</c-> <c- n>self</c-><c- o>::</c-><c- n>_name</c-><c- p>,</c-> <c- n>self</c-><c- o>::</c-><c- n>_flag</c-><c- p>,</c->
            <c- o>!</c-><c- n>self</c-><c- o>::</c-><c- n>_nodes</c-><c- p>.</c-><c- n>empty</c-><c- p>()};</c->
    <c- p>}</c->

<c- n>private</c-><c- o>:</c->
    <c- n>std</c-><c- o>::</c-><c- n>string</c-> <c- n>_name</c-><c- p>;</c->
    <c- b>bool</c-> <c- n>_flag</c-><c- p>;</c->
    <c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>Node</c-><c- o>*></c-> <c- n>_nodes</c-><c- p>;</c->

<c- p>};</c->
</pre>
   <p>The implementation relies on a putative new constructor for <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>tuple</c-></code> (not proposed) which captures the tuple elements by value category,
which allows to relocate objects into a tuple.</p>
   <p>Then, in the following snippet:</p>
<pre class="language-c++ highlight"><c- n>MyType</c-> <c- n>tp</c-><c- p>;</c->
<c- k>auto</c-> <c- p>[</c-><c- n>name</c-><c- p>,</c-> <c- n>flag</c-><c- p>,</c-> <c- n>nodes</c-><c- p>]</c-> <c- o>=</c-> <c- n>reloc</c-> <c- n>tp</c-><c- p>;</c->
<c- c1>// equivalent to: auto [name, flag, nodes] = get_all(get_all(reloc tp));</c->
</pre>
   <p><code class="highlight"><c- n>MyType</c-></code>’s <code class="highlight"><c- n>get_all</c-></code> returns a tuple. <code class="highlight"><c- n>get_all</c-></code> is defined for tuples as well, so
it is called again. The second return type won’t have a <code class="highlight"><c- n>get_all</c-></code> defined, hence
the recursion stops and the <em>data member</em> protocol is used.</p>
   <h2 class="heading settled" data-level="6" id="proposed-lib-changes"><span class="secno">6. </span><span class="content">Proposed library changes</span><a class="self-link" href="#proposed-lib-changes"></a></h2>
   <p class="note" role="note"><span class="marker">NOTE:</span> Adding support for relocation in the STL is another major change.
What we are proposing to add for the moment is the bare minimum to allow
library writers to benefit from relocation. Support for relocation in the STL
will be done in a separate proposal, depending on whether the work on this
proposal is pursued.</p>
   <h3 class="heading settled" data-level="6.1" id="std-mem-header"><span class="secno">6.1. </span><span class="content">Memory header</span><a class="self-link" href="#std-mem-header"></a></h3>
   <h4 class="heading settled" data-level="6.1.1" id="std-construct_at"><span class="secno">6.1.1. </span><span class="content">std::construct_at</span><a class="self-link" href="#std-construct_at"></a></h4>
   <p>We propose to add the following overload to <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>construct_at</c-></code>:</p>
<pre class="language-c++ highlight"><c- n>template</c-><c- o>&lt;</c-><c- n>class</c-> <c- n>T</c-><c- o>></c->
<c- n>constexpr</c-> <c- n>T</c-><c- o>*</c-> <c- n>construct_at</c-><c- p>(</c-> <c- n>T</c-><c- o>*</c-> <c- n>p</c-><c- p>,</c-> <c- n>T</c-> <c- n>src</c-> <c- p>);</c->
</pre>
   <p>Which would be equivalent to <code class="highlight"><c- o>::</c-><c- k>new</c-> <c- p>(</c-><c- n>p</c-><c- p>)</c-> <c- n>T</c-><c- p>{</c-><c- n>reloc</c-> <c- n>src</c-><c- p>}</c-></code>, except that it may be
used in constant expression evaluations.</p>
   <p class="note" role="note"><span class="marker">Note:</span> this overload would be unnecessary if the <a href="#future-capture-value">§ 7.4.1 More perfect forwarding</a> direction were to be adopted; instead the existing signature should be
altered to use the <code class="highlight"><c- k>decltype</c-><c- p>(</c-><c- n>Args</c-><c- p>)...</c-></code> placeholder.</p>
   <h4 class="heading settled" data-level="6.1.2" id="std-reloc_and_uninitialize"><span class="secno">6.1.2. </span><span class="content">std::reloc_and_uninitialize and std::reloc_and_reclaim</span><a class="self-link" href="#std-reloc_and_uninitialize"></a></h4>
   <p>We propose to add the following functions in the <code class="highlight"><c- n>std</c-></code> namespace in the <code class="highlight"><c- n>memory</c-></code> header to perform relocation through a pointer:</p>
<pre class="language-c++ highlight"><c- n>template</c-> <c- o>&lt;</c-><c- n>class</c-> <c- n>T</c-><c- o>></c->
<c- n>std</c-><c- o>::</c-><c- n>remove_cv_t</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-> <c- n>reloc_and_uninitialize</c-><c- p>(</c-><c- n>T</c-><c- o>*</c-> <c- n>src</c-><c- p>);</c->
<c- n>template</c-> <c- o>&lt;</c-><c- n>class</c-> <c- n>T</c-><c- o>></c->
<c- n>std</c-><c- o>::</c-><c- n>remove_cv_t</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-> <c- n>reloc_and_reclaim</c-><c- p>(</c-><c- n>T</c-><c- o>*</c-> <c- n>src</c-><c- p>);</c->
</pre>
   <p>Both functions construct a new object by calling either the relocation constructor,
the move constructor or the copy constructor,
using <code class="highlight"><c- o>*</c-><c- n>src</c-></code> as parameter while ignoring its cv-qualifiers, and return it.
They also ensure the end-of-life of the source object: if the move or copy
constructor is called then the destructor of <code class="highlight"><c- o>*</c-><c- n>src</c-></code> is called afterwards.</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> If <code class="highlight"><c- o>*</c-><c- n>src</c-></code> is a polymorphic type, that the relocation constructor is selected in
the overload resolution,
and the relocation constructor is virtual,
then a virtual relocation constructor call is performed from the dynamic type of <code class="highlight"><c- o>*</c-><c- n>src</c-></code>.</p>
   <p><code class="highlight"><c- n>reloc_and_uninitialize</c-></code> leaves the memory that was occupied by <code class="highlight"><c- n>src</c-></code> in an
uninitialized state.  If any exception is thrown,
then <code class="highlight"><c- n>reloc_and_uninitialize</c-></code> is guaranteed to leave the source object in a
destructed state.</p>
   <p><code class="highlight"><c- n>reloc_and_reclaim</c-></code> reclaims the memory by calling the appropriate deallocation
function (class-defined <code class="highlight"><c- k>delete</c-></code> or global <code class="highlight"><c- k>delete</c-></code>). If any exception is thrown,
then <code class="highlight"><c- n>reloc_and_reclaim</c-></code> is guaranteed to leave the source object in a destructed
state and to have deallocated its memory.</p>
   <p><code class="highlight"><c- n>reloc_and_uninitialize</c-></code> is intended to be used by library authors to enable relocation
from a memory address. For instance, extracting a value out of an optional just
becomes:</p>
<pre class="language-c++ highlight"><c- n>T</c-> <c- n>optional</c-><c- o>&lt;</c-><c- n>T</c-><c- o>>::</c-><c- n>extract</c-><c- p>()</c->
<c- p>{</c->
    <c- n>_has_value</c-> <c- o>=</c-> false<c- p>;</c->
    <c- k>return</c-> <c- n>std</c-><c- o>::</c-><c- n>reloc_and_uninitialize</c-><c- p>(</c-><c- n>_value_addr</c-><c- p>());</c->
    <c- c1>// _value_addr() being a private function returning the address of the owned value</c->
<c- p>}</c->
</pre>
   <p>Of course, this function is not intended to be used on local objects. Hopefully
its name should prevent misuses.</p>
<pre class="language-c++ highlight"><c- b>void</c-> <c- nf>foo</c-><c- p>()</c->
<c- p>{</c->
    <c- k>const</c-> <c- n>T</c-> <c- n>val</c-><c- p>;</c->
    <c- n>bar</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>reloc_and_uninitialize</c-><c- p>(</c-><c- o>&amp;</c-><c- n>val</c-><c- p>));</c-> <c- d>/* BAD, val destructor is called at the</c->
<c- d>        end of its scope while it is already destructed!*/</c->
<c- p>}</c->
</pre>
   <p><code class="highlight"><c- n>reloc_and_reclaim</c-></code> is intended to be used by end users and library vendors alike.</p>
<pre class="language-c++ highlight"><c- n>unique_ptr</c-><c- o>&lt;</c-><c- n>pair</c-><c- o>&lt;</c-><c- n>string</c-><c- p>,</c-> <c- n>reloc_only_t</c-><c- o>>></c-> <c- n>makeStuff</c-><c- p>();</c->

<c- n>reloc_only_t</c-> <c- nf>getRelocOnly</c-><c- p>()</c->
<c- p>{</c->
    <c- k>auto</c-> <c- n>stuff</c-> <c- o>=</c-> <c- n>makeStuff</c-><c- p>();</c->
    <c- k>auto</c-> <c- p>[</c-><c- n>str</c-><c- p>,</c-> <c- n>relocOnly</c-><c- p>]</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>reloc_and_reclaim</c-><c- p>(</c-><c- n>stuff</c-><c- p>.</c-><c- n>release</c-><c- p>());</c->
    <c- k>return</c-> <c- n>relocOnly</c-><c- p>;</c->
    <c- c1>// or the short version:</c->
    <c- c1>// return std::reloc_and_reclaim(makeStuff().release()).second;</c->
<c- p>}</c->
</pre>
   <h4 class="heading settled" data-level="6.1.3" id="std-uninitialized_relocate"><span class="secno">6.1.3. </span><span class="content">std::uninitialized_relocate</span><a class="self-link" href="#std-uninitialized_relocate"></a></h4>
   <p>We propose to introduce the following new functions in the <code class="highlight"><c- n>std</c-></code> namespace in
the <code class="highlight"><c- n>memory</c-></code> header:</p>
<pre class="language-c++ highlight"><c- n>template</c-><c- o>&lt;</c-><c- n>class</c-> <c- n>InputIt</c-><c- p>,</c-> <c- n>class</c-> <c- n>ForwardIt</c-><c- o>></c->
<c- n>ForwardIt</c-> <c- n>uninitialized_relocate</c-><c- p>(</c-><c- n>InputIt</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIt</c-> <c- n>last</c-><c- p>,</c-> <c- n>ForwardIt</c-> <c- n>d_first</c-><c- p>);</c->

<c- n>template</c-><c- o>&lt;</c-><c- n>class</c-> <c- n>ExecutionPolicy</c-><c- p>,</c-> <c- n>class</c-> <c- n>InputIt</c-><c- p>,</c-> <c- n>class</c-> <c- n>ForwardIt</c-><c- o>></c->
<c- n>ForwardIt</c-> <c- n>uninitialized_relocate</c-><c- p>(</c-><c- n>ExecutionPolicy</c-><c- o>&amp;&amp;</c-> <c- n>policy</c-><c- p>,</c-> <c- n>InputIt</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIt</c-> <c- n>last</c-><c- p>,</c->
  <c- n>ForwardIt</c-> <c- n>d_first</c-><c- p>)</c-> <c- p>;</c->

<c- n>template</c-><c- o>&lt;</c-><c- n>class</c-> <c- n>InputIt</c-><c- p>,</c-> <c- n>class</c-> <c- n>Size</c-><c- p>,</c-> <c- n>class</c-> <c- n>ForwardIt</c-><c- o>></c->
<c- n>pair</c-><c- o>&lt;</c-><c- n>InputIt</c-><c- p>,</c-> <c- n>ForwardIt</c-><c- o>></c-> <c- n>uninitialized_relocate_n</c-><c- p>(</c-><c- n>InputIt</c-> <c- n>first</c-><c- p>,</c-> <c- n>Size</c-> <c- n>count</c-><c- p>,</c->
  <c- n>ForwardIt</c-> <c- n>d_first</c-><c- p>)</c-> <c- p>;</c->

<c- n>template</c-><c- o>&lt;</c-><c- n>class</c-> <c- n>ExecutionPolicy</c-><c- p>,</c-> <c- n>class</c-> <c- n>InputIt</c-><c- p>,</c-> <c- n>class</c-> <c- n>Size</c-><c- p>,</c-> <c- n>class</c-> <c- n>ForwardIt</c-><c- o>></c->
<c- n>pair</c-><c- o>&lt;</c-><c- n>InputIt</c-><c- p>,</c-> <c- n>ForwardIt</c-><c- o>></c-> <c- n>uninitialized_relocate_n</c-><c- p>(</c->
  <c- n>ExecutionPolicy</c-><c- o>&amp;&amp;</c-> <c- n>policy</c-><c- p>,</c-> <c- n>InputIt</c-> <c- n>first</c-><c- p>,</c-> <c- n>Size</c-> <c- n>count</c-><c- p>,</c-> <c- n>ForwardIt</c-> <c- n>d_first</c-><c- p>);</c->
</pre>
   <p>Those relocate elements from the range <code class="highlight"><c- p>[</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>)</c-></code> (or the first <code class="highlight"><c- n>count</c-></code> elements from <code class="highlight"><c- n>first</c-></code>) to an uninitialized memory area beginning at <code class="highlight"><c- n>d_first</c-></code>.
Elements in the source range will be destructed at the end of the function
(even if an exception is thrown).</p>
   <p>Returns:</p>
   <ul>
    <li data-md>
     <p><code class="highlight"><c- n>uninitialized_relocate</c-></code>: an iterator to the element past the last element relocated;</p>
    <li data-md>
     <p><code class="highlight"><c- n>uninitialized_relocate_n</c-></code>: a pair whose first element is an iterator to the
element past the last element relocated in the source range, and whose second
element is an iterator to the element past the last element relocated in the
destination range.</p>
   </ul>
   <p>If the type to relocate is trivially relocatable and both iterator types are
contiguous, then both functions can be implemented as single <code class="highlight"><c- n>memcpy</c-></code> call over
the entire source range.
Otherwise relocation happens element-wise, as if by calling <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>reloc_and_uninitialize</c-></code> on each element.</p>
   <p>If an exception is thrown by <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>reloc_and_uninitialize</c-></code>, then the destructor of all
remaining elements in the source range is called, as well as the destructor of
all constructed objects in the output iterator.</p>
   <h3 class="heading settled" data-level="6.2" id="std-type_traits-header"><span class="secno">6.2. </span><span class="content">Type traits header</span><a class="self-link" href="#std-type_traits-header"></a></h3>
   <p>We propose to introduce the following type traits, which all derive from <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>true_type</c-></code> or <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>false_type</c-></code> accordingly:</p>
   <ul>
    <li data-md>
     <p><code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>is_relocation_constructible</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code>: same as <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>is_constructible</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> <c- n>T</c-><c- o>></c-></code> ;</p>
    <li data-md>
     <p><code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>is_trivially_relocation_constructible</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code>: same as <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>is_trivially_constructible</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> <c- n>T</c-><c- o>></c-></code> ;</p>
    <li data-md>
     <p><code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>is_nothrow_relocation_constructible</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code> same as <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>is_nothrow_constructible</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> <c- n>T</c-><c- o>></c-></code> ;</p>
    <li data-md>
     <p><code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>is_relocation_assignable</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code>: same as <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>is_assignable</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> <c- n>T</c-><c- o>></c-></code> ;</p>
    <li data-md>
     <p><code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>is_trivially_relocation_assignable</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code>: same as <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>is_trivially_assignable</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> <c- n>T</c-><c- o>></c-></code> ;</p>
    <li data-md>
     <p><code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>is_nothrow_relocation_assignable</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code>: same as <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>is_nothrow_assignable</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> <c- n>T</c-><c- o>></c-></code> ;</p>
    <li data-md>
     <p><code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>has_virtual_relocation_constructor</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code>: derives from <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>true_type</c-></code> if and only if <code class="highlight"><c- n>T</c-></code> declares (maybe implicitly) a virtual or overridden
relocation constructor.
Derives from <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>false_type</c-></code> otherwise ;</p>
    <li data-md>
     <p><code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>is_decomposable</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code>: derives from <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>true_type</c-></code> if and only if <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>is_class_v</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code> is true, and <code class="highlight"><c- n>T</c-></code> decomposition is legal ;
Derives from <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>false_type</c-></code> otherwise ;</p>
   </ul>
   <p>For all new type traits, the inline constexpr boolean template variable counterparts
are also proposed. For instance we propose to introduce:</p>
<pre class="language-c++ highlight"><c- n>template</c-><c- o>&lt;</c-> <c- n>class</c-> <c- n>T</c-> <c- o>></c->
<c- kr>inline</c-> <c- n>constexpr</c-> <c- b>bool</c-> <c- n>is_relocation_constructible_v</c-> <c- o>=</c-> <c- n>is_relocation_constructible</c-><c- o>&lt;</c-><c- n>T</c-><c- o>>::</c-><c- n>value</c-><c- p>;</c->
<c- c1>// along with the rest</c->
</pre>
   <h2 class="heading settled" data-level="7" id="discuss"><span class="secno">7. </span><span class="content">Discussions</span><a class="self-link" href="#discuss"></a></h2>
   <h3 class="heading settled" data-level="7.1" id="abi"><span class="secno">7.1. </span><span class="content">Potential ABI changes</span><a class="self-link" href="#abi"></a></h3>
   <p>As noted above (<a href="#parameter-ownership">§ 3.3 Parameter ownership</a>), some platforms have a <em>caller-destroy</em> ABI
where the <em>calling</em> function expects to destroy nontrivial parameters passed by
value. This poses a problem for functions that wish to relocate from such
parameters, and a potential ABI break.</p>
   <h4 class="heading settled" data-level="7.1.1" id="callee-destroy-abi"><span class="secno">7.1.1. </span><span class="content">relocate-only function parameters</span><a class="self-link" href="#callee-destroy-abi"></a></h4>
   <p>In the <a href="#reloc-with-function-param">case study</a> of how <code class="highlight"><c- n>reloc</c-></code> should behave
with function parameters passed by value, we established the following rule:</p>
   <blockquote>
    <p><strong>Rule:</strong> If the source object is a function parameter passed by value, and its
type provides an eligible move constructor, then the relocation constructor
(if any) may be discarded during overload resolution. Whether the relocation
constructor is discarded is implementation-defined.</p>
   </blockquote>
   <p>If the ABI is not already compliant, then this rule will force an ABI change
on functions which have parameters passed by value,
and whose type declares a relocation constructor but no move constructor.</p>
   <p>The good news is as of today, there are no such types, so no existing function
should suffer from an ABI break. However, some types may accidently gain a relocation
constructor and may trigger an ABI break nonetheless.</p>
   <p>In a future library changes proposal to support relocation (separate from this one),
we must be careful not to
make any existing type relocate-only, especially for that concern.
However we will add a relocation constructor on many classes, alongside their
existing copy and move constructors. In doing so,
some of them may fit the criteria for ABI break, should their copy and move constructors
be deleted (for instance <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>optional</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code> with <code class="highlight"><c- n>T</c-></code> being relocate-only).</p>
   <p>One example is a function with signature: <code class="highlight"><c- b>void</c-> <c- nf>foo</c-><c- p>(</c-><c- n>gsl</c-><c- o>::</c-><c- n>non_null</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>unique_ptr</c-><c- o>&lt;</c-><c- b>int</c-><c- o>>></c-><c- p>);</c-></code>,
supposing <code class="highlight"><c- n>unique_ptr</c-></code> gets a relocation constructor.
In turn GSL developers will
likely add a relocation constructor too. That makes <code class="highlight"><c- n>gsl</c-><c- o>::</c-><c- n>non_null</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>unique_ptr</c-><c- o>&lt;</c-><c- b>int</c-><c- o>>></c-></code> relocate-only, while it wasn’t before, and may cause a potential ABI break.</p>
   <p>There is zero value of passing a <code class="highlight"><c- n>gsl</c-><c- o>::</c-><c- n>non_null</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>unique_ptr</c-><c- o>></c-></code> by value
to a function today, so we doubt anyone would write such a function.
However those functions might theoritically exist, and might have an ABI change.</p>
   <p>Also, library vendors are encouraged to migrate to an ABI where any function that
takes non-trivial parameters by value are responsible for their destruction.
Then, the function definitions can make the most of <code class="highlight"><c- n>reloc</c-></code>.
This is not required by the proposal.</p>
   <p>We believe it’s up to the implementation to choose what they want to do with their ABI:</p>
   <ul>
    <li data-md>
     <p><em>full break</em>, use callee-destroy or equivalent for all non-trivial relocatable types
passed by value (for those who don’t care about ABI) ;</p>
    <li data-md>
     <p><em>break with opt-out</em>: a relocation constructor attribute to opt-out of the ABI
break on functions where it is passed be value.
This solution should also provide propagation mechanisms suitable for composition
(these could be standardized at a later date) ;</p>
    <li data-md>
     <p><em>likely no break, but opt-in</em>: an improved <code class="highlight"><c- p>[[</c-><c- n>trivial_abi</c-><c- p>]]</c-></code> that actually checks that
the type is trivially relocatable ;</p>
    <li data-md>
     <p><em>likely no break</em>: use callee-destroy only for relocatable but immovable types ;</p>
    <li data-md>
     <p>and those that are callee-destroy already don’t need to do anything!</p>
   </ul>
   <p>In all cases the following mitigation and migration techniques could be employed:</p>
   <ul>
    <li data-md>
     <p>functions that have an ABI change could be mangled differently. This makes
ABI breakage detectable ;</p>
    <li data-md>
     <p>for such functions, up to two symbols are emitted, where the old
symbol is emitted only if the function does not in actual fact relocate from
its parameters, in which case the new symbol is emitted, and its implementation
forwards to the old and then destructs its relocatable parameters on exit ;</p>
   </ul>
   <p>Last, this potential breakage was discussed on <a href="https://github.com/itanium-cxx-abi/cxx-abi/issues/187">Itanium ABI github</a>,
although we didn’t get much feedback.</p>
   <h4 class="heading settled" data-level="7.1.2" id="prvalue-assign-op-abi"><span class="secno">7.1.2. </span><span class="content">prvalue assignment operator</span><a class="self-link" href="#prvalue-assign-op-abi"></a></h4>
   <p>As mentioned above, if the class-type is relocatable but immovable, then it may have an
impact on existing prvalue-assignment operators (like it does to any function).
However this change is purely opt-in. If there is an existing prvalue-assignment
operator in a class, then it will prevent the implicit declaration of the
relocation constructor, which will in turn prevent from the potential ABI break.</p>
   <p>Also, the relocation assignment operator may be aliased.
If aliasing occurs, then the ABI does not break as aliasing happens only on a
new hidden function.</p>
   <p>The only scenario where the ABI might break is where:</p>
   <ul>
    <li data-md>
     <p>aliasing happened on declaration level ;</p>
    <li data-md>
     <p>code was compiled against it, and especially generated code that makes direct
calls to the aliased version ;</p>
    <li data-md>
     <p>the class changes, the aliasing only happens at definition level, or does not happen at all.</p>
   </ul>
   <p>This may introduce an ABI break, detectable at link-time (aliased symbols missing):</p>
   <ul>
    <li data-md>
     <p>if the aliasing now happens at definition level, but the aliased operator symbol
remains visible nonetheless, then no ABI breaks are introduced ;</p>
    <li data-md>
     <p>otherwise the ABI break happens, but remains detectable at link-time.</p>
   </ul>
   <h3 class="heading settled" data-level="7.2" id="object-decomposition-alt"><span class="secno">7.2. </span><span class="content">Object decomposition alternatives</span><a class="self-link" href="#object-decomposition-alt"></a></h3>
   <p>In R3, object decomposition took the form of "decomposing functions". An object
could only be decomposed through a member function:</p>
<pre class="language-c++ highlight"><c- n>class</c-> <c- n>T</c-> <c- p>{</c->
    <c- c1>// [..]</c->
    <c- k>auto</c-> <c- n>extract</c-><c- p>(</c-><c- n>this</c-> <c- n>T</c-> <c- n>reloc</c-><c- p>)</c-> <c- p>{</c-> <c- k>return</c-> <c- n>_obj</c-><c- p>;</c-> <c- p>}</c->
<c- n>private</c-><c- o>:</c->
    <c- n>reloc_only_t</c-> <c- n>_obj</c-><c- p>;</c->
<c- p>};</c->
</pre>
   <p>This had drawbacks:</p>
   <ul>
    <li data-md>
     <p>As objects could only be decomposed through member functions, it implied that:</p>
     <ul>
      <li data-md>
       <p>Decomposition had to happen through a dedicated function ;</p>
      <li data-md>
       <p>Decomposition had to happen within the class-type ;</p>
     </ul>
    <li data-md>
     <p>It was hard to decompose more than one object at a given time ;</p>
    <li data-md>
     <p>This used a weird syntax to access base classes: <code class="highlight"><c- n>reloc</c-> <c- n>B</c-></code>, with <code class="highlight"><c- n>B</c-></code> being
a base class.</p>
   </ul>
   <p>We wanted decomposition to be more convenient to use, as it is an intrinsically
close concept to relocation. It took several attempts to reach what we propose
in this paper.</p>
   <h4 class="heading settled" data-level="7.2.1" id="dot-reloc-take-1"><span class="secno">7.2.1. </span><span class="content">The dot-reloc operator</span><a class="self-link" href="#dot-reloc-take-1"></a></h4>
   <p>We studied for a while a putative <em>dot-reloc</em> operator: <code class="highlight"><c- n>p</c-><c- p>.</c-><c- n>reloc</c-> <c- n>first</c-></code>.
The first time the expression was evaluated, the object used as the left operand
would become decomposed, and the subobject used as the right operand would be relocated.
Once decomposed, the source object could no longer be used normally. We
restricted the expressions where a decomposed object would be allowed down to:</p>
   <ul>
    <li data-md>
     <p>data member access ;</p>
    <li data-md>
     <p>cast to base class ;</p>
    <li data-md>
     <p>base member function call ;</p>
   </ul>
   <p>For instance:</p>
<pre class="language-c++ highlight"><c- n>pair</c-><c- o>&lt;</c-><c- n>string</c-><c- p>,</c-> <c- n>string</c-><c- o>></c-> <c- n>p</c-> <c- o>=</c-> <c- n>getPair</c-><c- p>();</c->
<c- k>if</c-> <c- p>(</c-><c- n>test</c-><c- p>())</c-> <c- p>{</c->
    <c- n>foo</c-><c- p>(</c-><c- n>p</c-><c- p>.</c-><c- n>reloc</c-> <c- n>first</c-><c- p>);</c-> <c- c1>// p is now decomposed, p.first is relocated</c->
    <c- n>bar</c-><c- p>(</c-><c- n>p</c-><c- p>.</c-><c- n>second</c-><c- p>);</c-> <c- c1>// ok</c->
<c- p>}</c->
<c- n>foobar</c-><c- p>(</c-><c- n>p</c-><c- p>);</c-> <c- c1>// ko: p may be decomposed</c->
</pre>
   <p>And it could even work with pointer to data-members, given that they were
constant-evaluated:</p>
<pre class="language-c++ highlight"><c- n>template</c-> <c- o>&lt;</c-><c- k>auto</c-> <c- n>DataMember</c-><c- o>></c->
<c- n>string</c-> <c- n>Get</c-><c- p>(</c-><c- n>pair</c-><c- o>&lt;</c-><c- n>string</c-><c- p>,</c-> <c- n>string</c-><c- o>></c-> <c- n>p</c-><c- p>)</c->
<c- p>{</c->
    <c- k>return</c-> <c- n>p</c-><c- p>.</c-><c- o>*</c-><c- n>reloc</c-> <c- n>DataMember</c-><c- p>;</c->
<c- p>}</c->
</pre>
   <p>This approach proved quite convenient to use. However it suffured from much added
complexity:</p>
   <ol>
    <li data-md>
     <p>the code could be hard to follow because objects would be decomposed only when
the first <code class="highlight"><c- p>.</c-><c- n>reloc</c-></code> operator was evaluated ;</p>
    <li data-md>
     <p>the static information of the object (for instance, whether some expressions
involving the object are valid), which are supposed to remain
unchanged during the program ... would change when the first <code class="highlight"><c- p>.</c-><c- n>reloc</c-></code> operator was evaluated ;</p>
    <li data-md>
     <p>relocating a base class still has the unusual syntax: <code class="highlight"><c- n>src</c-><c- p>.</c-><c- n>reloc</c-> <c- n>BaseClass</c-></code> ;</p>
    <li data-md>
     <p>lots of new rules to learn on how to handle a decomposed object ;</p>
    <li data-md>
     <p>would complicate code parsing, as the validity of an id-expression designing an
object would depend on the surrounding expressions, should this object
be decomposed or potentially decomposed.</p>
   </ol>
   <p>This motivated us to make a second attempt with the <em>dot-reloc</em> operator.</p>
   <h4 class="heading settled" data-level="7.2.2" id="dot-reloc-take-2"><span class="secno">7.2.2. </span><span class="content">The dot-reloc operator (take 2)</span><a class="self-link" href="#dot-reloc-take-2"></a></h4>
   <p>The second take of the <em>dot-reloc</em> operator was close to the first.
The only change was that the object was decomposed from the moment of its declaration,
by specifing <code class="highlight"><c- n>reloc</c-></code>. Then, the <em>dot-reloc</em> operator could only be used on a
decomposed object.</p>
   <p>For instance:</p>
<pre class="language-c++ highlight"><c- n>pair</c-><c- o>&lt;</c-><c- n>string</c-><c- p>,</c-> <c- n>string</c-><c- o>></c-> <c- n>p</c-> <c- n>reloc</c-> <c- o>=</c-> <c- n>getPair</c-><c- p>();</c->
<c- k>if</c-> <c- p>(</c-><c- n>test</c-><c- p>())</c-> <c- p>{</c->
    <c- n>foo</c-><c- p>(</c-><c- n>p</c-><c- p>.</c-><c- n>reloc</c-> <c- n>first</c-><c- p>);</c-> <c- c1>// ok as p was decomposed, p.first is relocated</c->
    <c- n>bar</c-><c- p>(</c-><c- n>p</c-><c- p>.</c-><c- n>second</c-><c- p>);</c-> <c- c1>// ok</c->
<c- p>}</c->
<c- n>foobar</c-><c- p>(</c-><c- n>p</c-><c- p>);</c-> <c- c1>// ko: p is decomposed</c->
</pre>
   <p>However this did not fix the concerns (3), (4) and (5) raised above. First and
foremost, a decomposed object almost felt like a new value category in disguise.
This discouraged us to pursue the <em>dot-reloc</em> operator any further.</p>
   <h4 class="heading settled" data-level="7.2.3" id="dot-reloc-no-longer"><span class="secno">7.2.3. </span><span class="content">The proposed approach</span><a class="self-link" href="#dot-reloc-no-longer"></a></h4>
   <p>We learned from the fact that the decomposed object still being accessible
caused lots of issues. From this conclusion, we built the object decomposition
feature as it is proposed in this paper. The decomposed object is no longer
an accessible object but is instead a new namespace housing all its subobjects.</p>
   <p>This approach addresses all the points raised above, while still being
convenient to use. There is one aspect where it compares unfavorably to <em>dot-reloc</em>,
is that we cannot relocate a subobject from a pointer to data member, or from a
base class whose name is passed as a template type parameter:</p>
<pre class="language-c++ highlight"><c- n>template</c-> <c- o>&lt;</c-><c- n>string</c-> <c- n>T</c-><c- o>::*</c-><c- n>_str</c-><c- o>></c->
<c- n>string</c-> <c- n>GetStr</c-><c- p>(</c-><c- n>T</c-> <c- n>obj</c-> <c- n>reloc</c-><c- p>)</c->
<c- p>{</c->
    <c- k>return</c-> <c- n>obj</c-><c- o>::*</c-><c- n>_str</c-><c- p>;</c-> <c- c1>// invalid expression</c->
<c- p>}</c->
<c- n>template</c-> <c- o>&lt;</c-><c- n>class</c-> <c- n>B</c-><c- o>></c->
<c- n>B</c-> <c- n>GetBase</c-><c- p>(</c-><c- n>T</c-> <c- n>obj</c-> <c- n>reloc</c-><c- p>)</c->
<c- p>{</c->
    <c- k>return</c-> <c- n>obj</c-><c- o>::</c-><c- n>B</c-><c- p>;</c-> <c- c1>// invalid expression</c->
<c- p>}</c->
</pre>
   <p>However we believe this to be minor issues, which can still be fixed with a
future proposal should there be a need for it.</p>
   <h3 class="heading settled" data-level="7.3" id="reloc-new-keyword"><span class="secno">7.3. </span><span class="content">Why a new keyword?</span><a class="self-link" href="#reloc-new-keyword"></a></h3>
   <p>Alternatively, a new series of symbols could be used instead of introducing
a new keyword, like: <code class="highlight"><c- o>&lt;~&lt;</c-> <c- n>obj</c-></code> or <code class="highlight"><c- o>&amp;&lt;</c-> <c- n>obj</c-></code> in place of <code class="highlight"><c- n>reloc</c-> <c- n>obj</c-></code>.
However, we feel like <code class="highlight"><c- n>reloc</c-> <c- n>obj</c-></code> better conveys the intent, and has better
readibility.</p>
   <p>The introduction of a new keyword may always break existing codebases. We had a
look at several well-known open source C++ projects to analyse what volume of code
would break if <code class="highlight"><c- n>reloc</c-></code> were a keyword.</p>
   <p>For each of the following repositories, we searched for the <code class="highlight"><c- n>reloc</c-></code> string,
at word boundaries, with case-sensitivity, in all C++ source files and headers
(<code class="highlight"><c- o>*</c-><c- p>.</c-><c- n>cc</c-></code>, <code class="highlight"><c- o>*</c-><c- p>.</c-><c- n>cpp</c-></code>, <code class="highlight"><c- o>*</c-><c- p>.</c-><c- n>cxx</c-></code>, <code class="highlight"><c- o>*</c-><c- p>.</c-><c- n>h</c-></code>, <code class="highlight"><c- o>*</c-><c- p>.</c-><c- n>hpp</c-></code>, <code class="highlight"><c- o>*</c-><c- p>.</c-><c- n>hh</c-></code>).
We manually discarded matches that
were not code (comments or strings). And we put that in perspective with the
total number of files, lines and words of the repository.</p>
   <ul>
    <li data-md>
     <p><a href="https://github.com/qt/qtbase">Qt</a>: 0 hits; files:  7,586 ; lines:  2,794,607 ;
words:  98,635,622; commit: 040b4a4b21b3</p>
    <li data-md>
     <p><a href="https://github.com/boostorg/boost">boost</a> (with all submodules): 0 hits;
files:  23,726 ; lines:  4,133,844 ;
words:  180,808,943; commit: 86733163a3c6</p>
    <li data-md>
     <p><a href="https://github.com/godotengine/godot">godot</a>: 0 hits; files:  5,068 ;
lines:  2,545,299 ;
words:  99,389,743; commit: b6e06038f8a3</p>
    <li data-md>
     <p><a href="https://github.com/abseil/abseil-cpp">abseil-cpp</a>: 0 hits; files:  766 ;
lines:  247,441 ;
words:  9,028,820; commit: de6fca2110e7</p>
    <li data-md>
     <p><a href="https://github.com/facebook/folly">folly</a>: 0 hits; files:  1,861 ;
lines:  532,918 ;
words:  16,669,085; commit: cde9d22e8614</p>
    <li data-md>
     <p><a href="https://github.com/llvm/llvm-project">llvm-project</a>: <strong>124 hits in 11 files</strong> (<code class="highlight"><c- n>reloc</c-></code> only used as local variable or
data member, counting all uses); files:  39,048 ; lines:  9,760,587 ;
words:  385,429,611; commit: 9816c1912d56</p>
    <li data-md>
     <p><a href="https://github.com/gcc-mirror/gcc">gcc</a>: <strong>244 hits in 31 files</strong> (<code class="highlight"><c- n>reloc</c-></code> only used as local variable or
data member, counting all uses); files:  15,337 ; lines:  4,616,875 ;
words:  146,146,684; commit: ee6f262b87fe</p>
    <li data-md>
     <p><a href="https://github.com/Tencent/rapidjson">rapidjson</a>: 0 hits; files:  96 ;
lines:  39,828 ; words:  1,492,060;
commit: a98e99992bd6</p>
    <li data-md>
     <p><a href="https://github.com/google/googletest">googletest</a>: 0 hits; files:  155 ;
lines:  85,703 ; words:  3,104,817;
commit: 71140c3ca7a8</p>
    <li data-md>
     <p><a href="https://github.com/jbeder/yaml-cpp">yaml-cpp</a>: 0 hits; files:  259 ;
lines:  112,513 ; words:  3,784,676;
commit: 1b50109f7bea</p>
    <li data-md>
     <p><a href="https://github.com/google/flatbuffers">flatbuffers</a>: 0 hits; files:  175 ;
lines:  98,163 ; words:  3,851,726;
commit: e0d68bdda2f6</p>
    <li data-md>
     <p><a href="https://github.com/mongodb/mongo">MongoDB</a>: <strong>22 hits in 6 files</strong> (<code class="highlight"><c- n>reloc</c-></code> only used as local variable,
counting all uses); files:  20,054 ; lines:  6,439,465 ; words:  265,329,429;
commit: 73b7a22328c7</p>
    <li data-md>
     <p><a href="https://github.com/opencv/opencv">OpenCV</a>: 0 hits; files:  3,315 ;
lines:  1,556,606 ; words:  58,339,686;
commit: 9627ab9462a4</p>
    <li data-md>
     <p><a href="https://github.com/electron/electron">electron</a>: 0 hits; files:  698 ;
lines:  99,717 ; words:  3,431,787;
commit: 644243efd61b</p>
    <li data-md>
     <p><a href="https://github.com/rui314/mold">mold</a>: 0 hits; files:  813 ; lines:  262,560 ;
words:  9,992,769; commit: a45f97b47430</p>
    <li data-md>
     <p><a href="https://github.com/ClickHouse/ClickHouse">ClickHouse</a>: 0 hits; files:  5,566 ;
lines:  1,128,735 ; words:  68,112,047; commit: d42d9f70c812;</p>
    <li data-md>
     <p><a href="https://github.com/davisking/dlib">Dlib</a>: 0 hits; files:  1,421 ;
lines:  533,513 ; words:  19,080,728; commit: a12824d42584</p>
    <li data-md>
     <p><a href="https://github.com/SFML/SFML">SFML</a>: 0 hits; files:  532 ; lines:  168,787 ;
words:  7,272,946; commit: 9bdf20781819</p>
    <li data-md>
     <p><a href="https://github.com/xbmc/xbmc">Kodi</a>: 0 hits; files:  4,360 ; lines:  1,008,255 ;
words:  34,114,229; commit: b228c778668f</p>
    <li data-md>
     <p><a href="https://github.com/boostorg/beast">Beast</a>: 0 hits; files:  473 ;
lines:  145,193 ; words:  4,768,152; commit: 334b9871bed6</p>
    <li data-md>
     <p><a href="https://github.com/nlohmann/json">JSON for modern C++</a>: 0 hits; files:  450 ;
lines:  137,679 ; words:  5,210,982; commit: 4c6cde72e533</p>
    <li data-md>
     <p><a href="https://github.com/includeos/IncludeOS">IncludeOS</a>: 0 hits; files:  841 ;
lines:  107,582 ; words:  2,903,698; commit: 99b60c782161</p>
    <li data-md>
     <p><a href="https://github.com/SerenityOS/serenity">SerenityOS</a>: <strong>15 hits in 2 files</strong> (<code class="highlight"><c- n>reloc</c-></code> only used as local variable, counting all uses); files:  5,538 ;
lines:  887,768 ; words:  31,766,641; commit: 97dde51a9b3f</p>
   </ul>
   <p>Repository statistics are computed with the following command:</p>
<pre class="language-bash highlight">find -type f <c- se>\(</c-> -name <c- t>'*.h'</c-> -or -name <c- t>'*.hh'</c-> -or -name <c- t>'*.hpp'</c-> -or -name <c- t>'*.cc'</c-> <c- se>\</c->
    -or -name <c- t>'*.cpp'</c-> -or -name <c- t>'*.cxx'</c-> <c- se>\)</c-> -exec wc -l -c <c- o>{}</c-> <c- se>\;</c-> <c- se>\</c->
    <c- p>|</c-> awk <c- t>'{ f+=1 } { l += $1 } { w += $2 } END { print "files: ", f, "; lines: ", l, "; words: ", w }'</c->
</pre>
   <p>As you can see, in the vast majority of cases, <code class="highlight"><c- n>reloc</c-></code> is not used at all.
The impact seems to be minimal, where only a few files might need to be fixed
here and there. To smooth the transition, compilers may also warn that existing
code will break as <code class="highlight"><c- n>reloc</c-></code> will become a keyword in a next C++ version.</p>
   <h3 class="heading settled" data-level="7.4" id="future-directions"><span class="secno">7.4. </span><span class="content">Future directions</span><a class="self-link" href="#future-directions"></a></h3>
   <p>We removed some of the changes we initilialy had in mind, to keep for future
extensions. This proposal aims to be the bare minimum to bring support for
relocate-only types.</p>
   <h4 class="heading settled" data-level="7.4.1" id="future-capture-value"><span class="secno">7.4.1. </span><span class="content">More perfect forwarding</span><a class="self-link" href="#future-capture-value"></a></h4>
   <p>Currently, "perfect forwarding" is built on top of <em>universal references</em>, requiring
an understanding of reference-collapsing and the use of <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>forward</c-></code>. The present
proposal improves on this by incidentally replacing <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>forward</c-></code> with <code class="highlight"><c- n>reloc</c-></code>, but
at the same time the situation is worsened by making relocate-only types viable;
such types cannot be relocated when passed by universal reference.</p>
   <table>
    <tbody>
     <tr>
      <th>Before
      <th>After
     <tr>
      <td>
<pre class="language-c++ highlight"><c- n>template</c-> <c- o>&lt;</c-><c- n>class</c-><c- p>...</c-> <c- n>Args</c-><c- o>></c->
<c- b>void</c-> <c- n>fwd</c-><c- p>(</c-><c- n>Args</c-><c- o>&amp;&amp;</c-><c- p>...</c-> <c- n>args</c-><c- p>)</c->
<c- p>{</c->
    <c- n>do_stuff</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>Args</c-><c- o>></c-><c- p>(</c-><c- n>args</c-><c- p>)...);</c->
<c- p>}</c->
</pre>
      <td>
<pre class="language-c++ highlight"><c- n>template</c-> <c- o>&lt;</c-><c- n>class</c-><c- p>...</c-> <c- n>Args</c-><c- o>></c->
<c- b>void</c-> <c- n>fwd</c-><c- p>(</c-><c- n>Args</c-><c- o>&amp;&amp;</c-><c- p>...</c-> <c- n>args</c-><c- p>)</c->
<c- p>{</c->
    <c- n>do_stuff</c-><c- p>(</c-><c- n>reloc</c-> <c- n>args</c-><c- p>...);</c->
<c- p>}</c->
</pre>
   </table>
    <br> 
   <table>
    <tbody>
     <tr>
      <th>Future
     <tr>
      <td>
<pre class="language-c++ highlight"><c- n>template</c-> <c- o>&lt;</c-><c- n>class</c-><c- p>...</c-> <c- n>Args</c-><c- o>></c->
<c- b>void</c-> <c- n>fwd</c-><c- p>(</c-><c- n>decltype</c-><c- p>(</c-><c- n>Args</c-><c- p>)...</c-> <c- n>args</c-><c- p>)</c->
<c- p>{</c->
    <c- n>do_stuff</c-><c- p>(</c-><c- n>reloc</c-> <c- n>args</c-><c- p>...);</c->
<c- p>}</c->
</pre>
   </table>
   <p>We suggest a new way to deduce template type parameters, by allowing <code class="highlight"><c- k>decltype</c-><c- p>(</c-><c- n>T</c-><c- p>)</c-></code> in the function parameters (only if <code class="highlight"><c- n>T</c-></code> is a function template
type parameter). With this addition,
it would become possible to deduce each parameter to value, lvalue
reference or rvalue reference according to whether the argument is of
value category prvalue, lvalue or xvalue, and forward by relocation.</p>
   <h4 class="heading settled" data-level="7.4.2" id="solve-discarded-reloc-expr"><span class="secno">7.4.2. </span><span class="content">discarded reloc expression</span><a class="self-link" href="#solve-discarded-reloc-expr"></a></h4>
   <p>Initilialy, discarded reloc expressions such as <code class="highlight"><c- n>reloc</c-> <c- n>obj</c-><c- p>;</c-></code> would simply
translate to a call to the destructor of <code class="highlight"><c- n>obj</c-></code>, while ensuring that the
destructor won’t be called again at the end of its scope.</p>
   <p>However this is hardly possible at the moment because of all the different ABIs
that exist. If <code class="highlight"><c- n>obj</c-></code> is an <em>unowned parameter</em>, then the function cannot elide
the destructor call of <code class="highlight"><c- n>obj</c-></code> that will happen on the caller-side.</p>
   <p>We wanted the well-formedness of the code above all else (i.e. <code class="highlight"><c- n>reloc</c-> <c- n>obj</c-><c- p>;</c-></code> could
not be well-formed on some implementations and not in others). As such,
in this proposal, <code class="highlight"><c- n>reloc</c-> <c- n>obj</c-><c- p>;</c-></code> is only well-formed if <code class="highlight"><c- n>obj</c-></code> is
relocatable, movable or copyable.</p>
   <p>Hence, the best we can do if <code class="highlight"><c- n>obj</c-></code> is an <em>unowned parameter</em>,
is to move-construct a temporary, and destruct
it right after, which will trigger the desired side-effects of the destructor
(e.g. release a lock if <code class="highlight"><c- n>obj</c-></code> is a <code class="highlight"><c- n>unique_lock</c-></code>).
The destructor of <code class="highlight"><c- n>obj</c-></code> will still be called when the function
returns, but will likely do nothing as the object will be in a moved-from state.</p>
   <p>A future proposal could make <code class="highlight"><c- n>reloc</c-> <c- n>obj</c-><c- p>;</c-></code> to just call the destructor,
regardless of whether <code class="highlight"><c- n>obj</c-></code> is an <em>unowned parameter</em> and of its constructors,
solving those ABI issues.</p>
   <h3 class="heading settled" data-level="7.5" id="easier-cpp"><span class="secno">7.5. </span><span class="content">Will it make C++ easier?</span><a class="self-link" href="#easier-cpp"></a></h3>
   <p>This proposal introduces a new keyword, and a bunch of new concepts
(relocation constructor, decomposition), which are additional things to teach.
However we have hopes this proposal will improve the language on many areas
and eradicate some gotchas:</p>
   <ul>
    <li data-md>
     <p>support for relocation-only types, which allow for better class design
with stronger class invariants ;</p>
    <li data-md>
     <p><code class="highlight"><c- n>reloc</c-></code> aims to fix the "moved-from state" understanding problem,
and the used-after-move errors ;</p>
    <li data-md>
     <p>relocation fixes the <code class="highlight"><c- k>const</c-></code> pessimization with move constructor ;</p>
    <li data-md>
     <p><code class="highlight"><c- n>reloc</c-></code> creates more opportunities to declare constant variables, improving on
code readability and performance.</p>
   </ul>
  </main>
<script>
(function() {
  "use strict";
  var collapseSidebarText = '<span aria-hidden="true">←</span> '
                          + '<span>Collapse Sidebar</span>';
  var expandSidebarText   = '<span aria-hidden="true">→</span> '
                          + '<span>Pop Out Sidebar</span>';
  var tocJumpText         = '<span aria-hidden="true">↑</span> '
                          + '<span>Jump to Table of Contents</span>';

  var sidebarMedia = window.matchMedia('screen and (min-width: 78em)');
  var autoToggle   = function(e){ toggleSidebar(e.matches) };
  if(sidebarMedia.addListener) {
    sidebarMedia.addListener(autoToggle);
  }

  function toggleSidebar(on) {
    if (on == undefined) {
      on = !document.body.classList.contains('toc-sidebar');
    }

    /* Don’t scroll to compensate for the ToC if we’re above it already. */
    var headY = 0;
    var head = document.querySelector('.head');
    if (head) {
      // terrible approx of "top of ToC"
      headY += head.offsetTop + head.offsetHeight;
    }
    var skipScroll = window.scrollY < headY;

    var toggle = document.getElementById('toc-toggle');
    var tocNav = document.getElementById('toc');
    if (on) {
      var tocHeight = tocNav.offsetHeight;
      document.body.classList.add('toc-sidebar');
      document.body.classList.remove('toc-inline');
      toggle.innerHTML = collapseSidebarText;
      if (!skipScroll) {
        window.scrollBy(0, 0 - tocHeight);
      }
      tocNav.focus();
      sidebarMedia.addListener(autoToggle); // auto-collapse when out of room
    }
    else {
      document.body.classList.add('toc-inline');
      document.body.classList.remove('toc-sidebar');
      toggle.innerHTML = expandSidebarText;
      if (!skipScroll) {
        window.scrollBy(0, tocNav.offsetHeight);
      }
      if (toggle.matches(':hover')) {
        /* Unfocus button when not using keyboard navigation,
           because I don’t know where else to send the focus. */
        toggle.blur();
      }
    }
  }

  function createSidebarToggle() {
    /* Create the sidebar toggle in JS; it shouldn’t exist when JS is off. */
    var toggle = document.createElement('a');
      /* This should probably be a button, but appearance isn’t standards-track.*/
    toggle.id = 'toc-toggle';
    toggle.class = 'toc-toggle';
    toggle.href = '#toc';
    toggle.innerHTML = collapseSidebarText;

    sidebarMedia.addListener(autoToggle);
    var toggler = function(e) {
      e.preventDefault();
      sidebarMedia.removeListener(autoToggle); // persist explicit off states
      toggleSidebar();
      return false;
    }
    toggle.addEventListener('click', toggler, false);


    /* Get <nav id=toc-nav>, or make it if we don’t have one. */
    var tocNav = document.getElementById('toc-nav');
    if (!tocNav) {
      tocNav = document.createElement('p');
      tocNav.id = 'toc-nav';
      /* Prepend for better keyboard navigation */
      document.body.insertBefore(tocNav, document.body.firstChild);
    }
    /* While we’re at it, make sure we have a Jump to Toc link. */
    var tocJump = document.getElementById('toc-jump');
    if (!tocJump) {
      tocJump = document.createElement('a');
      tocJump.id = 'toc-jump';
      tocJump.href = '#toc';
      tocJump.innerHTML = tocJumpText;
      tocNav.appendChild(tocJump);
    }

    tocNav.appendChild(toggle);
  }

  var toc = document.getElementById('toc');
  if (toc) {
    createSidebarToggle();
    toggleSidebar(sidebarMedia.matches);

    /* If the sidebar has been manually opened and is currently overlaying the text
       (window too small for the MQ to add the margin to body),
       then auto-close the sidebar once you click on something in there. */
    toc.addEventListener('click', function(e) {
      if(e.target.tagName.toLowerCase() == "a" && document.body.classList.contains('toc-sidebar') && !sidebarMedia.matches) {
        toggleSidebar(false);
      }
    }, false);
  }
  else {
    console.warn("Can’t find Table of Contents. Please use <nav id='toc'> around the ToC.");
  }

  /* Wrap tables in case they overflow */
  var tables = document.querySelectorAll(':not(.overlarge) > table.data, :not(.overlarge) > table.index');
  var numTables = tables.length;
  for (var i = 0; i < numTables; i++) {
    var table = tables[i];
    var wrapper = document.createElement('div');
    wrapper.className = 'overlarge';
    table.parentNode.insertBefore(wrapper, table);
    wrapper.appendChild(table);
  }

})();
</script>
  <h2 class="no-num no-ref heading settled" id="references"><span class="content">References</span><a class="self-link" href="#references"></a></h2>
  <h3 class="no-num no-ref heading settled" id="informative"><span class="content">Informative References</span><a class="self-link" href="#informative"></a></h3>
  <dl>
   <dt id="biblio-d2839r1">[D2839R1]
   <dd>Brian Bi; Joshua Berne. <a href="https://isocpp.org/files/papers/D2839R1.html"><cite>Nontrivial Relocation via a New owning reference Type</cite></a>. June 2023. URL: <a href="https://isocpp.org/files/papers/D2839R1.html">https://isocpp.org/files/papers/D2839R1.html</a>
   <dt id="biblio-iife">[IIFE]
   <dd>Bartlomiej Filipek. <a href="https://www.cppstories.com/2016/11/iife-for-complex-initialization/"><cite>IIFE for Complex Initialization - C++ Stories</cite></a>. October 2016. URL: <a href="https://www.cppstories.com/2016/11/iife-for-complex-initialization/">https://www.cppstories.com/2016/11/iife-for-complex-initialization/</a>
   <dt id="biblio-n4158">[N4158]
   <dd>Pablo Halpern. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4158.pdf"><cite>Destructive Move</cite></a>. October 2014. URL: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4158.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4158.pdf</a>
   <dt id="biblio-p0023r0">[P0023R0]
   <dd>Denis Bider. <a href="http://open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0023r0.pdf"><cite>Relocator: Efficiently moving objects</cite></a>. April 2016. URL: <a href="http://open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0023r0.pdf">http://open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0023r0.pdf</a>
   <dt id="biblio-p0308r0">[P0308R0]
   <dd>Peter Dimov. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0308r0.html"><cite>Valueless Variants Considered Harmful</cite></a>. March 2016. URL: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0308r0.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0308r0.html</a>
   <dt id="biblio-p1029r3">[P1029R3]
   <dd>Niall Douglas. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1029r3.pdf"><cite>move = bitcopies</cite></a>. January 2020. URL: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1029r3.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1029r3.pdf</a>
   <dt id="biblio-p1144r8">[P1144R8]
   <dd>Arthur O'Dwyer. <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1144r8.html"><cite>std::is_trivially_relocatable</cite></a>. May 2023. URL: <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1144r8.html">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1144r8.html</a>
   <dt id="biblio-p2665r0">[P2665R0]
   <dd>Bengt Gustafsson. <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2665r0.pdf"><cite>Allow calling overload sets containing T, const T&amp;</cite></a>. October 2022. URL: <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2665r0.pdf">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2665r0.pdf</a>
  </dl>