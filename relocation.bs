<pre class='metadata'>
Title: Relocating prvalues
Revision: 4
Audience: LEWG, EWG
Status: P
Group: WG21
ED: https://htmlpreview.github.io/?https://github.com/SebastienBini/cpp-relocation-proposal/blob/main/relocation.html
Shortname: P2785
Editor:
  SÃ©bastien Bini, Amadeus, sebastien.bini@gmail.com
  Ed Catmur, ed@catmur.uk
Markup Shorthands: markdown yes, biblio yes, markup yes
Abstract:
  This paper proposes several mechanisms to enable real relocation in C++.
  We cover several topics, such as trivial relocatibility, container optimizations,
  supports for relocate-only types, library changes and the impact of the existing code base.
Date: 2023-06-14
</pre>

# Overview # {#intro}

Move semantics were introduced with C++11, and have improved the language in
many aspects. However they have also brought their lot of defects:

- `std::move` does not move ;
- moved-from objects are in an unspecified state, and more often than not,
    must not be reused ;
- constant objects cannot be moved ;
- classes that want to support move-semantics must either have a natural empty
    state (like strings, containers or smart pointers)
    or force one into their design, usually creating a loophole in their class invariant.

We propose to resolve all these issues with a new kind of operation: "relocation".
Relocation is the operation of constructing a
new target object while simultaneously destructing the source object.
Relocation will happen thanks to a new keyword `reloc` and a new relocation
constructor (with signature `T(T)`).

```c++
// with: void foo(non_null<unique_ptr<T>>)

non_null<unique_ptr<T>> const ptr{new T};
ptr->do_stuff();
foo(reloc ptr);
// ptr cannot be reused or the program is ill-formed
```

This tackles every flaw not solved by move-semantics:

- `reloc` does perform the relocation ;
- relocated objects cannot be re-used, or else the program is ill-formed ;
- relocation disregards cv-qualifiers, so constant objects can be relocated ;
- classes that want to support relocation can do so without breaking their
    class invariant, as the relocated-from object is simultaneously destructed.

Another major addition of this proposal is the `.reloc` operator which allows
to relocate subobjects. This enables to relocate data members of compound types
(such as `std::pair`) and to easily write used-defined relocation constructor.

```c++
pair<std::string const, int> const keyValue = extractKV();
storeKey(keyValue.reloc first);
```
```c++
template <class First, class Second>
class MyPair
{
public:
    First first;
    Second second;

    // user-defined relocation constructor (could have been defaulted)
    MyPair(MyPair rhs) : first{rhs.reloc first}, second{rhs.reloc second} {}
};
```

This proposal introduces:

- two new special member functions: a relocation constructor `T(T)` and a relocation
    assignment operator `T& operator=(T)` ;
- a new keyword: `reloc` which backs two new operators: `reloc` and `.reloc` (*dot-reloc*) ;
- slight changes to overload resolution rules ;
- might introduce ABI breaks to some functions (opt-in).

This proposal does not introduce a new value category: instead it completes C++
tripartite value system as we propose relocation to happen from prvalues.

## Changes from previous revisions of P2785 ## {#changes}

### Changes from P2785R3 ### {#changes-from-r3}

#### Motivation #### {#changes-from-r3-motivation}

The motivation section is more complete, giving more explanations, describing
where today's C++ falls short, how we intend to improve, and each time illustrated with an
example.

#### Dot reloc instead of decomposing functions #### {#changes-from-r3-dot-reloc}

One of the major changes we introduced is the `.reloc` (*dot-reloc*) operator
that can easily decompose an object. This has several advantages:

- it greatly simplifies the writing and the understanding of the relocation constructor
    and reloc assignment operator ;
- it simplifies the handling of relocate-only subobjects in user code ;
- it removes the *decomposing functions* feature as they are being replaced by
    `.reloc` ;
- the whole proposal is more unified as all those changes are now built on top
    of the *dot-reloc* operator.

#### Value parameter ownership rule #### {#changes-from-r3-value-param-ownership}

In P2785R3, we mandated that a function taking a relocate-only type as value
parameter **must** have control over its lifetime. This might break some ABIs
on rare occasions, but in a controlled way.

In R4, we take a slightly less conservative approach: *any function
that takes a parameter by value, whose type provides a relocation constructor*
**but no move constructor**, *must have control over the lifetime of that parameter.*

Discussion about this change is detailed in the
[reloc with function parameters](#reloc-with-function-param)
section.

#### Library changes #### {#changes-from-r3-stl}

In P2785R3, we enumerated all the desired changes in the STL to properly
support relocation. Now the suggested library changes only contain the bare
minimum for library writers. A more comprehensive list of changes
will be proposed separately, depending on the reception of the current proposal.

### Changes from older revisions ### {#changes-from-older}

R0, R1 and R2 revisions are internal versions bumps that were
never formerly presented.

# Motivation # {#motivation}

## More constness! ## {#const-vs-move}

Automatic objects are recommended by various guidelines to be constant, since a constant object
will not change throughout its lifetime, simplifying reasoning about program state both for
humans (coders, reviewers, maintainers) and for machines (compilers, tooling).
In addition when used in class design, `const` on member functions and data members
enables to explicitly write class invariants. Last, allowing an object
to be `const` throughout its lifetime but give up its resources at the end of its lifetime allows
for better, safer code.

However `const` usefulness is greatly diminished because of move-semantics.
The move constructor cannot work with a constant source object.
Hence for those, the program either
silently falls back to calling their copy constructor, or is simply ill-formed...

```c++
// with: void bar(A);

A const a = someFunc();
bar(std::move(a)); // silently calls A's copy ctor, performing a deep copy...
```

Declaring an object with `const` may have unwanted side-effects. As a consequence:

- some developers will use `const` to naively declare constant objects as so - *as one would
    expect from the language* - while being unaware of the side-effects. This may
    lead to unoptimized code, with the copy constructor being called *silently*
    while `std::move` is explicitly called ;
- knowledgeable developers will rather not use it if they can foresee the
    negative side-effect, which leads to poorer code (see the benefits of `const`
    described above), but can make use of the move constructor.

This is a missed opportunity and it leads to poorer code. The
proposed relocation semantics solves this problem: constant objects can be relocated,
they are just destroyed when done so.

```c++
A const a = someFunc();
bar(reloc a);
```

### Constant local variables cannot be moved ### {#const-var}

We also have to consider that the Immediately Invoked Function Expressions (IIFE)
decouples the possibilities to declare constant variables (even when they have
a complex initialization routine), were they not hindered down
by `std::move`.

Consider the following code snippets:

<table>
<tr><th>Before</th><th>Constified + relocation (IIFE)</th></tr>
<tr>
<td valign="top">
```c++
void foo(A a, B b, C c);

void bar()
{
  A a = getA();

  B b = getB(a);
  b.processData();

  C c = getC(a.token(), b);
  c.fetchAll();
  c.processData();
  c.finalize();

  foo(std::move(a), std::move(b),
    std::move(c));
}
```
</td>
<td valign="top">
```c++
void foo(A a, B b, C c);

void bar()
{
  A const a = getA();

  B const b = std::invoke([&] {
    B b = getB(a);
    b.processData();
    return b;
  });

  C const c = std::invoke([&] {
    C c = getC(a.token(), b);
    c.fetchAll();
    c.processData();
    c.finalize();
    return c;
  });

  foo(reloc a, reloc b, reloc c);
}
```
</td>
</tr></table>

NOTE: We expect the `reloc` operator to also multiply the
possibilities to declare constant variables, with ou without the IIFE idiom:

<table>
<tr><th>Constified + relocation (no IIFE)</th></tr>
<tr>
<td valign="top">
```c++
void foo(A a, B b, C c);

void bar()
{
  A const a = getA();

  B b_mut = getB(a);
  b_mut.processData();
  B const b = reloc b_mut;

  C c_mut = getC(a.token(), b);
  c_mut.fetchAll();
  c_mut.processData();
  c_mut.finalize();
  C const c = reloc c_mut;

  foo(reloc a, reloc b, reloc c);
}
```
</td>
</tr></table>

The versions with `reloc` can benefit from constant variables.
Their initialization code
is strictly enclosed in the lambda expressions (IFFE version) or relocated
to their const version once initialized (no IFFE). By looking at the code, we
know that each variable will remain unmodified for the remaining of the function,
even when used in the initialization of other variables.

The `reloc` keyword relocates the objects to the parameter slots of `foo`. `a`,
`b`, and `c` have reached their end of life when the call to `foo` completes and
can no longer be used in `bar`. In particular, should `a`, `b` and `c` be relocatable,
their destructor will not even be called.

### Constant data members ### {#const-data-members}

It's not uncommon to find in production codebase things like this:

```c++
class SomeType
{
public:
    // some parameterized constructor
    // SomeType(...)

    SomeType(SomeType&&) = default;

private:
    std::string const _key1;
    std::string const _key2;
    int _val;
};
```

Here the developer innocently qualified `_key1` and `_key2` as constant.
In their mind, their value was never to change in the lifetime of the object.
This being part of the class invariant, it only feels natural to enforce the
class invariant in the code, with the `const` qualifier.

However the experienced developer will have noticed the incurred performance drawback:
the move constructor, because of `const`, will be forced to make a deep copy
of `_key1` and `_key2` (via std::string's copy constructor). This gives an even
bitter taste when we know that
the moved-from object will pretty likely be destructed right after, meaning
that the deep copy will have been done for nothing.

This issue is solved with relocation:

<table>
<tr><th>Before (fixed)</th><th>After</th></tr>
<tr>
<td valign="top">
```c++
class SomeType
{
public:
  // some parameterized constructor
  // SomeType(...)

  SomeType(SomeType&&) = default;

private:
  std::string _key1; /* const but cannot
    mark it so because of the
    move constructor */
  std::string _key2; /* const but cannot
    mark it so because of the
    move constructor */

  int _val;
};
```
</td>
<td valign="top">
```c++
class SomeType
{
public:
  // some parameterized constructor
  // SomeType(...)

  SomeType(SomeType) = default;

private:
  std::string const _key1;
  std::string const _key2;
  int _val;
};
```
</td>
</tr></table>

See how the code becomes clearer: class invariant can be written in the code
instead of comments, which leads to a code that is both more readable and
robust.

*This is not an isolated example*. In fact, we invite the reader to think of all
the places that could have benefited from a constant data member but didn't because
of this issue. How much clearer the code would have been, had you been able
to write `const`?

Let's illustrate this with a final example. Consider a `flat_map` implementation.
As a `flat_map` implements an associative container, we know for a fact that the keys
of that container will never change. We could write it quite easily in our class
invariant:

```c++
template <class Key, class Val>
class MyFlatMap
{
public:
    // [...]

private:
    std::vector<std::pair<Key const, Val>> _map;
};
```

However, as of today,
this will lead to a deep copy of some range of keys when a new item is inserted
anywhere but at the end of `_map`, or when `_map` needs to grow.
Support for relocation in the language (and in the STL) will enable to write
`const` with no performance hit.

## Support for relocate-only types ## {#reloc-only-support}

As of today, C++ provides very little support for class-types which provide
no copy and no move constructors. Such objects are impractical to handle, for they
can only be:

- constructed as a function local variable ;
- returned from said function if copy-elision is guaranteed ;
- constructed in-place in a node-based container ;
- or constructed in-place in the parameter slot of another function.

We cannot however, perform any operation that will move or copy the object to
another address in memory:

- we cannot pass such objects by value in the parameter slots of other functions,
    unless the object is constructed in the parameter slot.
- Such types cannot be stored in any non node-based containers. Node-based
    containers have a performance overhead as they require more
    memory allocations. The node-based property may not be desired by users
    but they are forced to pay for it anyway as there is no support for such
    types in other containers.

Relocation fixes those issues by bringing support for relocate-only types.
Thanks to relocation, relocate-only types can for instance be stored in a `std::vector`
or passed from functions to functions.

### Accidental relocate-only types ### {#motivation-accidental-relocate-only-types}

Some classes do need to be immovable by design (like `std::mutex`) ;
those types can perfectly remain so with this proposal. However there is still
the case of some types which are accidentally made immovable, because they are
being wrapped with another type, or merely because of their cv-qualifiers
(look no further than `const`).

Let's us consider the
`gsl::not_null<std::unique_ptr<T>>` case for a moment. `gsl::not_null` inhibits
the move constructor, as a moved-from pointer would be null and break the class invariant.
In turn `std::unique_ptr` inhibits the copy constructor because of its ownership policy.
Hence this type is non-copyable and non-movable. Another example is simply
`std::unique_ptr<T> const`, where the qualifier inhibits the move constructor...

Those objects are legitimate since
they improve code correctness (the user need not check whether they are empty,
or are sure the pointed address hasn't changed) and performance. However, we
choose not to use such types in our code because we know how impractical they
are to handle, especially if we know they will need to be moved.

This is once again a missed opportunity ; our proposal fixes this issue.
With the relocation
semantics in mind, this would be allowed: each time `gsl::not_null<std::unique_ptr<T>>`
or `std::unique_ptr<T> const`
are moved in memory, the previous instance is simultaneously destroyed (very often in practice,
this simply means the memory is moved as if by `memcpy`, and the memory occupied
by the source object just becomes uninitialized.
In particular, the source object's destructor is not called).

### Move constructor breaks class invariant ### {#motivation-never-empty}

In framework code it is a relatively everyday task to write helper classes that are
constructed to own some resource, passed around from place to place, and then destroyed,
cleaning up the resource in the destructor.

Move semantics for such classes requires
identifying or adding an appropriate empty state, writing a move constructor, and
adding checks to the destructor; all of these inhibit performance and are opportunities
to introduce bugs. Relocation would replace all of this with a single defaulted special
member function declaration.

For instance, consider a file descriptor class, which opens a file in its
constructor (throws in case of failure), and closes it in its destructor.

<table>
<tr><th>Before</th><th>After</th></tr>
<tr>
<td valign="top">
```c++
class FileDesc
{
public:
  // some parameterized constructor, which
  // guarantees _fd != -1 or else throws
  // FileDesc(...)

  ~FileDesc()
  { if (_fd != -1) ::close(_fd); }

  FileDesc(FileDesc&& rhs) noexcept :
    _fd{std::exchange(rhs._fd, -1)} {}

  FileDesc&
  operator=(FileDesc&& rhs) noexcept
  {
    _fd = std::exchange(rhs._fd, -1);
    return *this;
  }

private:
  int _fd;
};
```
</td>
<td valign="top">
```c++
class FileDesc
{
public:
  // some parameterized constructor, which
  // guarantees _fd != -1 or else throws
  // FileDesc(...)

  ~FileDesc() { ::close(_fd); }

  FileDesc(FileDesc) noexcept = default;

  FileDesc&
  operator=(FileDesc) noexcept = default;

private:
  int const _fd; //< can now be const
};
```
</td>
</tr></table>

The code on the right is easier to write, to maintain and to understand.
This is because there is no need to handle the *moved-from* state in which
`_fd == -1`. But first and foremost, the version with relocation benefits from
an **improved class-invariant**: it provides at all times a valid file
descriptor. This simplifies reasoning and usability throughout the code.

We didn't have this guarantee before because of the move-constructor: the `FileDesc`
class might not have held a valid file
descriptor, had it been moved-from before.

## Safety against use-after-move ## {#motivation-safer-use-after-move}

Moved-from objects are in an unspecified yet valid state. This is true even
in cases where there exists a natural empty state (like for `std::string` or
`std::vector`). For this reason, it is advised not to reuse a moved-from object
(that is to say, we let it die). However the language does not prevent from
reusing such objects,
which leaves the door open for mistaken uses, ... and sometimes with
disastrous consequences.

Consider for instance the *p-impl* idiom, which is commonly used by
library vendors to guard against ABI breaks. The `impl` pointer is allocated
in the constructor, but what about the move constructor? Understandably, to
avoid unnecessary allocations, library
vendors often choose to leave the `impl` pointer of the moved-from object set to the
null pointer. Unless the moved-from object is re-assigned to something valid,
any further access to its data will trigger the program termination!

This issue is fixed with relocation, as the language will forbid any reuse
of a relocated object. Reconsidering any *p-impl* implementation, the move
constructor could simply be dropped in favor of the relocation constructor, and
the `impl` pointer would always be valid.

External tools do exist to detect such `use-after-move` errors. However we believe
the language can only be improved if we reduce its reliance on external tools,
especially for things as embarrassing as memory safety. Also, tools are fallible
(they may not detect all issues, or may not at all be ran in some companies),
which is less true for compilers (you cannot not run a compiler).

## Early destruction ## {#motivation-early-dtor}

We sometimes need to trigger the destruction of an object early, before
its end of scope. It's often the case when a particular destructor side-effect
is wanted early:

```c++
std::experimental::scope_exit guard{[this] { updateMetrics(); }};
// [...]
if (someTest())
{
    // need to call updateMetrics before modifyMetrics!
    guard.release();
    updateMetrics();
    modifyMetrics();
}
// [...]
```

There is no clean mechanism to do this today in C++. One way is to wrap the
type into an `std::optional` and reset the optional when the destruction of the
contained object is wanted. Another is to move to a temporary.

As it is done with this paper, relocation provides a clean solution for this
case. [Discarded relocated objects are simply destructed](#discarded-reloc-expr), triggering the desired
effect.

<table>
<tr><th>Before (optional)</th></tr>
<tr>
<td valign="top">
```c++
std::optional guard = std::scope_exit{[this] { updateMetrics(); }};
// [...]
if (someTest())
{
    // need to call updateMetrics before modifyMetrics!
    guard.reset();
    modifyMetrics();
}
// [...]
```
</td>
</tr></table>
<br/>
<table>
<tr><th>Before (Temporary)</th></tr>
<td valign="top">
```c++
std::scope_exit guard{[this] { updateMetrics(); }};
// [...]
if (someTest())
{
    // need to call updateMetrics before modifyMetrics!
    { auto _ = std::move(guard); }
    modifyMetrics();
}
// [...]
```
</td>
</tr></table>
<br/>
<table>
<tr><th>After</th></tr>
<td valign="top">
```c++
std::scope_exit guard{[this] { updateMetrics(); }};
// [...]
if (someTest())
{
    // need to call updateMetrics before modifyMetrics!
    reloc guard;
    modifyMetrics();
}
// [...]
```
</td>
</tr></table>

This is not what motivates this proposal, but comes as an added bonus, which
we thought was worth mentioning.

## Teachability ## {#motivation-teachability}

It is a matter of some confusion for learners that a "moved-from" object still exists and is
accessible, but has an unspecified state. This leads to so-called "use-after-move" bugs, and
requires static analysis passes and coding guidelines to prevent. "What does `std::move` do?"
is, regrettably, a common "gotcha" question in a certain style of coding interview. In this
matter C++ compares unfavorably to other languages where the "move" operation is destructive
(if trivial) and bars further access to the source object.

## Versus trivial relocation ## {#motivation-vs-trivial-relocation}

As will be seen below, trivial relocation provides an incomplete solution to the issues
presented in this section. The primary concern is that of composability; an aggregate of
a self-referential type that cannot be trivially relocated (e.g. `std::string` in some
implementations) and a relocate-only type (e.g. a non-null `unique_ptr`) can neither be
relocated by move-and-destroy nor trivially relocated. Thus non-trivial relocation
emerges as a requirement.

## Library performance ## {#motivation-performance}

Finally, relocation and especially trivial relocation will bring performance boosts
in many situations. Other proposals make fine work at enumerating all the gains to be had
from trivial relocation (see in particular [[P1144R8]]). To summarize, the performance gains
are mainly in containers (std::vector::resize and the likes)
and code size gains from functions that use `std::swap`.

# Nomenclature # {#nomenclature}

We refer to the <a href="https://wg21.link/intro.defs">Terms and definitions</a> of the C++ Standard,
and to nomenclature introduced therein,
in particular the <a href="https://wg21.link/intro.object">object model</a>.
In addition, we define:

## Source and target objects ## {#src-and-target}

Relocation is the act of constructing a new instance while ending the lifetime of an existing one.
This allows destructively stealing its resources, if any.

The new instance is called the *target object*.
The existing instance whose lifetime is ended and whose resources
are stolen is called the *source object*.

## Destructed state ## {#dtor-state}

An object is to be in a *destructed state* if its lifetime has ended because:

- its destructor was called, or ;
- it was passed to as source object to its relocation constructor.

It is a
programming error to call the destructor of an object if it is already in a
*destructed state*.
As described in <a href="https://eel.is/c++draft/basic.life#9">[basic.life]</a>,
this has undefined behavior unless the object type is trivial, in which case its destructor
or pseudo-destructor is a no-op.

## Parameter ownership ## {#parameter-ownership}

The lifetime of function parameters is implementation-defined in C++, but it
is of most importance with relocation. Depending on the function call convention
or ABI, the function may or may not be in charge of the lifetime of its parameters.

An object is said to be an *owned parameter* (respectively, an
*unowned parameter*) with regards to a function `f`
if the object is a parameter of `f`, passed by value, and that `f`
has control (respectively, does not have control) over its lifetime.

We denote two main parameter passing conventions:

- *caller-destroy*: the call site is in charge of the lifetime of the value parameter passed in the function call ;
- *callee-destroy*: the function itself is in charge of the lifetime of its value parameters ;

Depending on the ABI choice, the convention can be per parameter, or apply
to all the function parameters. Other conventions may exist, and they are
still compatible with this proposal.

For instance, in a function with caller-destroy convention, all its value
parameters are *unowned parameters*.
Likewise, with callee-destroy, all of its parameters are *owned parameters*.

# Comparison with existing proposals # {#compare}

This proposal introduces the `reloc` keyword, which allows users to explicitly
and safely relocate local variables in their code base.

This proposal is also one of the few (with [[P0308R0]]), to tackle the case of
relocate-only types. The `reloc` keyword thus becomes necessary to safely pass
around such objects in user code.

Also, all these proposals (but [[P0308R0]]) aim to optimize the move and destruct
operations into a single memcpy. But there are places where this optimization
could not happen, and we are left with suboptimized move constructor and destructor calls.

The relocation constructor that we propose offers a customization point, and
especially allows for a more optimized relocation technique than move and destruct.
If trivial, then it can be optimized into a `memcpy`.

## P1144R8: Object relocation in terms of move plus destroy by Arthur O'Dwyer ## {#compare-P1144R8}

[[P1144R8]] puts the focus on trivially relocatable types, and offers ways to
mark a type as trivially relocatable.

The current proposal has its own take on trivial relocatability that does not
rely on a class attribute. Instead the trivial relocatability
trait flows naturally from the new relocation constructor that we introduce. In short:
if a class type has a relocation constructor that is (explicitly) declared as defaulted or
is implicitly defined and not defaulted as deleted, and all of
its subobjects are trivially relocatable (or fully trivial), then the type
is trivially relocatable.

This approach is not prone to errors when compared to a class attribute,
which could be mistakenly overridden by some users on classes that are not
trivially relocatable.

Also, [[P1144R8]] does not account for relocate-only types. To some extend, trivially
relocatable types have minimal support as they could be trivially relocated in the
places where "move plus destroy" can be optimized. However:

- this only concerns trivially relocatable types ;
- there are places where the optimization cannot happen, and as such the object cannot be "relocated" ;
- this poses a composability issue. If a relocate-only (non-movable and non-copyable), trivially-relocatable type
    is a data member of a class that also has other non-trivially-relocatable data members, then the
    enclosing class becomes non trivially relocatable, while remaining relocate-only.
    This renders the enclosing class impractical to use without proper support
    for relocate-only types.

In this proposal we reuse [[P1144R8]]'s `std::relocate` function, except that we
name it `std::reloc_and_uninitialize`.

## P0023R0: Relocator: Efficiently moving objects by Denis Bider ## {#compare-P0023R0}

The Relocator introduced in [[P0023R0]] is similar to the proposed relocation constructor.
However P0023R0's Relocator is not viewed as a constructor. Instead, it is a special
function that can be invoked in lieu of move plus destroy where possible.

However this brings again suboptimal support for relocate-only types. Indeed [[P0023R0]]
does not force relocation to happen in all cases, and falls back to move+destroy paradigm
when relocation cannot happen.

A typical example is when relocating a function parameter:

```c++
void sink(T);
void foo(T x) { sink(x); }
```

Here, under the terms of [[P0023R0]], relocation may not happen because of ABI
constraints (if `x` is an unowned parameter).
This will cause `foo` to fallback to a move+deferred detroy paradigm.

This proposal has another take on this issue: if `T` has a relocation constructor
but no move constructor, then any function
that takes a `T` parameter by value is required to have an ABI that allows it to
relocate
its input parameter (e.g. callee-destroy ABI).

This proposal also introduces the `reloc` keyword that is here to trigger
the relocation, and protect against the reuse of the relocated object.
The solution then becomes:

```c++
void sink(T);
void foo(T x) { sink(reloc x); /* x can no longer be used. */ }
```

Moreover, the proposed syntax for invoking [[P0023R0]]'s relocator is low-level and
prone to error:

```c++
T x;
alignas(T) char buf[sizeof(T)];
T* y = new (buf) >>T(x);
```

Here the lifetime of `x` has been ended as if by a destructor call, but the language
is not aware of this,
so firstly the user may erreoneously refer to `x` as if it was within its lifetime,
and secondly if an object is not recreated in `x` by the time the block
exits, the behavior is undefined by <a href="https://eel.is/c++draft/basic.life#9">[basic.life]/9</a>.
Likewise, the language is not aware of the existence of `*y` so will not call its
destructor; the behavior is then possibly undefined under <a href="https://eel.is/c++draft/basic.life#5">[basic.life]/5</a>.
In contrast, the present proposal would write the above as:

```c++
T x;
T y = reloc x;
```

Here the use of the `reloc` keyword ensures that the language is aware that the lifetime
of `x` has finished, so the destructor only of `y` is called at scope exit.

## N4158: Destructive Move by Pablo Halpern ## {#compare-N4158}

[[N4158]] proposes a customizable function `std::uninitialized_destructive_move`,
that is somewhat similar to the relocation constructor, but is a pure library solution.

It has several drawbacks :

- relocation can only happen if this function is called explicitly. Typically this function
    would be called in container implementation. But then we cannot relocate
    local variables with this.
- users can write their own `uninitialized_destructive_move` overload, but this
    is terrible for composability. Classes that have a subobject with a
    custom `uninitialized_destructive_move` overload do not get a
    `uninitialized_destructive_move` overload generated for free.
- `uninitialized_destructive_move` cannot be default-generated with memberwise
    relocation.

## P1029R3: move = bitcopies by Niall Douglas ## {#compare-P1029R3}

[[P1029R3]] enables a special bitcopies move constructor for types that are trivially relocatable.

Like the other proposals [[P1029R3]] does not provide support for relocate-only types
(it suffers from the same drawbacks as [[P1144R8]] in that regard).

## P0308R0: Valueless Variants Considered Harmful by Peter Dimov ## {#compare-P0308R0}

We only consider the "pilfering" proposition from [[P0308R0]].
P0308R0's pilfering shares some similarities with the current proposal,
as it is an attempt to support relocate-only types as a pure library solution.

We believe a language solution is best suited here:

- the source object is effectively destroyed by the relocation: its destructor
    is not called. This can hardly be achieved by a library solution ;
- the `reloc` keyword makes sure the relocated object is not reused,
    while `std::pilfer` does not ;
- the pilfering constructor is inconvenient to write as we need to unwrap from
    `std::pilfered` and rewrap to propagate to base classes and data members ;
- as a library solution, the pilfering constructor cannot be defaulted ;
- trivial relocation is not possible with pilfering, which makes [[P0308R0]] miss
    the performance boost that is so longed for.

## D2839R1: Nontrivial Relocation via a New *owning reference* Type by Brian Bi and Joshua Berne ## {#compare-D2839}

[[D2839R1]] is very close in spirit and mechanism to this paper. We consider the
addition of an "owning reference" to be an unnecessary complication to the type
system that would impose a burden throughout library code. We refute the claim
that a prvalue occupying storage constitutes a fourth value category; in our
model, the lvalue that previously occupied that storage ceases to exist and a
new prvalue is formed, which may come to occupy that storage (if relocation is
elided) or distinct storage (in the general case).

We are intrigued by the claim that an owning reference can provide superior
performance when passing a variable up the stack, compared to repeatedly relocating
it from caller to callee, but believe that in practice such gains would be minimal
and liable to be eliminated via optimization, while our model offers the possibility
of improved locality, since the relocated object will reside directly in the leafmost
function's stack as opposed to being accessible only via indirection.

Otherwise, the paper has some minor differences in naming (e.g. `std::force_relocate`
for what we call `std::reloc_and_uninitialize`) that could easily be reconciled in either
direction.

# Proposed language changes # {#lg-changes}

## reloc operator ## {#reloc-operator}

This paper suggests to introduce a new keyword, named `reloc`. `reloc` acts as a
unary operator that can be applied to named, local, complete objects (in other
words: function-local non-static variables and, with some restrictions,
function parameters and
identifiers introduced through the syntax of structured binding declarations).

`reloc obj` does the following:

- if `obj` is ref-qualified, then performs perfect-forwarding
    (as if by `static_cast<decltype(obj)>(obj)`) ;
- otherwise returns a temporary obtained from the source object, constructed
    from the relocation, move or copy constructor. At the end of the
    full-expression, the source object is in a *destructed state* or a
    "*pending-destruction*" state ;
- in all cases, marks the "early" end-of-scope of the variable `obj`, preventing
    reuses of the variable.

### reloc to perfectly forward all value categories ### {#reloc-perfect-fwd}

`reloc` can be used on ref-qualified objects to enable perfect forwarding.
If the source object is ref-qualified, then it performs the following cast:
`static_cast<decltype(obj)>(obj)`.

This makes `reloc` the one operator to use to perfectly forward objects, whether
they are ref-qualified or not.
It also prevents from use-after-move and use-after-relocation errors.

### reloc in constexpr ### {#reloc-constexpr}

`reloc` can be used in constexpr functions and constant-evaluated expressions.

### reloc returns a temporary ### {#reloc-value-change}

Unlike `std::move`, `reloc` does perform some form of relocation.
Through misuse of language, we say that `reloc` returns a temporary object,
created by relocation, move or copy constructor. In truth,
given that the source object is not ref-qualified, `reloc` merely
changes the value category of the source object from lvalue to prvalue
(if the source object is ref-qualified, see [above](#reloc-perfect-fwd)).

It is this value category change that *may* trigger the creation of a temporary
object. However, optimizations may happen that will elide the creation of the
temporary entirely.

If the temporary is materialized, then it is ideally constructed by the relocation
constructor, destroying the source object in the process. However, `reloc` does
not force the use of the relocation constructor. The constructor which will be used
to create the temporary is selected by overload resolution. `reloc` merely enables
the relocation constructor to be selected because of the value category change
(the relocation constructor has the signature `T(T)`, meaning it will be preferred
when constructed from a prvalue, with our new [overload resolution rules](#overload-resolution)).

### Relocation constructor discardment with function parameters ### {#reloc-with-function-param}

Function parameters' lifetime ownership is implementation-defined in C++.
Depending on the ABI in use, a function parameter may be destroyed at caller-site
(upon function return, at the end of the full-expression evaluation),
or at callee-site (before the function exits).

Enforcing the relocation constructor when `reloc` is used on a function
parameter, which would effectively destroy the function parameter,
will not be compatible with all existing ABIs (see Itanium ABI for
instance). We could propose this nonetheless, by stating that the relocation
constructor must be used if declared.
However we fear this would propagate ABI changes with too little control
and the proposal would meet to much resistance to go further.

We could take a very conservative approach, and mandate the ABI change
for *relocate-only* value parameters. Such types don't exist today, so the
likelihood of breaking any existing ABI is relatively small. However this may
lead to suboptimized code, where `reloc` would perform worse than move semantics.
Consider now the following code:


<table>
<tr><th>With move semantics</th><th>With relocation</th></tr>
<tr>
<td valign="top">
```c++
struct A
{
    // [...]
    A(A const&) = default;
    A(A&&) = default;
};

void bar(A);
void foo(A a)
{
    bar(std::move(a));
}
```
</td>
<td valign="top">
```c++
struct A
{
    // [...]
    A(A const&) = default;
    A(A&&) = delete;
    A(A) = default;
};

void bar(A);
void foo(A a)
{
    bar(reloc a);
}
```
</td>
</tr>
</table>

Since `A` has a copy constructor, it is not relocate-only. With the conservative
approach, we have no guarantee
that `foo` has the ownership of `a`. Hence `reloc a` here may simply call the copy
constructor, as the ABI may not permit otherwise.

To prevent such a pessimization, developers will be tempted to add a move constructor
to `A`, ensuring that at least the move constructor is called in such cases.
Doing so goes against what we are trying to achieve with this proposal. One
of our main motivation points is that the move constructor doesn't fit all classes
that could yet still be moved. We don't want users to declare one anyway
to avoid pitfalls.

Thus in an attempt to make a compromise between ABI compatibility and acceptable
support for relocation, we take a slightly less conservative approach.
We would like function parameters passed by value, whose type declares
a relocation constructor but no move constructor, to be *owned parameters*.
As the C++ standard leaves this area implementation-defined, we are going to force
this another way, although the effect will likely be the same:

**Rule:** If the source object is a function parameter passed by value, and its type
provides an eligible move constructor, then the relocation constructor (if any)
may be discarded during overload resolution. Whether the relocation constructor
is discarded is *implementation-defined*.

Note: *eligible* is defined in
<a href="http://wg21.link/special#def:special_member_function,eligible">[special]</a>.

As consequences of that rule, we get the following:

- source objects which are not function parameters are always guaranteed that
    their relocation constructor (if eligible) is called ;
- source objects which are *owned parameters* have the same guarantee as above ;
- source objects which are *unowned parameters*, and have both an eligible move
    and relocation constructor, will not be relocated. Instead the move constructor
    will be used by `reloc`.
- source objects which are function parameters, and have an eligible relocation
    constructor but no move constructor, are forcibly *owned parameters*.

NOTE: Types which have a relocation constructor but no move constructor
still don't exist today, so the likelihood of breaking existing ABIs is still
small.

With this updated rule, `reloc a` from our previous example will effectively
call the relocation constructor. And users can safely migrate from the move
constructor to the relocation constructor if they wish to without any gotchas.

Note that this rule is still isn't optimal. Consider the following code,
having in mind a putative `std::pair` with a relocation constructor:

```c++
void bar(pair<const string, int>);

void foo(pair<const string, int> val)
{
    val.second *= 2;
    bar(reloc val);
}
```

`val` has the three constructors, so our rule does not apply. The ownership
of `val` by `foo` is implementation-defined. If `foo` doesn't own `val`, then
`reloc val` will call the move constructor, making a full string copy
(because of `const`). Contrary to our previous example which motivated us to
update the parameter ownership rule,
here `reloc` may call `std::move` so we haven't worsened the situation.

### Early end of scope ### {#reloc-src-obj-lifetime}

As we have seen `reloc` may trigger a call to the relocation constructor.
At the moment of the call, the source object is in a destructed state.
Thus it is unsafe to reuse it after the `reloc` expression completes.

To prevent uses of a potentially destructed object, we state that the program is
**ill-formed** if the source object is reused after being passed to `reloc`,
regardless of whether the relocation constructor was called. For a detailed
explanation of how this is enforced, please refer to [the dedicated section](#ill-formed-reuse).

NOTE: The rest of this section only applies to `reloc` operands that are
not ref-qualified.

That early end of scope provides us with a strong guarantee. We know that the
source object cannot be reused, and as such we may be tempted to call the
destructor of the source object early (in cases where the relocation constructor
was not selected). For instance, we may want to destroy the
source object at the end of the full-expression evaluation, when temporaries are
destroyed. It would be the natural thing to do:

- for consistency, if the object had been relocated (with the relocation constructor),
    then it already reached its end of life. The same could be expected for
    copy and move constructor ;
- the source object cannot be reused anyway, why defer its destruction?

Unfortunately, this cannot be done without breaking some ABIs. If the source
object is an *unowned parameter*, then the function cannot destroy it early.
The problem does not happen if the source object is a function-local variable
or an *owned parameter*.
Let us see what happens if we allow the early destruction of function parameters
to be *implementation-defined*:

- If `reloc` calls the copy constructor:
    all the resources owned by the source object are *copied* to the target object.
    As such if the destructor has side-effects, they may be applied twice, once
    for the destruction of each object. Depending on the ABI, the destructor
    of the source object may be called at the end of full-expression, or deferred
    until control returns to the caller.
    We can see that the destruction time of the source object would be
    *implementation-defined* (as of today). Remember that we might have side-effects from the
    destructor, so the moment those side-effects will be applied will also
    be *implementation-defined*.
- If `reloc` calls the move constructor:
    all the resources owned by the source object are *transferred* to the target
    object. As such if the destructor has side-effects, we expect them to be
    applied only once, at the destruction of the target object. We expect the
    source object destructor to detect the *moved-from state* and return, without
    triggering any side-effects.
    Under those reasonably safe assumptions, it doesn't matter when the source
    object is destroyed, be it at its natural end of scope, or at the end of the
    `reloc` expression.

As of today, the lifetime of function parameters is already *implementation-defined*.
As such, code that relies on the timing of a destructor side-effects of a
function parameter is already *implementation-defined*.
We don't feel we will worsen the
situation with `reloc`, even with copy-only source objects.
We prefer to keep this behavior implementation-defined, same as
today, except that the source object may also be destructed early, at the end
of the full-expression evaluation that contained `reloc`.

In conclusion, we establish the following rules when a `reloc` expression
is evaluated:

- **Rule:** If the source object passed to `reloc` is not a function parameter, and
    the source object has not been relocated by its relocation constructor, then
    its lifetime ends (i.e. its destructor is called) at the end of the
    full-expression evaluation containing `reloc`.
- **Rule:** If the source object passed to `reloc` is a function parameter, and
    the source object has not been relocated by its relocation constructor, then
    its destructor may be called at the end of the full-expression
    containing the evaluated `reloc` expression, upon function exit,
    or at the caller site at the end of the
    full-expression evaluation. Which it is is *implementation-defined*.

We acknowledge that with `reloc` expressions we allow for more code to be executed between
the end of the full-expression which contained `reloc`,
and when control returns to the caller site.
One might argue that we exacerbate this destruction time discrepancy between
implementations. However please keep in mind that:

- this only concerns copy-only value parameters, whose destructor have a side-effect, and
    are passed to `reloc` ;
- any arbitrary amount of code could still be executed today upon function exit,
    at the end of the full-expression evaluation that made the function call,
    at caller-site. Indeed, all function parameters need to be destructed,
    and their destruction order remains *implementation-defined* as of today,
    leaving the door open for any arbitrary code from a destructor,
    to be executed before the destructor of our source object ;
- code that relies on a precise destruction timing of a function parameter is
    poor code as this timing is implementation-defined, even today.

### Illegal uses of reloc ### {#reloc-illegal-uses}

A `reloc` statement is ill-formed if any of the following conditions is met:

- its parameter is not the name of a variable ;
- the source object is not a *complete object* ;
- the source object is not ref-qualified and does not have local storage
    (i.e. not a local function variable and not a function parameter passed by
    value) ;
- the source object is not ref-qualified and does not have an accessible relocation,
    move, or copy constructor ;
- the source object is a structured binding (and not an identifier introduced in a
    <a href="#structured-reloc">structured relocation declaration</a>) ;
- the source object is a lambda capture ;
- the source object is the first parameter of the relocation constructor
    (only applicable in a [user-provided relocation constructor](#reloc-ctor-delegate)) ;

In particular, the `reloc` statement is well-formed if the source object is a
member of a function-local anonymous union.

For instance:
```cpp
void foo(std::string str);
std::string get_string();
std::pair<std::string, std::string> get_strings();

std::string gStr = "static string";

void bar(void)
{
	std::string str = "test string";
	foo(reloc str); // OK: relocation will happen given that std::string has a reloc ctor
	foo(reloc gStr); // ill-formed: gStr does not have local storage

	std::pair p{std::string{}, std::string{}};
	foo(reloc p.first); // ill-formed: p.first is not a complete object, and not the name of variable

	foo(reloc get_string()); // ill-formed: not the name of variable
	foo(reloc get_strings().first); // ill-formed: not a complete object, and not the name of variable
}

void foobar(const std::string& str)
{
	foo(reloc str); // OK: str is passed by reference.
	// Note that the lifetime of the referent of str is unaffected.
}
void foobar(std::string* str)
{
	foo(reloc *str); // ill-formed: *str is not the name of variable
}
void foobar2(std::string* str)
{
	foobar(reloc str); // OK, the pointer itself is relocated (not the pointed value)
}

class A
{
	std::string _str;
public:
	void bar()
	{
		foo(reloc _str); // ill-formed: _str is not a complete object and does not have local storage
	}
};
```

### Relocation elision ### {#reloc-elision}

Whether performed by relocation, move or copy constructor, relocation
may be elided if the compiler can ensure that the source object is created at
the address to be occupied by the target object.
This is intended to work in much the same way as the named return value optimization;
for example:

```c+
void f(std::string s);
void g() {
    std::string s;  // may be created in f's argument slot
    f(reloc s);  // relocation may be elided
}
```

### Discarded reloc expressions ### {#discarded-reloc-expr}

`reloc` expressions can be discarded: `reloc obj;` (note the semi-colon).
We expect this statement to have the same effect as ` { auto _ = reloc obj; } `.
A temporary is constructed from the source object and is then destructed at scope
exit (that is right-away). The source object is destructed right-away,
or at later stage if it's a function parameter (*implementation-defined*).
We will discuss here the effects of such expressions.

Materializing a temporary whose only goal is to be
destroyed is suboptimal.
We might be tempted to optimize away the temporary
materialization, and only call the destructor of the source object.

This optimization is authorized (whether it is performed is *implementation-defined*).
If the optimization does not happen, then
the temporary must be materialized and destroyed at the end of full-expression
evaluation. The lifetime of the source object follows
[the established rules](#reloc-src-obj-lifetime).

Note that, if the temporary is materialized and that the source object:

1. *has an eligible relocation or move constructor*: In this case,
    all the owned
    resources of the source object will be *transferred* to the temporary. For this
    reason, we expect that destroying the temporary *will have the same effects
    as* destroying the source object directly.
2. *only has an eligible copy constructor*:
    all the owned resources of the source object will be *copied* to the temporary.
    This is very likely a useless operation.
3. Other cases need not to be considered, as the `reloc` expression requires the
    source object to declare one of the three constructors.

NOTE: If the source object is a copy-only function parameter, then implementations
are encouraged to emit a warning on discarded reloc statements, as if `reloc`
had the `[[nodiscard]]` attribute. This is because the intent of this statement
is likely to trigger the destruction of the source object (or to trigger the
effect of the destructor, if a move-constructed temporary is materialized and
destroyed). But whether this statement indeed calls a destructor early
(or has any side-effect) for copy-only function parameters is
*implementation-defined*.

To summarize, it means that `reloc obj;` has the following behavior:

- If `obj` is an *owned parameter* or a function-local variable then:
    - The temporary is likely elided, effectively only calling the
        destructor of `obj`.
    - Otherwise a temporary is initialized from the
        source object, and then destructed.
- Otherwise (`obj` is an *unowned parameter*):
    - A temporary is move-or-copy-constructed and then destructed.
    - The source object destruction is deferred until the function returns.

For instance this gives:
```c++
void do_something_01(std::mutex& m)
{
    std::lock_guard guard{m};
    if (!some_test())
    {
        reloc guard; // ill-formed: no relocation, move or copy constructor
        log("thread ", std::this_thread::get_id(), " failed");
        return;
    }
    bar();
}
void do_something_02(std::unique_lock<std::mutex> guard)
{
    if (!some_test())
    {
        reloc guard; /* well-formed: lock is released, either by calling the
            destructor directly, or by constructing a temporary from
            guard (by relocation or move) and destructing it. */
        log("thread ", std::this_thread::get_id(), " failed");
        return;
    }
    bar();
}
void do_something_03(std::mutex& m)
{
    std::unique_lock guard{m};
    if (!some_test())
    {
        reloc guard; /* well-formed: temporary is likely elided regardless of
            do_something_03's ABI, only calling the destructor of guard. */
        log("thread ", std::this_thread::get_id(), " failed");
        return;
    }
    bar();
    /* guard destructor is called only if it wasn't passed to reloc. */
}
// assuming non_null does not have a relocation constructor
void do_something_04(non_null<shared_ptr<int>> copyOnlyObj)
{
    if (!some_test())
    {
        reloc copyOnlyObj; /* well-formed but its effects are implementation
            defined. Will emit a warning. */
        return;
    }
    bar();
}
```

## Decomposing operator (dot reloc) ## {#dot-reloc-operator}

In addition to the `reloc` operator, this paper introduces the *dot-reloc* (`.reloc`)
operator, which can be used to **decompose** a source object and **relocate its
subobjects**. The *dot-reloc* is necessary to allow user-defined relocation
constructors and relocation assignment operators that look similar to their copy
and move counterparts.

### dot-reloc expression ### {#dot-reloc-syntax}

The *dot-reloc* operator is a binary operator.
Both operands must be id-expressions separated by `.` and `reloc`.
Its left operand is the source
object to decompose, and its right operand is the subobject to relocate.

Let `T` be the type of the left operand.
The left operand must verify all the following:

- the id-expression must designate a function-local variable
    (can be a function parameter passed by value) ;
- it must be a complete object ;
- it must not be a lambda
    capture, a structured binding, or a subobject promoted to a complete object
    because of a previous decomposition ([see below](#decomposed-state)) ;
- `T` must be a non-union class-type ;
- `T` must not be ref-qualified ;
- `T` must not be not an array-type.
- `T` may be cv-qualified ;

The right operand is an id-expression which must designate either:
- *data member relocation case*: a non-static data member of a class `X`,
    with `X` being `T` or a non-virtual base of `T`. In particular, the
    expression may designate a data member of an anonymous union of `X` ;
- *base class relocation case*: a class-type `X` which is a non-virtual base of `T` ;
- In both cases, if `X` is not a direct base of `T`, then there must not be any
    virtual base on the inheritance path from `T` to `X`.

For instance:
```c++
void foo(pair<string const, non_null<unique_ptr<int>>> p)
{
    bar(p.reloc first, p.reloc second);
}
```

If any of the requirements on any operand is not satisfied, then the program is ill-formed.

The result of the *dot-reloc* expression is:
- an lvalue of the type of its right operand in the *data member relocation case*
    and if said data member is ref-qualified ;
- a prvalue of the type of its right operand otherwise.

The effect of the *dot-reloc* operator is twofold:

1. If not already decomposed, then `src` (along with base classes up to the base
    class which holds the subobject to relocate) [transitions into its decomposed state](#decomposed-state) ;
2. Triggers the relocation of the said subobject, as if done by the `reloc`
    operator on any complete object.

#### Pointer to members with dot-reloc #### {#dot-reloc-star}

*dot-reloc* expressions can be used with pointer-to-members:

- the `.reloc*` operator must be used as a natural mix of `.*` and `.reloc` operators ;
- the right operand must be a pointer to data member, and not a pointer to
    a member function ;
- the right operand must be constant-evaluated ;
- the left operand has the same constraints as in the *dot-reloc* expression ;
- once the right operand has been resolved at compile-time to the data member to relocate,
    the *dot-reloc-star* expression has the exact same effects as the *dot-reloc* expression.

```c++
template <auto Member, class Pair>
auto GetMember(Pair pair)
{
    return pair.reloc *Member;
}

void foo()
{
    using pair_t = pair<string const, non_null<unique_ptr<int>>>;
    pair_t const p = // ...
    auto const p_second = GetMember<&pair_t::second>(reloc p);
}
```

NOTE: As the *dot-reloc-star* operator can be expressed at compile-time
in term of a *dot-reloc* operator, the remainder of this proposal will only
address the *dot-reloc* operator (which encompasses the *dot-reloc-star*
operator).

### Decomposed state transition ### {#decomposed-state}

When a complete object enters its decomposed state:

- All its direct bases and non-static data members are now considered as
    distinct complete objects:
    - the decomposition does not odr-use any of the copy, move or relocation
        constructor of the subobjects. In particular, their address remains unchanged ;
    - the introduced objects **have the same scope as the source object**,
        even if the *dot-reloc* expression was used in a nested scope ;
    - the introduced objects are still restrained by the cv-qualifiers,
        if any, of the source object ;
    - if any of the direct base had a runtime type information, it now points
        to that of the base class, and no longer points to the type of the source
        object.
    - all virtual bases, if any, keep the same address ; all pointers to such
        virtual bases remain unchanged.
- *The lifetime of the source object ends*, its destructor is never called.
    All its non-static subobjects, now considered as complete objects, are still
    alive and will
    follow normal destruction rules: they will be destructed at the end of their
    scope (which is the source object scope)
    unless they have been relocated before.

Note: If not for changing the runtime type of the direct bases that have one,
the decomposition operation would be a no-op.

#### Incurred decompositions #### {#incurred-decomposition}

The source object is decomposed using the [steps described above](#decomposed-state).
However extra decompositions may occur, depending on the subobject that is
being relocated.

##### Base class relocation case ##### {#incurred-decomposition-base-class}

If `X` is not a direct base of `T`, then let `U` be the direct base of `T`
which is on the inheritance path from `T` to `X`.

`U` is decomposed as well (it is considered as the source object
being decomposed in the [steps described above](#decomposed-state)). This step occurs recursively and stops
when all classes on the inheritance path from `T` to `X` are decomposed,
but `X` itself is not decomposed.

Note: Relocating a virtual base is ill-formed. Instead virtual bases must be moved
thanks to their move constructor. The reason behind this is that, because of the
decomposition, we may have some source subobjects that still point to virtual
bases, and we still want them to point to valid data
(albeit potentially in a moved-from state).

##### Data member relocation case ##### {#incurred-decomposition-data-member}

If `X` is not `T` then all classes on the inheritance path from `T` to `X`
are decomposed, including `X` itself, starting with the most derived classes.

### Illegal uses of dot-reloc ### {#ill-formed-dot-reloc}

An expression using the *dot-reloc* operator is ill-formed
if any of the following conditions is met:

- any of [the requirements on any operand](#dot-reloc-syntax) is not satisfied ;
- any of the incurred decompositions is illegal.
    See [below](#ill-formed-decomposition) ;
- the relocation operation on the subobject is ill-formed.
    See [below](#ill-formed-dot-reloc-relocation).

#### Illegal decomposition #### {#ill-formed-decomposition}

A decomposition is ill-formed if any of the following conditions
is not satisfied:

- all subobjects of the source object are accessible. They all need to be since their
    destructor will be called if not relocated ;
- the source object type has no user-defined special member function,
    **or** the call-site has private access privilege to the source object type

These requirements ensure that we can only relocate (a) compound types,
where subobjects have no dependencies with one another (like an `std::pair`),
or (b) types that we are in control of (because of the private access).

#### Illegal relocation #### {#ill-formed-dot-reloc-relocation}

The *dot-reloc* expression in the *base class relocation case* is ill-formed
if `X` does not have an eligible relocation, move or copy constructor.

The *dot-reloc* expression in the *data member relocation case* is ill-formed
if the data member type is not ref-qualified and does not have an eligible
relocation, move or copy constructor.

### Illegal uses of a decomposed object ### {#ill-formed-decomposed-object-uses}

When an object transitions into its decomposed state, it reaches its
end of scope. The object itself cannot be reused,
and its member functions can no longer be called.
However all its non-relocated subobjects,
now considered as individual complete objects, are alive and they can be accessed
normally.

We do not propose any special syntax to access such objects. Instead we restrict
the expressions in which a decomposed object can be used.
The *id-expression* which designates the decomposed
object is **ill-formed**, unless it is used with the following expressions
(and only those):

#### Data member access #### {#ill-formed-decomposed-object-dm}

All the expressions listed under [class member access](https://eel.is/c++draft/expr.ref) (but [7.3.2](https://eel.is/c++draft/expr.ref#7.3.2))
where the decomposed object is the [object expression](https://eel.is/c++draft/expr.ref#4.sentence-1),
remain well-formed.

Non-static member function expressions [[7.3.2](https://eel.is/c++draft/expr.ref#7.3.2)],
where the function is declared in class-type `X`
and that `X` subobject has been decomposed, are ill-formed.
If `X` is not decomposed, then the expression is valid.

NOTE: Accesses to relocated subobjects are ill-formed as well, although this is
not enforced by the rules of this section. [Read more](#ill-formed-reuse).

```c++
struct B { int _b; void b_func(); };
struct C : B { int _c; void c_func(); };
struct D : C { int _d; void d_func(); };

D obj;
foo(obj.reloc _c); // decomposes D and C
// - `obj`, `(C&)obj`, `obj.d_func` and `obj.c_func` are now
//      ill-formed expressions because of the decomposition
// - `obj._c` is ill-formed because of the relocation
// - `(B&)obj`, `obj.b_func`, `obj._b` and `obj._d` are still
//      well-formed expressions
```

#### Pointer to members #### {#ill-formed-decomposed-object-pm}

All the expressions listed under [pointer-to-member operators](https://eel.is/c++draft/expr.mptr.oper)
where the decomposed object is the [object expression](https://eel.is/c++draft/expr.mptr.oper#4.sentence-1),
remain well-formed under conditions.

The right operand of the `.*` operator must be constant-evaluated. In addition:

- If the result of the expression is a member function, where the function is
    declared in class-type `X` and that `X` subobject has been decomposed, then
    the expression is ill-formed. If `X` is not decomposed, then the expression is valid.
- If the result of the expression is an object, then the expression is well-formed.

NOTE: Again, accesses to relocated subobjects are ill-formed. The main reason
why the right operand must be constant-evaluated is to allow for better tracking
of data members and their relocation state. [Read more](#ill-formed-reuse).

#### Explicit cast to base classes #### {#ill-formed-decomposed-object-bc}

`static_cast<D>(v)`, `const_cast<D>(v)`, `dynamic_cast<D>(v)` and explicit type
conversion `(D) v` expressions, where `v` is the *id-expression* which
designates the decomposed object, remain well-formed under the following
conditions:

- `D` is a possibly ref-qualified, possibly cv-qualified base of `T` (the type of `v`), and
- the `D` part of `v` has not been decomposed.

The cast expression evaluation and return value do not change.

`reinterpret_cast<D>(v)` expressions remain well-formed.

```c++
struct B { int _b; void b_func(); };
struct C : B { int _c; void c_func(); };
struct D : C { int _d; void d_func(); };

D obj, obj2;
foo(obj.reloc _c, obj2.reloc C); // decomposes D and C
// - `obj`, `(C&)obj` are now ill-formed expressions because of the
//      decomposition
// - `(B)obj`, `static_cast<B const&>(obj)`, `const_cast<B&>(obj)`
//      are still well-formed expressions
// - `(C&)obj2`, `(B&)obj2` are ill-formed because of the relocation
```

#### Further dot-reloc expressions #### {#ill-formed-decomposed-object-dr}

Further *dot-reloc* expressions, with the decomposed object as left operand,
remain well-formed given that the right operand has not been relocated yet.

### Decomposition of a lambda closure type ### {#decompose-lambda}

Lambda objects can be decomposed with the rules defined above. The subobjects
of the closure type are all the lambda captures which are captured by copy.
The decomposition can only happen from the lambda body and not from outside
the lambda, as if its captures had private access.

The following is well-formed:

```c++
non_null<unique_ptr<int>> ptr;
auto const getPtr = [p = reloc ptr](this auto self)
{
    return self.reloc p;
};
auto ptr2 = (reloc getPtr)();
```
But this is ill-formed:
```c++
non_null<unique_ptr<int>> ptr;
auto const getPtr = [p = reloc ptr](this auto self)
{
    return self.reloc p;
};
auto ptr2 = getPtr.reloc p; // ill-formed, no access privilege to the captures
```

### Implicit decomposition of temporaries ### {#decompose-tmp}

Temporary objects can be implicitly decomposed to allow relocations in the following
scenarios (but non exclusively):

```c++
struct D : public B {};
D getD();
std::pair<std::string, std::string> getPair();

B b = getD(); /* under conditions, equivalent to:
    auto d = getD(); B b = d.reloc B; */
std::string s = getPair().first; /* under conditions, equivalent to:
    auto pair = getPair(); std::string s = pair.reloc first; */
```

Inspired by [[class.temporary](https://eel.is/c++draft/class.temporary#6.sentence-2)]
we add a clause to when a subobject of a temporary is to be converted to a
prvalue (for instance because passed to the relocation constructor or relocation
assignment operator).

In all the expressions listed in [6](https://eel.is/c++draft/class.temporary#6.sentence-2),
but [6.3](https://eel.is/c++draft/class.temporary#6.3) and
[6.5](https://eel.is/c++draft/class.temporary#6.5) if the pointer
cannot be evaluated at compile-time, the resulting expression can be converted
to a prvalue with *implicit decomposition*.

If the *implicit decomposition* is illegal, then it does not cause the program
to be ill-formed, the expression simply cannot be converted
to a prvalue (e.g. any relocation constructor or assignment operator are
discarded from overload resolution).

The *implicit decomposition* materializes the temporary complete object, and
recursively uses the *dot-reloc* operator to extract the desired subobject.

All the incurred *dot-reloc* expressions must be legal, as defined
[here](#ill-formed-decomposition), or else the *implicit decomposition* is
illegal. In particular, if any virtual base is used as right operand of
*dot-reloc*, then the *implicit decomposition* is illegal.

For instance:
```c++
class T
{
public:
    std::string _pub;
private:
    std::string _priv;
};
class U
{
public:
    std::string _pub[5];
};

T getT();
U getU();

std::pair<std::string, std::string> getPair();


std::string a = getT()._pub; /* implicit-decomposition is ill-formed
    because T has a private member, move constructor is used */
std::string b = getU()._pub[2]; /* implicit-decomposition is ill-formed
    as dot-reloc cannot be used on array elements, move constructor is used */
std::string c = getPair().second; /* implicit-decomposition is well-formed
    std::string's relocation constructor is used */
```

### Decomposition of value parameters ### {#decompose-value-param}

As we have seen, decomposition ends the lifetime of the source object.
The reader may be concerned that this may break existing ABIs, should the source
object be a function parameter passed by value.
However we do not foresee any extra breakage other than what the support for
`reloc` does.

Indeed, if the source object is an *unowned parameter*, and that
the function body uses the *dot-reloc* operator on it, then the function
may silently relocate its argument to some local storage before the function
body is entered. *This is a putative
workaround and is not part of the proposal.*

For instance:

<table>
<tr><th>User-written code</th><th>Putative equivalent generated code</th></tr>
<tr>
<td valign="top"><pre lang="cpp">
void foo01(T obj)
{
    // ...
    sink(obj.reloc m);
    // ...
}
</pre></td>
<td valign="top"><pre lang="cpp">
void foo01(T __obj)
{
    auto obj{reloc __obj};
    // ...
    sink(obj.reloc m)
    // ...
}
</pre></td>
</tr>
<tr>
<td valign="top"><pre lang="cpp">
void foo02(T obj)
{
    // ...
    if (test())
    {
        sink(obj.reloc m);
    }
    // ...
}
</pre></td>
<td valign="top"><pre lang="cpp">
void foo02(T __obj)
{
    auto obj{reloc __obj};
    // ...
    if (test())
    {
        sink(obj.reloc m);
    }
    // ...
}
</pre></td>
</tr>
<tr>
<td valign="top"><pre lang="cpp">
void foo03(T obj) try
{
    // ...
    if (test())
    {
        sink(obj.reloc m);
    }
    // ...
}
catch (...) {}
</pre></td>
<td valign="top"><pre lang="cpp">
void foo03(T __obj) try
{
    auto obj{reloc __obj};
    // ...
    if (test())
    {
        sink(obj.reloc m);
    }
    // ...
}
catch (...) {}
</pre></td>
</tr>
</table>

### dot-reloc in constexpr ### {#dot-reloc-constexpr}

As with `reloc`, *dot-reloc* can be used in constexpr functions and
constant-evaluated expressions.

### Examples ### {#decomposed-object-examples}

#### Nominal case #### {#decomposed-object-ex-nominal}

One of the main uses of *dot-reloc* is to decompose compound types, such as
`std::pair`. Note that this code would not be feasible without relocation and
without decomposition.

```c++
void bar(string, non_null<unique_ptr<int>>);

void foo(pair<string const, non_null<unique_ptr<int>>> p)
{
    bar(p.reloc first, p.reloc second);
}
```

#### Custom extractor #### {#decomposed-object-ex-extractor}

```c++
class T
{
private:
    string const _key;
    non_null<unique_ptr<int>> _val;

public:
    // [...]
    non_null<unique_ptr<int>> getVal(this T self)
    {
        return self.reloc _val;
        // note that here the destructor of self is not called.
        // however every non relocated data member is still destructed
        // so self._key.~string() is called at function exit.
    }
};
```

This code may be invoked in the following situations:
```c++
// with: T getT();
//       T src;

auto val1 = getT().getVal();
auto val2 = (reloc src).getVal();
```

#### Putative std::unique_ptr::release #### {#decomposed-object-putative-release}

```c++
template <class T, class Deleter>
class unique_ptr
{
// ...
public:
    T* release(this T self)
    {
        return self.reloc _ptr;
    }
};
```

Because of the decomposition, the destructor of `self` is not called. This code
safely releases the guarded pointer. Note that this function `release` function
is not part of the proposal.

#### Ill-formedness showcase #### {#decomposed-object-ex-ill-formed}

Let's consider the following classes:
```c++
struct VB
{
    string _vb;

    void vb_func();
};
struct VB2
{
    string _vb2;
};
struct B0 : public B0Iface
{
    string _b0;

    ~B0() override = default;
    void b0_vfunc() override;
};
struct B1 : public virtual VB
{
    string _b1;

    void b1_func();
};
struct B2Base
{
    string _b2base;
};
struct B2 : public B2Base, public virtual VB
{
    string _b2;

    virtual void b2_vfunc();
};
struct Iface
{
    virtual ~Iface() = default;
    virtual void iface_vfunc() = 0;
};

struct D : public virtual VB2, public B0, public B1, public B2, public Iface
{
    ~D() override = default;

    void d_func();

    void b0_vfunc() override;
    void b2_vfunc() override;
    void iface_vfunc() override;

    string _d;
    non_null<unique_ptr<int>> _d2;
};
```

Now let's see what happens when we decompose a `D` object:

```c++
D src;
// decomposition does not happen until the first dot-reloc
src.d_func(); // ok

bar(src.reloc _d2); // decomposition happens now
// B0 dynamic type is now B0
// Iface dynamic type is now Iface

/* The following expressions are now ill-formed:
  src;                            // `src` id-expression is ill-formed.
  auto cp = src;                  // `src` id-expression is ill-formed.
  auto* address = &src;           // `src` id-expression is ill-formed.
  src.d_func();                   // `src.d_func` expression is ill-formed.
  src.b0_vfunc();                 // `src.B0::b0_vfunc` would be well-formed.
  src.iface_vfunc();              // `src.iface_vfunc` expression is ill-formed.
  auto* address2 = src._d2.get(); // src._d2 has been relocated.
  auto vb2 = src.reloc VB2;       // cannot relocate virtual base.
  auto iface = src.reloc Iface;   // cannot relocate abstract base.
*/

// well-formed: access to non-relocated data members and bases is still allowed,
// or calling member functions from non-relocated bases is also allowed.
auto vb = src._vb;
auto vb2 = static_cast<VB2&&>(src);
auto b2base = static_cast<B2Base const&>(src);
auto d = src._d;
src.B2::b2_vfunc();

// triggers the decomposition of B0 base class:
auto b0 = src.reloc _b0;
/* The following expressions become ill-formed:
  static_cast<B0 const&>(src);
  src.b0_vfunc();
*/

// relocates base class
auto b2 = src.reloc B2;
/* The following expressions become ill-formed:
  static_cast<B2Base const&>(src);
  static_cast<B2 const&>(src);
  src._b2;
  src._b2base;
  src.B2::b2_vfunc();
*/

// Although B2 was relocated, we can still access its virtual base class:
vb = src._vb; // OK
```

## Ill-formed reuse of relocated or decomposed objects ## {#ill-formed-reuse}

### Variable state tracking ### {#variable-state-tracking}

The `reloc` and *dot-reloc* operators change the state of their operand, imposing
restrictions of how the variable can be used in the next expressions.

Let us formally introduce the new states a local variable can have:

- *alive* (**A**): this is the default state. As of today in C++, all variables are in this
    state.
- *relocated* (**R**): the variable was passed as operand to the `reloc` operator.
- *decomposed* (**D**): the variable was passed as left operand to the *dot-reloc* operator.

In addition, a variable may have any **OR**-combination of those three states:

- *alive-or-relocated* (**A-R**): the variable may be *relocated* or *alive*. For instance
    the variable will have this state at the end of an if statement,
    if the variable was *relocated* in one path and remained *alive* in the other.
- *alive-or-decomposed* (**A-D**): the variable may be *decomposed* or *alive*.
- *relocated-or-decomposed* (**R-D**): the variable may be *relocated* or *decomposed*,
    but not *alive*.
- *alive-or-relocated-or-decomposed* (**A-R-D**): the variable may be *relocated*, *decomposed*,
    or *alive*.

Those states are evaluated *at compile-time*, and their primary use is to verify
the well-formedness of expressions.

The state of a given variable (including function parameters) is evaluated as follows:

- The variable starts in the **A** state ;
- The state of the variable is tracked by *examining* expressions,
    from one expression to the next, following the evaluation order ;
- If two or more expressions have an unspecified evaluation order with one another, then:

    - expressions containing a `reloc` operator with the tracked variable as
        operand are examined first (in any order),
    - expressions containing a *dot-reloc* operator with the
        tracked variable as left operand are examined second (in any order),
    - and followed by the rest of the expressions in any order.

- In a `reloc` expression, if the variable used as operand is not **A**
    (prior to the expression examination), then the expression is ill-formed.
    Otherwise the variable transitions to the **R** state after the
    expression examination.
- In a *dot-reloc* expression, the state of variable used in the left operand
    must match **A-D**, and the base class or data member of the right operand
    must be **A**. If the right operand does not designate a subobject of the left
    operand (i.e. because it designates a subobject of a base class of the left operand),
    then all the intermediary base classes that lead to that subobject must
    match **A-D**. If any of those constraints is not verified (prior to the
    expression examination) then the expression is ill-formed.

    At the end of the expression examination, the left operand transitions to
    the **D** state. All its subobjects will be tracked separately in another
    pass of this algorithm. Any intermediary base classes which got decomposed
    also transitions to the **D** state and their subobjects will likewise need
    to be tracked. The subobject that was in the right operand starts in the
    **R** state. All the other introduced objects start in the **A** state.

    Note that the newly introduced objects, if they were non-static data
    members, cannot be decomposed so they may only have **A**, **R** or **A-R** states ;
- If the code path forks (for instance because of an if statement), then all the
    different code branches need to be examined. **Exception:** if it is known
    at compile-time that some code branches will never be evaluated (for
    instance because of an if constexpr statement), then the non-evaluated
    branches must not be examined.
- If two or more code paths rejoin, then the resulting state of the variable
    is the **OR**-combination of the state it had in all the joined code branches.
- In a [logical AND](https://eel.is/c++draft/expr.compound#expr.log.and) or
    [OR expression](https://eel.is/c++draft/expr.compound#expr.log.or), both
    operands are examined sequentially.
- On a code jump:

    - if the code jumps before the variable declaration or after the variable
        enclosing scope, then the state analysis for this code branch stops here
        for this variable.
    - otherwise the state of the variable after the jump is the **OR**-combination
        of the state it had before the jump, and the state it would have had at the
        destination code location without taking the jump.
        If the destination code location cannot be reached without jump, then
        the jump does not change the state the variable.
        The state of the variable prior to the jump is memorized for this code jump.
    - if a same code jump needs to be taken an extra time, then the state of the variable
        is compared to the one previously memorized. If they are identical then
        the state analysis for this code branch stops here for this variable.
        Otherwise the new state prior the jump is updated and the jump re-examined.

- In a try block, if the variable was declared before the block: at the end of
    an expression that may throw,
    a code jump to each catch block may be examined.
    This code jump is necessary:

    - if the state of the variable has changed prior to when the last jumps
        to the catch blocks were made.
    - or if no last jumps to catch blocks were made, then compare the state
        the variable had when entering the try block against the current state
        and perform the jumps if they differ.

- This state analysis stops until code reaches the natural end of scope of the
    variable.

NOTE: We don't expect this analysis to be costly. It is only necessary in functions
for the variables that are relocated or decomposed. If none of the two are used,
then this analysis is not needed.

### reloc and dot-reloc in unevaluated operands ### {#unevaluated-operands}

`reloc` or *dot-reloc* operators can be used in
[unevaluated operands](https://eel.is/c++draft/expr.context#1).
Such expressions are ignored by the code analysis described
[above](#variable-state-tracking).
If `reloc` or *dot-reloc* are used in an unevaluated operands,
then (a) their operands are always considered to have the *alive* state,
and (b) the state of their operands do not change.

For instance:
```c++
void foo(T x)
{
    decltype(reloc x) y = reloc x; // well-formed
    decltype(reloc x, x.reloc m) z = y.m; // well-formed
}
```

### Ill-formed expressions ### {#reloc-dot-reloc-ill-formed}

Thanks to this compile-time state analysis, new ill-formed conditions arise:

- If the variable potentially has the *relocated* state (i.e. the variable is
    **R**, **A-R**, **R-D** or **A-R-D**), then any potentially-evaluated
    expressions using the variable is ill-formed.
- If the variable potentially has the *decomposed* state, then the ill-formed
    conditions described [here](#ill-formed-decomposed-object-uses) apply in any
    potentially-evaluated expressions using the variable.

### Examples ### {#reloc-dot-reloc-ill-formed-showcase}

Consider the following examples:

```cpp
void reloc_showcase_01()
{
	const T var = getT();
	bar(reloc var);
	if (sometest(var)) // ill-formed: state of 'var' is relocated
		do_smth(var); // ill-formed: state of 'var' is relocated
}
```
`var` cannot be reused after the `reloc` call.
```cpp
void reloc_showcase_02()
{
	const T var;
	{
		const T var;
		bar(reloc var);
		do_smth(var); // ill-formed: state of 'var' is relocated
		{
			const T var;
			do_smth(var); // OK
		}
		do_smth(var); // ill-formed: state of 'var' is relocated
	}
	do_smth(var); // OK
}
```
The second and forth calls to `do_smth(var)` are allowed because the name `var`
does not resolve to the relocated object.
```cpp
void reloc_showcase_03()
{
	const T var = getT(); // var state is alive
	if (sometest(var)) // var state is alive
		bar(reloc var); // var state is relocated
	else
		do_smth(var); // var state is alive
	// var state is alive-or-relocated
}
```
`do_smth(var)` is allowed because the `else` branch is not affected by the
`reloc` call of the `if` branch.
```cpp
void reloc_showcase_04()
{
	const T var = getT();
	if (sometest(var))
		bar(reloc var);
	else
		do_smth(var); // OK
	// [...]
	do_smth_else(var); // ill-formed: state of 'var' is A-R
}
```
`do_smth_else(var)` is an error because `var` is mentioned after the `reloc` call.
```cpp
void reloc_showcase_05()
{
	const T var = getT();
	if (sometest(var))
		bar(reloc var);
	else
		do_smth(reloc var); // OK
    // var state is relocated
}
```
Both `reloc` are okay as they happen on different code paths.
```cpp
void reloc_showcase_06()
{
	const T var = getT();
	bool relocated = false;
	if (sometest(var))
	{
		bar(reloc var);
		relocated = true;
	}
	else
		do_smth(var); // OK
	// [...]
	if (!relocated)
		do_smth_else(var); // ill-formed: state of 'var' is A-R
}
```
It does not matter that the developer tried to do the safe thing with the
`relocated` variable. The code-path analysis disregards run-time values and
explores all branches of an `if` block (unless in the case of `if constexpr`).
```cpp
void reloc_showcase_07()
{
	constexpr bool relocated_v = my_can_relocate<T>{}();
	const T var = getT();
	if constexpr(relocated_v)
	{
		bar(reloc var);
	}
	else
		do_smth(var); // OK
	// [...]
    // var state is R if relocated_v is true, A otherwise
	if constexpr(!relocated_v)
		do_smth_else(var); // OK
}
```
The above example is safe because of the use of `if constexpr`.
```cpp
void reloc_showcase_08()
{
	const T var = getT();
	if (sometest(var))
	{
		bar(reloc var);
		return;
	}
	do_smth(var); // OK
}
```
This example is also safe thanks to the `return` statement right after the
`reloc` instruction, which prevents from running `do_smth(var);`.
```cpp
void reloc_showcase_09()
{
	const T var = getT();
	for (int i = 0; i != 10; ++i)
		do_smth(reloc var); // ill-formed: state of 'var' is A-R (on second iteration)
}
```
This is ill-formed as each iteration reuses `var` which is declared before
the loop body.

In the code path analysis:

1.  At the first loop iteration, the variable gains the *relocated* state.
2.  The loop increment is examined, and it does not change the state of `var`.
3.  The loop condition is examined, and it does not change the state of `var`.
4.  The code jump is examined for the first time, memorizing the state of `var`
    at that moment (*relocated*).
5.  The new state of `var` is now **A-R**.
6.  `do_smth(reloc var)` is examined, and `reloc var` is ill-formed as `var`
    is not in the *alive* state.

```cpp
void reloc_showcase_10()
{
	const T var = getT();
	for (int i = 0; i != 10; ++i)
	{
		if (i == 9)
			do_smth(reloc var); // ill-formed: state of 'var' is A-R (on second iteration)
		else
			do_smth(var); // ill-formed: state of 'var' is A-R (on second iteration)
	}
}
```
This is ill-formed for the same reason as above.
```cpp
void reloc_showcase_11()
{
	const T var = getT();
	for (int i = 0; i != 10; ++i)
	{
		if (i == 9) {
			do_smth(reloc var); // OK, var state is relocated
			break;
		}
		else
			do_smth(var); // OK, var state is alive
	}
	// var state is A-R
}
```
Adding the break statement right after the `reloc` call makes the code snippet well-formed.
Indeed the `break` statement forces the loop exit, which implies that the
conditional jump at the end of loop (that may start the next iteration) is no
longer part of the code path that follows the `reloc` instruction.
```cpp
void reloc_showcase_12()
{
	for (int i = 0; i != 10; ++i)
	{
		const T var = getT();
		do_smth(reloc var); // OK
	}
}
```
`var` is local to the for-loop body, so `reloc` is well-formed here.
The code path analysis for this variable does not require several loop iterations,
as the variable scope ends before the code jump leading to the next iteration
is evaluated.

```cpp
void reloc_showcase_13()
{
	const T var = getT();
from:
	if (sometest(var)) // ill-formed: var state is A-R after the jump
	{
		do_smth(var); // ill-formed: var state is A-R after the jump
	}
	else
	{
		do_smth(reloc var); // ill-formed: var state is A-R after the jump
	}
	goto from;
}
```
When `goto from;` is reached the first time, `var` state is A-R.
After the jump, all the expressions that use `var` are ill-formed.
```cpp
void reloc_showcase_14()
{
	const T var = getT();
from:
	if (sometest(var)) // var state is alive
	{
		do_smth(var); // var state is alive
		goto from;
	}
	else
	{
		do_smth(reloc var);
	}
}
```
In this scenario `goto` is placed in a way that does not trigger the reuse of relocated `var`.
```cpp
void reloc_showcase_15()
{
	union { T x; U y; };
	x = getT();
	if (sometest(x))
	{
		do_smth(reloc x);
		x = getT(); // well-formed
	}
	else
	{
		reloc x; // destroy x
		y = getU();
		do_smth_else(reloc y); // well-formed
		x = getT(); // well-formed
	}
	do_smth_else(reloc y); // well-formed
}
```
`reloc` does not prevent from reusing the names of anonymous union members.
```cpp
void reloc_showcase_16()
{
	T x;
	if (sometest(x))
	{
		do_smth(reloc x);
	}
	else
	{
		do_smth_else(x.reloc m); // well-formed
	}
	do_another_thing(x); // ill-formed: state is now R-D
}
```
`do_another_thing(x)` is ill-formed as `x` is either relocated or decomposed.
```cpp
void reloc_showcase_17()
{
	T x;
	if (sometest(x))
	{
		do_smth(x.reloc m); // x state is decomposed
	}
	else
	{
		do_smth_else(x); // x state is alive
	}
	do_another_thing(x); // ill-formed: x state is now A-D
	do_another_thing(x.m); // ill-formed: x.m state is A-R
	do_another_thing(x.m2); // well-formed
}
```
```cpp
void reloc_showcase_18()
{
	T x;
	if (sometest(x))
	{
		do_smth(x.reloc m); // x state is decomposed, x.m is relocated
		do_smth(x.m2); // x.m2 state is alive
	}
	else if (othertest(x)) // x state is alive
	{
		if (anothertest(x)) // x state is alive
		{
			do_smth_else(reloc x); // x state is relocated
		}
		else
		{
			do_smth(x.reloc m2); // x state is decomposed,  x.m2 is relocated
			do_smth(x.m); // x.m is alive
		}
	}
	else
	{
		do_another_thing(x.m); // x is alive
	}
	// x state is A-R-D
	// x.m and x.m2 states are A-R
}
```
```cpp
void reloc_showcase_19()
{
	T x;
	if (sometest(x) || sometest(reloc x)) // well-formed: x state is A-R
	{
		do_smth(x); // ill-formed: x state is A-R
	}
	else if (othertest(x)) // ill-formed: x state is A-R
	{
		foo();
	}
}
```
```cpp
void reloc_showcase_20()
{
	T x;
	if (othertest(x.reloc m) && sometest(x)) // ill-formed: x state
	// is D when examining the second operand of the && operator
	{
		foo();
	}
	else
	{
		do_another_thing(x.m2); // well-formed: x is A-D
	}
	// x state is A-D
	// x.m state is A-R
}
```
```cpp
void reloc_showcase_21()
{
	T x;
	if (sometest(x) && othertest(x.reloc m))
	// well-formed: x state is A-D
	{
		bar(reloc x); // ill-formed: x state must be A
	}
	else
	{
		do_another_thing(x.m); // ill-formed: x.m state is A-R
	}
	// x state is A-D
	// x.m state is A-R
}
```
```cpp
void reloc_showcase_22()
{
	// unspecified evaluation order
	{ T x; auto y = reloc x + reloc x; } // ill-formed
	{ T x; auto y = x + reloc x; } // ill-formed
	{ T x; auto y = reloc x + x; } // ill-formed
	{ T x; auto y = x[reloc x]; } // ill-formed

	// sequenced evaluation order
	{ T x; auto y = x, reloc x; } // well-formed
	{ T x; auto y = reloc x, x; } // ill-formed
	{ T x; auto y = x or reloc x; } // well-formed
	{ T x; auto y = reloc x or x; } // ill-formed

	// unspecified evaluation order with ternary
	{ T x; foo(x, reloc x); } // ill-formed
	{ T x; foo(x, test() ? reloc x : x); } // ill-formed
	{ T x; foo(test() ? reloc x : x); } // well-formed
}
```

If two or more expressions have an unspecified evaluation order,
then to determine the well-formedness with regards to `reloc` and *dot-reloc*,
we examine the expressions containing `reloc` first, *dot-reloc* second, and
examine the rest.

```cpp
void reloc_showcase_23()
{
	T x = getT();
	try
	{
		foo();
		bar(reloc x);
	}
	catch (std::exception const& excp)
	{
		std::cerr << excp.what() << " for " << x << std::endl;
		// ill-formed: x state is alive or relocated
	}
}
```

### Conditional destruction ### {#conditional-reloc}

NOTE: This section only applies to variables that are not ref-qualified.

The variable state analysis described [here](#variable-state-tracking)
may be used to know what kind of cleanup is necessary at scope exit
(i.e. if the end of scope is reached or an exception is emitted).

When this happens, if the variable is in any of **A-R**, **A-D**, **R-D** or
**A-R-D** state, and that its type is not trivial, then
implementations must track *at runtime* the actual state of the variable
(**A**, **R** or **D**)
and process its destruction accordingly:

- If the variable was the operand in an evaluated `reloc` expression, then
    the variable may need to be destructed following the rules described [here](#reloc-src-obj-lifetime).
- Otherwise, if the variable was the left operand in an evaluated *dot-reloc* expression,
    then the variable must not be destructed as it has reached its end of scope.
- Otherwise the variable must be destructed by its destructor following normal
    rules.

NOTE: If the variable was the operand of a `reloc` expression, or the left operand
    of a *dot-reloc* expression, but that expression was *not evaluated*, then
    *its lifetime is not affected* and the variable must still be destroyed
    normally.

How this runtime tracking is done is
*implementation-defined*, although it will probably take the form of extra flags
in the function stack.

For instance:
```c++
void foo()
{
    T obj = /* ... */;
    if (some_test())
        bar(reloc obj); // obj state is relocated
    else
        handle_error(); // obj state is alive
    live_on(); // obj state is alive-or-relocated
}
```

After the call to `live_on()`, or should `live_on` throw, `obj` destructor
is only called if `reloc obj` was not evaluated. Implementations may simply turn on
a flag right before the evaluation of the `reloc` expression.

Concerns have been expressed that extra flags would violate the "don't pay for
what you don't use" principle. We acknowledge this concern, but feel that the
user is getting at least something out of this. Alternatives would be for the source
object to be destroyed implicitly at the opening or closing brace of the `else`,
for the code to be ill-formed unless the source object is relocated within the
`else`, or for the code to be ill-formed unconditionally. Note that in each of these
cases, the user can recover our preferred behavior in library, using `std::optional`
to add the tracking flags that in our proposal would be provided by the language.

## Relocation constructor ## {#reloc-ctor}

Now that we have introduced the `reloc` and *dot-reloc* operators, we
introduce the relocation constructor, which is built upon those new concepts.
As relocation happens from prvalues,
the constructor takes a prvalue as parameter: `T(T)`.

This signature was picked as it completes the C++ tripartite value system.
The copy constructor creates a new instance from an lvalue, the move constructor
from an xvalue, and then the relocation constructor from a prvalue.

Note: a further benefit of this syntax is that it is currently ill-formed
<a href="http://wg21.link/class.copy.ctor#5">[class.copy.ctor]/5</a>, and
thus available for extension.

A point of confusion may be that the syntax implies an infinite regress: the
parameter must be constructed, which requires a prior call to the relocation
constructor, and so on. This is not the case; if the source object was previously
a glvalue the operand of the `reloc` operator, it was transformed into a prvalue
immediately before entering the relocation constructor, and the parameter of the
relocation constructor is that same prvalue. (If the source object was already a
prvalue, there is no issue; the parameter is that prvalue.)

An attractive intuition is that the parameter aliases the source object in the
same way as a reference or a structured binding declaration.
However, this is misleading; the lifetime of a source object glvalue has already
ended and so use of a pointer or reference referring to the source object has
undefined behavior, except as provided by [basic.life] and [class.cdtor].

Note: this behavior matches that for the destructor of a class type; see
<a href="https://wg21.link/basic.life#1.4">[basic.life]</a> paragraph 1.

This intuition is only useful in so far as the ABI for a relocation
constructor prvalue parameter is likely to be the same as that for a copy or move
constructor parameter, since the prvalue parameter may have the same storage
location as a previously existing glvalue.

Note: it does not matter that the ABI for the relocation constructor parameter
differs from that for a prvalue parameter in normal functions, since it is not
possible to take the address of a constructor.

### The relocation constructor is a second destructor ### {#reloc-ctor-is-2nd-dtor}

The role of the relocation constructor is to construct a new instance by *destructively
stealing* the resources from the source object. Unlike the move
constructor, the relocation constructor needs not to leave the source object in
valid state.

The relocation constructor **is a second destructor** of the class-type
with regards to the source object. Indeed, the lifetime of the source object
was ended immediately prior to entering the relocation constructor, and thus
the source object is considered as destructed thereafter.

In particular, the original destructor of the class-type must not be called
on the source object if it has been already passed to the relocation constructor.

### Declaration ### {#reloc-ctor-declaration}

The relocation constructor can be declared (implicitly or explicitly), defaulted
and deleted like any other constructor.

The relocation constructor of a class-type `T` implicitly gets a `noexcept(true)`
exception specification unless:

- it is explicitly declared with `noexcept(false)` ;
- or one `T`'s subobjects has a `noexcept(false)` relocation constructor ;
- or one `T`'s subobjects does not declare a relocation constructor and has
    a `noexcept(false)` move constructor.

These rules are similar to that of the destructor's implicit exception specification.

A class-type that provides a relocation constructor has some impact on the program
ABI. See the [ABI section](#abi).

#### Implicit declaration #### {#reloc-ctor-declaration-implicit}

If a class-type follows the Rule of Zero (updated to account for the relocation
constructor and relocation assignment operator), then the compiler will declare
a non-explicit inline public relocation constructor,
i.e. if none of the following are user-declared:

* copy constructor
* copy assignment operator
* move constructor
* move assignment operator
* destructor
* relocation assignment operator

#### Deleted implicitly-declared or defaulted relocation constructor #### {#reloc-ctor-declaration-deleted}

The implicitly-declared or defaulted relocation constructor for class `T` is defined as deleted:

- if `T` has subobjects that explicitly declare a deleted relocation constructor ;
- or `T` has subobjects with missing relocation and move constructors (i.e.
    that are deleted, inaccessible, or ambiguous).
- or `T` has subobjects with deleted or unaccessible destructor.

As for move constructors, a defaulted relocation constructor that is deleted is
ignored by overload resolution.

Note: this means that a class with an explictly deleted relocation constructor
will still be relocated if necessary, but through the move (or copy) constructor
and destructor.

#### Trivial relocation #### {#trivial-relocation}

A relocation constructor of a class type `X` is *trivial* if it is not user-provided and
if:
* `X` has no virtual functions and no virtual base classes, and
* for each direct base class and direct non-static data member of class type or array thereof,
    the relocation operation (which may be a relocation constructor or
    synthesized from copy/move constructor plus destructor) selected
    to relocate that base or member is trivial.

A *trivially relocatable class* is one which:
* has a trivial, eligible relocation constructor, or
* does not have a relocation constructor (including one that is deleted),
    and is trivially copyable.

Note: *eligible* is defined in
<a href="http://wg21.link/special#def:special_member_function,eligible">[special]</a>.

Scalar types, trivially relocatable class types, and arrays and cv-qualified versions
thereof are *trivially relocatable*.

Advisement: We also tighten the definition of "trivial class" (and thus "trivial") to
require that the class in question be trivially relocatable as well as trivially
copyable. This is to ensure that if the user wants code to be called on relocation,
the library does not bypass said code by, say, using `memmove`.

### Definition ### {#reloc-ctor-definition}

#### Destruction of the source object #### {#reloc-ctor-dtor-def}

As mentioned above, the relocation constructor **is a second destructor** of
the class-type. It shares similarities with the destructor with regards
to the source object:

- When the constructor body exits, all the subobjects of the
    source object, **unless relocated**, will be destructed in reverse
    declaration order.
- If the constructor exits because of an exception, this destruction sequence
    is triggered by stack unwinding.

##### Destruction of virtual bases ##### {#reloc-dtor-virtual-bases}

Virtual bases have a special treatment in constructors and destructors:
they are only contructed and destructed by the class-type of the complete object,
and not by its base classes.
The relocation constructor has the same behavior.
Hence it must be passed the same extra information
that is passed today to any constructor and to the destructor:
(a) whether it is charge of the construction of the virtual bases, and
(b) whether it is charge of the destructon of the virtual bases of the source object.

It follows that the relocation constructor will construct the virtual
bases of the target object (respectively destroy them from the source object)
only if the extra information *(a)* (respectively *(b)*) states so.

For instance:
```c++
class B
{
    B(B src);
    // [...]
};
class C : public virtual B
{
    C(C src);
    // [...]
};
class D : public C
{
    D(D src);
    // [...]
};

void foo(C);

void bar()
{
    D const d = getD();
    foo(d.reloc C);
}
```

Here, when `bar` calls the `C`'s relocation constructor to build the parameter of
`foo`:

- `C(C)` is in charge of constructing the virtual base `B` ;
- `C(C)` is **not** in charge of destroying the virtual base `B` of its parameter.
    `src.~B()` is not called by the relocation constructor ;
- The default implementation of `C(C)` will move-construct the virtual base ;
- `static_cast<B&&>(src)` still points to valid data in `C(C)` ;
- `foo` gets a `C` object owning its virtual base.

#### Default definition #### {#reloc-ctor-default-definition}

The default relocation constructor implementation for a class-type `T` depends
on `T`'s type traits.

If `T` is trivially relocatable then the relocation constructor
effectively (ignoring padding) performs
a `memcpy` over its entire memory layout.

Otherwise in the nominal case, the constructor implementation tries to perform
memberwise relocations. In the relocation constructor `T(T src)`,
for each subobject `s` (of type `S`) of `T`, in declaration order:

- if `S` is a virtual base, then `S` is move-or-copy-constructed as if by:
    `S{static_cast<S&&>(src)}` ;
- otherwise we construct `s` (or `S`) by calling its own relocation, move or copy
    constructor, as if by: `s{src.reloc s}` (or `S{src.reloc S}`);

#### User-provided definition #### {#reloc-ctor-user-definition}

Although the default definition should cover almost all cases, users can provide
their own definition of the relocation constructor. Doing so is relatively
straightforward thanks to the *dot-reloc* operator.

The only reason we have found to write a custom relocation constructor is to adjust some
self-referencing pointers.

Consider the following examples:

```c++
struct T
{
    std::string _a, _b, _c;

    // Dummy example to explain all the steps of the relocation constructor.
    T(T src) :
        _a{std::move(src._a)}, _c{src.reloc _c} {} /*
        1. T::_a is constructed using the move constructor.
        2. T::_b is default constructed.
        3. T::_c is constructed using std::string's relocation
           constructor, from src._c.
        4. src._b and src._a are destructed (in that order)
           when the constructor body exits.
    */
};

struct U
{
    std::string _a;

    ~U();

    // Second dummy example.
    U(U src) {} /*
        1. U::_a is default-constructed.
        2. Although src is not explicitly decomposed, and that
           src has a user-provided destructor,
           src destructor is not called, only src._a is.
    */
};

// Motivating example
class List
{
public:
    List(List src) : _sentinel{src.reloc _sentinel}
    {
        /* fixup references */
        _sentinel._prev->_next = &_sentinel;
        _sentinel._next->_prev = &_sentinel;
    }
private:
    struct Node { Node* _prev; Node* _next; int _value; };
    Node _sentinel;
};
```

#### Delegating relocation constructor #### {#reloc-ctor-delegate}

We do not support writing a delegating relocation constructor. Doing would raise
several problems that are difficult to solve:

- `T(T src, [...])` with non-defaulted extra parameters after `src` is a valid
    syntax today and considering this as a putative relocation constructor may
    break existing code ;
- When relocation constructor delegates to another relocation constructor,
    the source object needs to be relocated in the parameter slot of the
    delegating relocation constructor, causing infinite regress ;
- It's the relocation constructor responsibility to properly destruct
    non-relocated subobjects of the source object.
    This rule would need to be clarified if a delegating relocation constructor
    is called somehow or else we will have double destruction.

For all those reasons, using `reloc` on the source object of the relocation
constructor is considered ill-formed, as specified [here](#reloc-illegal-uses).
This may be relaxed later if the above issues are solved.

NOTE: We do not consider this as a blocking issue.
[Additional default parameters](#reloc-ctor-additional-params)
are supported with the relocation constructor. And the relocation constructor
may still delegate to another non-relocating constructor:

```c++
struct T
{
    T(T&&, Helper);
    T(T src) : T{std::move(src), Helper{}} {} /*
        all subobjects of src are destroyed upon exit */

    // [...]
};
```

#### Additional parameters #### {#reloc-ctor-additional-params}

As with copy and move constructors, it is permissible to add additional parameters
to a relocation constructor, on condition they have a default initializer.

One case where this can be of use is if the user needs space to store information
and/or resources
for the duration of the relocation constructor, for a contrived example:

```c++
class T
{
public:
    class Helper {
    public:
        Helper() = default;
        ~Helper() { delete p; }
    private:
        friend T;
        int* p;
    };

    T(T src, Helper storage = {}) noexcept(false)
        : _p(storage.p = std::exchange(src._p, nullptr))
        , _q{src.reloc _q}
        , _r{src.reloc _r}
    {
        storage.p = nullptr;
    }

    ~T() {
        delete _p;
    }

private:
    int* _p;
    RelocateOnly _q;
    ThrowingRelocate _r;
};
```

In the above, `T::_p` does not manage its own lifetime,
but the presence of `T::_r` means that `T::T(T)` is not noexcept so we need to
release its resources if an exception is thrown during relocation.

### Invocation ### {#reloc-ctor-invoke}

The relocation constructor is invoked *as necessary* to relocate a prvalue
from one storage location to another. Use of the `reloc` operator does not
guarantee that a relocation constructor (if present) will be called,
since it may be elided
if the compiler can arrange that the source glvalue was constructed at the
appropriate address.

In particular, code of the form `T x = reloc y;` is *highly* likely to be a
no-op, simply renaming an existing object. This is however likely to find use
for "sealing" objects with complex initialization, replacing the idiom of
immediately-invoked function expressions (IIFEs, [[IIFE]]):

<table>
<tr><th>Before</th><th>After</th></tr>
<tr>
<td valign="top"><pre lang="cpp">
T const x = std::invoke([&]
{
    T x;
    x.modify(y, z);
    return x;
});
</pre></td>
<td valign="top"><pre lang="cpp">
T x_mut;
x_mut.modify(y, z);
T const x = reloc x_mut;
</pre></td>
</tr></table>

Or, consider:

```c++
C f(int i) {
    C c1, c2;
    if (i == 0)
        [[likely]] return reloc c1;  // #1
    else if (i == 1)
        [[likely]] return c1;  // #2
    else
        [[unlikely]] return c2;  // #3
}
```

At `#1` the `reloc` is largely redundant; the end-of-life optimization means
the compiler is entitled to treat `c1` as a prvalue anyway, as in `#2`. Indeed,
the likelihood annotation encourages the compiler to construct `c1` in the
return slot, such that both `#1` and `#2` are a no-op. It is only `#3` that is
likely to invoke the relocation constructor.

The relocation constructor may also be invoked by library functions, for example
[[#std-reloc_and_uninitialize]].

### Virtual relocation constructor ### {#virtual-reloc-ctor}

As the relocation constructor is a second destructor, it can be declared as `virtual`.
The virtual relocation constructor is useful when relocating from dynamic
storage, to prevent leaky object-slicing. Consider the following scenario:

```c++
class D : public B { std::string _str; };

B* b = new D;

B sliced = std::reloc_and_reclaim(b);
// reloc_and_reclaim relocates the given address to
// its return value and deallocates the memory.
```

If `B`'s relocation constructor is not virtual, then only the `B` part of `*b` will
be relocated, leaking the rest.

User code cannot make a virtual call to the relocation constructor, only STL
functions can (like [std::reloc_and_uninitialize and std::reloc_and_reclaim](#std-reloc_and_uninitialize)).
In other words, how to make a virtual function call to the relocation constructor
is implementation-defined.

#### Declaration #### {#virtual-reloc-ctor-decl}

A relocation constructor can be declared as virtual by adding the `virtual`
keyword before the declaration. In derived classes, the relocation constructor
signature must not change: the parameter type must still match the class-type:

```c++
struct B
{
    virtual B(B);
};
struct D : public B
{
    D(D) override;
    // and not D(B)!
};
```

If a class-type `T` derives from a class-type which declares a virtual relocation
constructor, and that the class-type `T` has no user-declared relocation constructor,
then the class-type `T` gets a public, defaulted implicitly-declared relocation
constructor.

#### Definition #### {#virtual-reloc-ctor-def}

Let `T` be a class-type with a virtual relocation constructor.
If `T` relocation constructor has been called normally (not through a
virtual function call), then it proceeds normally as if non-virtual.

Otherwise, the virtual relocation constructor must know
(they may be passed as extra parameters):

- the target type of the object to construct, which we will call `U`.
    `U` is by construction, either `T` or a (maybe non-direct) base class of `T` ;
- the address where it is to be constructed, which we will call `u`.

The relocation constructor `T(T src)` then proceeds recursively as follows:

1.  If `U` is the same as `T`, then proceeds with the relocation constructor
    as if non-virtual.
2.  If `U` is a direct base of `T`:

    1.  If `U` is a virtual base, then use move semantics to initialize `u`:
        `new (u) U{static_cast<U&&>(src)};` and return.
    2.  Otherwise, initialize `u` with *dot-reloc*: `new (u) U{src.reloc U};`
        and return.
    3.  When the constructor exits, all the subobjects of `src` are destroyed normally
        (unless `U` if it was relocated).

3.  Let `V` be the direct base of `T` which is on the inheritance path from `T` to `U`:

    1. If `V` is a virtual base, then move-construct a local object `v`
        (`V v{static_cast<V&&>(src)};`). Then make a virtual relocation
        constructor call, passing `v` as source object, and forwarding the target type
        `U` and its target address `u`. Return.
    2. Otherwise, calls the virtual relocation constructor of `V`,
        passing the base class `V` of `src` as the source object
        (as if by `src.reloc V`), and forwarding the target type
        `U` and its target address `u`. Return.
    3.  When the constructor exits, all the subobjects of `src` are destroyed normally
        (unless `V` if it was relocated).

As you can see when the virtual relocation constructor completes,
all the non-relocated subobjects of `src` are destroyed normally, and the target
subobject is relocated at the desired location.

NOTE: To detect how the relocation constructor is called,
implementations may emit two relocation constructor definitions, one virtual
and one non-virtual. User code can only call the non-virtual version, which
ensures the virtual one is only called through virtual function calls.

#### Ill-fomed definition #### {#virtual-reloc-ctor-def-ill-formed}

A virtual relocation constructor definition of a class-type `T` is ill-formed if:

- any of the direct base of `T`, which declares (maybe implicitly) a virtual
    relocation constructor, has a non-accessible relocation constructor ;
- or if any of the subobject of `T` have an inaccessible destructor.

## Relocation assignment operator ## {#reloc-assign-operator}

We further introduce the relocation assignment operator. Its signature shall be:
`T& T::operator=(T)`. Such operators may already be defined in existing codebases,
but the proposed changes will not interfere with them.

Sometimes we also make mentions to the *prvalue-assignment operator*.
It refers to the same function,
but further indicates that this function existed prior to the proposal.

### Declaration ### {#reloc-assign-declaration}

The relocation assignment operator becomes a special member function. As such,
declaring one breaks the Rule of Zero, which was not the case previously.

The relocation assignment operator may be implicitly declared, and may be
defaulted or deleted.

#### Implicit declaration #### {#reloc-assign-operator-implicit}

If a class-type follows the Rule of Zero, then the compiler will declare
an inline public relocation assignment operator.

#### Deleted implicitly-declared or defaulted relocation assignment operator #### {#reloc-assign-declaration-deleted}

The implicitly-declared or defaulted relocation assignment operator for class `T` is defined as deleted:

- if `T` has subobjects that have an implicitly or explicitly deleted relocation assignment operator ;
- or `T` has no relocation, move, or copy constructor ;
- or `T` has subobjects that have inaccessible relocation or move assignment operators ;
- or `T` has subobjects with deleted or unaccessible destructor.

A defaulted relocation assignment operator that is deleted is ignored by overload
resolution.

### Relocation assignment operator parameter relocation elision ### {#aliased-reloc-assign}

As with the relocation constructor, it is desirable that the parameter should be
the source object *converted to* a prvalue, and not a temporary prvalue relocated
*from* the source object. This is particularly critical for
the default definition of the operator, which
(as you might suspect) performs memberwise calls to other relocation assignment operators.
Without elision, that would imply recursive relocation of each subobject, down to
their smallest unbreakable parts (incurring O(N<sup>2</sup>) byte copies, *N* being the size in
bytes of the source object).

However, this poses a problem since it is possible to take the address of a
relocation assignment operator, yielding a pointer (or reference) with (typical)
signature `T& (T::)(T)`, implying that the source object must occupy a parameter slot,
which may not find it possible to have the same storage address as the source object,
and/or which the caller may expect to destroy (see [[#abi]]).

Nevertheless, we mandate elision where possible:

- If the class-type (possibly implicitly) declares a non-deleted relocation constructor,
    or declares a defaulted relocation assignment operator, then elision is
    mandated at declaration level ;
- Otherwise, if the class-type defines a relocation assignment operator as
    defaulted, then elision is mandated at definition level ;
- Otherwise elision is not mandated.

Elision is performed in such a way as to avoid ABI break (more on that on the [ABI
section](#prvalue-assign-op-abi)).

#### Elision at declaration level #### {#aliased-reloc-assign-declaration}

If elision is mandated at declaration level, then the assignment operator
declaration actually declares two member functions:

- the non-eliding one, which takes its input parameter by value.
    This is the function that will get called when user-code calls the
    assignment operator. It is the prvalue-assignment operator as we know it
    today ;
- the eliding one, which takes its input parameter as if by reference, and has the
    same return type as the non-eliding one. The eliding
    function has no identifier and does not participate in overload resolution.
    Users cannot take its address.
    The eliding operator is forced to have callee-destroy ABI: the operator
    is in charge of the lifetime of the source object.

The definition of the assignment operator (which is user-provided or
defaulted) will serve as the definition of the eliding operator.

The non-eliding operator definition is generated by the compiler, and merely wraps
the call to the eliding one:

- If the source object passed to the non-eliding operator is not an *unowned parameter*,
    then the operator:
    1.  Calls the eliding operator, passing the source object as if by reference.
    2.  It forwards as return value whatever the eliding operator returns.
- Otherwise (the source object is an *unowned parameter*), then the operator:
    1.  Creates a copy of the source object, using move or copy constructor.
    2.  Calls the eliding operator, passing that copy by reference.
    3.  It forwards as return value whatever the eliding operator returns.

If the address of the assignment operator is queried, then the address of the
non-eliding version is returned. If the assignment operator is virtual, then only
the non-eliding version is considered to be `virtual` and is added to the vtable entry.

#### Elision at definition level #### {#aliased-reloc-assign-definition}

If elision is mandated at definition level, then the two versions of the operator
are generated (eliding and non-eliding) in the translation unit where the operator
is defined. The visibility of the eliding operator symbol to other translation
units is *implementation-defined*.

The eliding operator has an ABI where it takes its input parameter by reference,
and is in charge of the lifetime of the source object (callee-destroy).

The definition of the two functions are the same as if elision was mandated at
declaration level.

Typically, we expect code in the same translation unit to befenit from the
elided-version. Code outside the translation unit may also benefit from it
through link time optimizations.

### Definition ### {#reloc-assign-definition}

#### Default definition #### {#reloc-assign-default-definition}

As you would expect, the default definition merely delegates to the relocation
assignment operator of all its subobjects.

In `T`'s default assignment operator, for all subobjects `s` of type `S` of the
source object `T src`:

- if `S` is a virtual base, then `S` is move-or-copy-assigned as if by:
    `static_cast<S&>(*this) = static_cast<S&&>(src);` ;
- otherwise we construct `s` (or `S`) by calling its own relocation, move or copy
    assignment operator, as if by: `s = src.reloc s;` (or `static_cast<S&>(*this) = src.reloc S;`);

Thanks to the relocation-assignment operator special eliding,
no copies or relocations of the source subobjects are performed.

#### Possible user definitions #### {#reloc-assign-user-definition}

User-provided operators can still perform memberwise relocation as it is
done with the defaulted version.

Other definitions are possible, notably the famous *copy-and-swap*
(now *relocate-and-swap*) and the *destroy-and-construct* idioms.

Note that the most optimal implementation will result in a single destructor
call and a single memcpy call (given that the class-type is trivially
relocatable).

**Memberwise relocation**

```c++
T& T::operator=(T src)
{
    static_cast<B&>(*this) = src.reloc B; // relocate base
    this->_a = src.reloc _a;
    return *this;
}
```

This implementation is the best possible given that memberwise relocation
matches the need of the class-type. It has a strong exception safety
and has optimal performance (memberwise, one destructor call and one memcpy).

**destroy-and-construct**

```c++
T& T::operator=(T src) noexcept
{
    std::destroy_at(this);
    return *std::construct_at(this, reloc src);
}
```

Or an exception-safe version, necessary if the destructor or the relocation
constructor throws:

```c++
T& T::operator=(T src)
{
    std::experimental::scope_fail _{[this] { new (this) T{}; }};
    std::destroy_at(this);
    return *std::construct_at(this, reloc src);
}
```

This idiom is as optiomal as we could hope for, merely destructing the object
and reconstructing it thanks to the relocation constructor.

Exception safety is a bit tricky and requires
to be able to reconstruct a valid instance of the object from scratch, should
an exception be thrown. Of course, this is not possible in the general case as
not all classes are default-constructible.

Note that if `T` is trivially
relocatable, then the operator is as optimal as we would like, as it merely
translates into a destructor call and a memcpy call.

NOTE: If the assignment operator needs no further logic than a simple memberwise
assignment, then users should instead use the defaulted version of the operator
as it will provide better exception safety for similar performance.

**relocate-out-and-construct**

```c++
T& T::operator=(T src)
{
    T const tmp{std::reloc_and_uninitialize(this)};
    return *std::construct_at(this, reloc src);
}
```

Or the exception-safe version, needed only if the relocation constructor throws
(we don't care about the destructor exception specification):

```c++
T& T::operator=(T src)
{
    std::experimental::scope_fail guard{[this] { new (this) T{}; }};
    T const tmp{std::reloc_and_uninitialize(this)};
    std::construct_at(this, reloc src);
    guard.release();
    return *this; // we don't care if tmp.~T() throws
}
```

Again, the exception-safe version is only possible if `T` can be default-constructed.

This version is less performant, as it results in one destructor call (`tmp`'s)
and *two* memcpy calls. This idiom may only be used if the destructor throws but the
relocation constructor does not.

**relocate-and-swap**

```c++
T& T::operator=(T src)
{
    using std::swap;
    swap(*this, src);
    return *this;
}
```

This version is exception-safe, although it may not be the most efficient approach.

Should `std::swap` be optimized to perform memcpy on trivially relocatable
objects, then it results in one destructor call (`src`'s) and three memcpy calls.

**Union trick**

If for some reason, the implementation needs to prevent the destructor call
on the source object, it is still possible to perform the "union trick":

```c++
T& operator=(T src)
{
    union { T tmp } = { .tmp = reloc src; };
    /* do some stuff with tmp (like calling std::reloc_and_uninitialize),
     * knowing its destructor will not be called by the language */
    return *this;
}
```

### Invocation ### {#reloc-assign-invoke}

```c++
T x, y;
x = reloc y;
```

Every call to the relocation assignment operator follows normal rules.

If the call site detects that an eliding version of the operator is available
(either because the eliding happened at declaration level, or because it
happened at definition level and the call site is in the same
translation unit as the definition, or through link-time optimization),
then which version of the operator
is called is implementation-defined.

The nominal case is to call the non-eliding version. The implementation is allowed
to call the eliding version instead, as long as it can elide the call to the
destructor on the source object.

## Overload resolution ## {#overload-resolution}

The current overload resolution rules are not suitable for relocation by prvalue.

Indeed, consider the following scenario:
```c++
void bar(T&&);
void bar(T);

void foo(T val)
{
    bar(reloc val); /* ambiguous call using today's rules */
}
```

Hence we propose a change in the overload resolution rules to prefer passing by
value for prvalue arguments.

Specifically, we would amend [over.ics.rank]/3.2.3 to read:

- neither of S1 and S2 bind a reference to an implicit object parameter of a
    non-static member function declared without a ref-qualifier, and either:
    - S1 binds an lvalue reference to an lvalue, and S2 does not, or:
    - S1 binds an rvalue reference to an xvalue, and S2 does not, or:
    - S1 does not bind a reference, and S2 binds a reference to a prvalue, or:
    - S1 binds an rvalue reference to a prvalue, and S2 binds an lvalue reference [Example:
        ```c++
        int i;
        int f1();
        int&& f2();
        ...
        int g2(const int&);
        int g2(int);
        int g2(int&&);
        int j2 = g2(i); // calls g2(const int&)
        int k2 = g2(f1()); // calls g2(int)
        int l2 = g2(f2()); // calls g2(int&&)
        ...
        ```
        &#45; end example]


### Comparison against P2665R0 ### {#overload-against-P2665R0}

[[P2665R0]] "Allow calling overload sets containing T, const T&" also proposes
to modify the overload resolution rules. It allows overload sets containing
both `T` and `T const&` to exist, and which overload is selected is
implementation-defined. The main motivation is for performance: "small" trivial
types, such as built-in integral types, are best passed by value than by
reference.

In what we propose, overload sets with `T`, `T const&` and `T&&` can also exist.
However, which is picked is (almost always) specified clearly by the standard
(depending on the value category of the parameter) and
not *implementation-defined*.

The `reloc` or *dot-reloc* operators can be used to turn not-ref-qualified
automatic variables
into prvalues, which allows the user to force the right overload.

The only situation where the overload being selected is implementation-defined,
is when a function parameter passed by value is being relocated. Whether the
relocation constructor is considered in the overload resolution is
implementation-defined, as it depends on the ABI capabilities. Consider:

```c++
void foo(T);
void foo(T&&);

void bar(T value)
{
    foo(reloc value); /* always calls foo(T),
        but how foo's parameter is constructed
        is implementation-defined (reloc, move or copy ctor) */
}
```

In this example, `bar` will always call the `foo(T)` overload, as `reloc value`
is always a prvalue. However, the materialization of this prvalue is
implementation-defined, the relocation constructor being potentially
evicted.

NOTE: This proposal and P2665R0 can co-exist. Even with the updated overload
resolution rules that we propose, compilers may still be allowed to pick the
prvalue overload if they analyse it may bring a performance boost, as P2665R0
suggests.

## Structured relocation ## {#structured-reloc}

### Discussion ### {#structured-reloc-discussion}

`auto [x, y] = foo(); sink(reloc y);` is ill-formed given the rules we
established for `reloc`. `x` and `y` are not complete objects but aliases to some anonymous
object which the language creates behind the scene.

As this proposal aims to provide support for relocate-only types, this support
would be partial, if not impractical, without allowing some form of
relocation from a structured binding.

In our experience, most C++ developers believe that a structured binding is
a complete, separate object, and not a name alias to some subobject. As such
it would feel unnatural for them if they cannot relocate from a structured binding.

### Structured relocation declaration ### {#structured-reloc-declaration}

A structured relocation declaration is syntactically identical to a structured
binding, with the exception that no ref-qualifiers are allowed after the `auto`
type specifier.

```c++
T foo();
T const& bar();
T foobar();

// [...]

auto [x, y] = foo(); // matches structured relocation declaration
auto const [w, z] = bar(); // matches structured relocation declaration
auto&& [a, b] = foobar(); // structured bindings will be used
```

The structured relocation declaration further requires that the type of the
expression that is used to initialize it
supports any of the [structured relocation protocol](#structured-reloc-obj-decomposition).
If not, then the declaration is simply a structured bindings declaration and will
follow structured bindings rules.

A structured relocation introduces a new complete object for each identifier
declared in the brackets `[]`. In other words, the new identifiers are not
aliases like in structured bindings, but actual complete objects. As such, they
can be relocated like any other.

### Structured relocation protocols ### {#structured-reloc-obj-decomposition}

As there are three binding protocols for structured bindings, there are likewise
three "structured relocation" protocols. If none
of those protocols match, then the declaration is not a
structured relocation declaration, and structured bindings are considered.

The protocols are tested in the following order:

1. The *array* protocol ;
2. The *get_all* protocol ;
1. The *data members* protocol ;

In what follows, let `E` be the type of the initializer expression (the type
of the expression used to initialize the structured relocation).

- If `E` is ref-qualified, then let `S` be the same as `E`, but deprived of its
    ref-qualifiers.
    If one of the two protocols applies, then an anonymous object of type `S` is
    constructed from the initializer, using the appropriate constructor.
    This anonymous object will be considered as source object ;
- Otherwise (`E` is a prvalue), then let `S` be the same as `E`. The initializer
    expression will be used as source object.

#### array protocol #### {#structured-reloc-array}

The *array* protocol is quite similar to that of structured bindings.
For this protocol to apply, all the following conditions must be satisfied:

- `S` must be an array-type of known bound ;
- the number of identifiers must equal the number of array elements ;

If this protocol applies, then the *i*-th identifier is constructed by
relocation, move or copy constructor using the *i*-th array element as source object.

```c++
void foo()
{
    std::string const strs[3] = { /* ... */ };
    // [...]
    auto const [str1, str2, str3] = reloc strs;
    bar(reloc str2);
}
```

#### get_all protocol #### {#structured-reloc-get_all}

The function `get_all(S)` is looked-up using ADL-lookup. If there is
no match, then this protocol does not apply.

If there is a match, then this function is called. The returned type is
tested recursively:

1. If *get_all* matches for the returned type, then we reapply it again ;
2. If *data members* protocol matches for the
    returned type, then it is applied ;
3. If no protocol matches for the returned type, then the program is **ill-formed**.

This follows the same recursive logic as `operator->()`.
We recursively call `get_all` as long as the *get_all* protocol applies.
When the recursion ends, we end up with a type which
matches the *data member* protocol, or else the program is ill-formed.

#### data members protocol #### {#structured-reloc-dm}

The *data members* protocol is also similar to that of structured bindings.
For this protocol to apply, all the following conditions must be satisfied:

- every non-static data member of `S` must be a direct member of `S` or of the same
    base class of `S` ;
- the number of identifiers must equal the number of non-static data members ;
- `S` may not have an anonymous union member ;
- *specific to structured relocation:* for every base class, between `S` and the base
    class the data members are found in, its decomposition is [well-formed](#ill-formed-decomposition).

If this protocol applies, then the *i*-th identifier is constructed as if by
`s.reloc i`, `s` being the base class holding all the data members and `i` the
*i*-th identifier.

#### Implementation-defined library support #### {#structured-reloc-tuple}

`std::pair`, `std::tuple`, and `std::array` shall provide their own implementation
of `get_all`. The return type is implementation-defined (may rely on compiler magic).

This allows us to write things like:
```c++
void bar(T);
void foo(std::vector<T>& v)
{
    /* This code uses a putative vector::pilfer(const_iterator) (not proposed),
     * which removes a vector element at given iterator, and
     * returns a pair with next valid iterator and relocated vector element. */
    auto [val, it] = v.pilfer(v.begin() + 1); /* calls get_all behind
        the scene. */
    bar(reloc val); /* can call reloc on val as it is not a structured binding */
}
```

This code works even if `T` is relocate-only.

#### Possible get_all implementations #### {#structured-reloc-implem}

Thanks to `std::tuple`'s `get_all` we can easily write
a `get_all` implementation for a custom class:

```c++
class MyType
{
public:
    MyType();
    MyType(MyType);

    // Possible implementation:
    auto get_all(this MyType self)
    {
        return std::tuple{self.reloc _name, self._flag,
            !self._nodes.empty()};
    }

private:
    std::string _name;
    bool _flag;
    std::vector<Node*> _nodes;

};
```

The implementation relies on a putative new constructor for `std::tuple`
(not proposed) which captures the tuple elements by value category,
which allows to relocate objects into a tuple.

Then, in following snippet:
```c++
MyType tp;
auto [name, flag, nodes] = reloc tp;
// equivalent to: auto [name, flag, nodes] = get_all(get_all(reloc tp));
```

`MyType`'s `get_all` returns a tuple. `get_all` is defined for tuples as well, so
it is called again. The second return type won't have a `get_all` defined, hence
the recursion stops and the *data member* protocol is used.

# Proposed library changes # {#proposed-lib-changes}

NOTE: Adding support for relocation in the STL is another major change.
What we are proposing to add for the moment is the bare minimum to allow
library writers to benefit from relocation. Support for relocation in the STL
will be done in a separate proposal, depending on whether the work on this
proposal is pursued.

## Memory header ## {#std-mem-header}

### std::construct_at ### {#std-construct_at}

We propose to add the following overload to `std::construct_at`:

```c++
template<class T>
constexpr T* construct_at( T* p, T src );
```

Which would be equivalent to `::new (p) T{reloc src}`, except that it may be
used in constant expression evaluations.

Note: this overload would be unnecessary if the [[#future-capture-value]]
direction were to be adopted; instead the existing signature should be
altered to use the `decltype(Args)...` placeholder.

### std::reloc_and_uninitialize and std::reloc_and_reclaim ### {#std-reloc_and_uninitialize}

We propose to add the following functions in the `std` namespace in the `memory`
header to perform relocation through a pointer:

```c++
template <class T>
T reloc_and_uninitialize(T* src);
template <class T>
T reloc_and_reclaim(T* src);
```

Both functions construct a new object by calling either the relocation constructor,
the move constructor or the copy constructor,
using `*src` as parameter while ignoring its cv-qualifiers, and return it.
They also ensure the end-of-life of the source object: if the move or copy
constructor is called then the destructor of `*src` is called afterwards.

NOTE: If `*src` is a polymorphic type, that the relocation constructor is selected in
the overload resolution,
and the relocation constructor is virtual,
then a virtual relocation constructor call is performed from the dynamic type of `*src`.

`reloc_and_uninitialize` leaves the memory that was occupied by `src` in an
uninitialized state.  If any exception is thrown,
then `reloc_and_uninitialize` is guaranteed to leave the source object in a
destructed state.

`reloc_and_reclaim` reclaims the memory by calling the appropriate deallocation
function (class-defined `delete` or global `delete`). If any exception is thrown,
then `reloc_and_reclaim` is guaranteed to leave the source object in a destructed
state and to have deallocated its memory.

`reloc_and_uninitialize` is intended to be used by library authors to enable relocation
from a memory address. For instance, extracting a value out of an optional just
becomes:

```c++
T optional<T>::extract()
{
    _has_value = false;
    return std::reloc_and_uninitialize(_value_addr());
    // _value_addr() being a private function returning the address of the owned value
}
```

Of course, this function is not intended to be used on local objects. Hopefully
its name should prevent misuses.

```c++
void foo()
{
    const T val;
    bar(std::reloc_and_uninitialize(&val)); /* BAD, val destructor is called at the
        end of its scope while it is already destructed!*/
}
```

`reloc_and_reclaim` is intended to be used by end users and library vendors alike.

```c++
unique_ptr<pair<string, reloc_only_t>> makeStuff();

reloc_only_t getRelocOnly()
{
    auto stuff = makeStuff();
    auto [str, relocOnly] = std::reloc_and_reclaim(stuff.release());
    return relocOnly;
    // or the short version:
    // return std::reloc_and_reclaim(makeStuff().release()).second;
}
```

### std::uninitialized_relocate ### {#std-uninitialized_relocate}

We propose to introduce the following new functions in the `std` namespace in
the `memory` header:

```c++
template<class InputIt, class ForwardIt>
ForwardIt uninitialized_relocate(InputIt first, InputIt last, ForwardIt d_first);

template<class ExecutionPolicy, class InputIt, class ForwardIt>
ForwardIt uninitialized_relocate(ExecutionPolicy&& policy, InputIt first, InputIt last,
	ForwardIt d_first) ;

template<class InputIt, class Size, class ForwardIt>
pair<InputIt, ForwardIt> uninitialized_relocate_n(InputIt first, Size count,
	ForwardIt d_first) ;

template<class ExecutionPolicy, class InputIt, class Size, class ForwardIt>
pair<InputIt, ForwardIt> uninitialized_relocate_n(
	ExecutionPolicy&& policy, InputIt first, Size count, ForwardIt d_first);
```

Those relocate elements from the range `[first, last)` (or the first `count`
elements from `first`) to an uninitialized memory area beginning at `d_first`.
Elements in the source range will be destructed at the end of the function
(even if an exception is thrown).

Returns:

- `uninitialized_relocate`: an iterator to the element past the last element relocated;
- `uninitialized_relocate_n`: a pair whose first element is an iterator to the
    element past the last element relocated in the source range, and whose second
    element is an iterator to the element past the last element relocated in the
    destination range.

If the type to relocate is trivially relocatable and both iterator types are
contiguous, then both functions can be implemented as single `memcpy` call over
the entire source range.
Otherwise relocation happens element-wise, as if by calling `std::reloc_and_uninitialize`
on each element.

If an exception is thrown by `std::reloc_and_uninitialize`, then the destructor of all
remaining elements in the source range is called, as well as the destructor of
all constructed objects in the output iterator.

## Type traits header ## {#std-type_traits-header}

We propose to introduce the following type traits, which all derive from
`std::true_type` or `std::false_type`
accordingly:

- `std::is_relocation_constructible<T>`: same as `std::is_constructible<T, T>` ;
- `std::is_trivially_relocation_constructible<T>`: same as
    `std::is_trivially_constructible<T, T>` ;
- `std::is_nothrow_relocation_constructible<T>` same as
    `std::is_nothrow_constructible<T, T>` ;
- `std::is_relocation_assignable<T>`: same as `std::is_assignable<T, T>` ;
- `std::is_trivially_relocation_assignable<T>`: same as `std::is_trivially_assignable<T, T>` ;
- `std::is_nothrow_relocation_assignable<T>`: same as `std::is_nothrow_assignable<T, T>` ;
- `std::has_virtual_relocation_constructor<T>`: derives from `std::true_type`
    if and only if `T` declares (maybe implicitly) a virtual or overridden
    relocation contructor.
    Derives from `std::false_type` otherwise ;
- `std::is_decomposable<T>`: derives from `std::true_type`
    if and only if `T` is a possibly cv-qualified class-type, not ref-qualified,
    not a pointer and not an array type, and whose decomposition is legal ;
    Derives from `std::false_type` otherwise ;

For all new type traits, the inline constexpr boolean template variable counterparts
are also proposed. For instance we propose to introduce:
```c++
template< class T >
inline constexpr bool is_relocation_constructible_v = is_relocation_constructible<T>::value;
// along with the rest
```

# Discussions # {#discuss}

## Potential ABI changes ## {#abi}

As noted above ([[#parameter-ownership]]), some platforms have a *caller-destroy* ABI
where the *calling* function expects to destroy nontrivial parameters passed by
value. This poses a problem for functions that wish to relocate from such
parameters, and a potential ABI break.

### relocate-only function parameters ### {#callee-destroy-abi}

In the [case study](#reloc-with-function-param) of how `reloc` should behave
with function parameters passed by value, we established the following rule:

> **Rule:** If the source object is a function parameter passed by value, and its
type provides an eligible move constructor, then the relocation constructor
(if any) may be discarded during overload resolution. Whether the relocation
constructor is discarded is implementation-defined.

If the ABI is not already compliant, then this rule will force an ABI change
on functions which have parameters passed by value,
and whose type declares a relocation constructor but no move constructor.

The good news is as of today, there are no such types, so no existing function
should suffer from an ABI break. However, some types may accidently gain a relocation
constructor and may trigger an ABI break nonetheless.

In our library changes proposal (separate from this one), we are careful not to
make any existing type relocate-only, especially for that concern.
However we do add a relocation constructor on many classes, alongside their
existing copy and move constructors. In doing so,
some of them may fit the criteria for ABI break, should their copy and move constructors
be deleted (for instance `std::optional<T>` with `T` being relocate-only).

One example is a function with signature: `void foo(gsl::non_null<std::unique_ptr<int>>);`,
supposing `unique_ptr` gets a relocation constructor.
In turn GSL developers will
likely add a relocation constructor too. That makes `gsl::non_null<std::unique_ptr<int>>`
relocate-only, while it wasn't before, and may cause a potential ABI break.

There is zero value of passing a `gsl::non_null<std::unique_ptr>` by value
to a function today, so we doubt anyone would write such a function.
However those functions might theoritically exist, and might have an ABI change.

Also, library vendors are encouraged to migrate to an ABI where any function that
takes non-trivial parameters by value are responsible for their destruction.
Then, the function definition can make the most of `reloc`.
This is not required by the proposal.

We believe it's up to the implementation to choose what they want to do with their ABI:
- *full break*, use callee-destroy or equivalent for all non-trivial relocatable types
    passed by value (for those who don't care about ABI) ;
- *break with opt-out*: a relocation constructor attribute to opt-out of the ABI
    break on functions where it is passed be value.
    This solution should also provide propagation mechanisms suitable for composition
    (these could be standardized at a later date) ;
- *likely no break, but opt-in*: an improved `[[trivial_abi]]` that actually checks that
    the type is trivially relocatable ;
-Â *likely no break*: use callee-destroy only for relocate-only types ;
- and those that are callee-destroy already don't need to do anything!

In all cases the following mitigation and migration techniques could be employed:

- functions that have an ABI change could be mangled differently. This makes
    ABI breakage detectable ;
- for such functions, up to two symbols are emitted, where the old
    symbol is emitted only if the function does not in actual fact relocate from
    its parameters, in which case the new symbol is emitted, and its implementation
    forwards to the old and then destructs its relocatable parameters on exit ;

### prvalue assignment operator ### {#prvalue-assign-op-abi}

As mentioned above, if the class-type is relocate-only, then it may have an
impact on existing prvalue-assignment operators (like it does to any function).
However this change is purely opt-in. If there is an existing prvalue-assignment
operator in a class, then it will prevent the implicit declaration of the
relocation constructor, which will in turn prevent from the potential ABI break.

Also, the relocation assignment operator may be aliased.
If aliasing occurs, then the ABI does not break as aliasing happens only on a
new hidden function.

The only scenario where the ABI might break is where:

- aliasing happened on declaration level ;
- code was compiled against it, and especially generated code that makes direct
    calls to the aliased version ;
- the class changes, the aliasing only happens at definition level, or does not happen at all.

This may introduce an ABI break, detectable at link-time (aliased symbols missing):

- if the aliasing now happens at definition level, but the aliased operator symbol
    remains visible nonetheless, then no ABI breaks are introduced ;
- otherwise the ABI break happens, but remains detectable at link-time.

## Why a new keyword? ## {#reloc-new-keyword}

Alternatively, a new series of symbols could be used instead of introducing
a new keyword, like: `<~< obj` or `&< obj` in place of `reloc obj`.
However, we feel like `reloc obj` better conveys the intent, and has better
readibility.

The introduction of a new keyword may always break existing codebases. We had a
look at several well-known open source C++ projects to analyse what volume of code
would break if `reloc` were a keyword.

For each of the following repositories, we searched for the `reloc` string,
at word boundaries, with case-sensitivity, in all C++ source files and headers
(`*.cc`, `*.cpp`, `*.cxx`, `*.h`, `*.hpp`, `*.hh`).
We manually discarded matches that
were not code (comments or strings). And we put that in perspective with the
total number of files, lines and words of the repository.

- [Qt](https://github.com/qt/qtbase): 0 hits; files:  7,586 ; lines:  2,794,607 ;
    words:  98,635,622; commit: 040b4a4b21b3
- [boost](https://github.com/boostorg/boost) (with all submodules): 0 hits;
    files:  23,726 ; lines:  4,133,844 ;
    words:  180,808,943; commit: 86733163a3c6
- [godot](https://github.com/godotengine/godot): 0 hits; files:  5,068 ;
    lines:  2,545,299 ;
    words:  99,389,743; commit: b6e06038f8a3
- [abseil-cpp](https://github.com/abseil/abseil-cpp): 0 hits; files:  766 ;
    lines:  247,441 ;
    words:  9,028,820; commit: de6fca2110e7
- [folly](https://github.com/facebook/folly): 0 hits; files:  1,861 ;
    lines:  532,918 ;
    words:  16,669,085; commit: cde9d22e8614
- [llvm-project](https://github.com/llvm/llvm-project): **124 hits in 11 files**
    (`reloc` only used as local variable or
    data member, counting all uses); files:  39,048 ; lines:  9,760,587 ;
    words:  385,429,611; commit: 9816c1912d56
- [gcc](https://github.com/gcc-mirror/gcc): **244 hits in 31 files**
    (`reloc` only used as local variable or
    data member, counting all uses); files:  15,337 ; lines:  4,616,875 ;
    words:  146,146,684; commit: ee6f262b87fe
- [rapidjson](https://github.com/Tencent/rapidjson): 0 hits; files:  96 ;
    lines:  39,828 ; words:  1,492,060;
    commit: a98e99992bd6
- [googletest](https://github.com/google/googletest): 0 hits; files:  155 ;
    lines:  85,703 ; words:  3,104,817;
    commit: 71140c3ca7a8
- [yaml-cpp](https://github.com/jbeder/yaml-cpp): 0 hits; files:  259 ;
    lines:  112,513 ; words:  3,784,676;
    commit: 1b50109f7bea
- [flatbuffers](https://github.com/google/flatbuffers): 0 hits; files:  175 ;
    lines:  98,163 ; words:  3,851,726;
    commit: e0d68bdda2f6
- [MongoDB](https://github.com/mongodb/mongo): **22 hits in 6 files**
    (`reloc` only used as local variable,
    counting all uses); files:  20,054 ; lines:  6,439,465 ; words:  265,329,429;
    commit: 73b7a22328c7
- [OpenCV](https://github.com/opencv/opencv): 0 hits; files:  3,315 ;
    lines:  1,556,606 ; words:  58,339,686;
    commit: 9627ab9462a4
- [electron](https://github.com/electron/electron): 0 hits; files:  698 ;
    lines:  99,717 ; words:  3,431,787;
    commit: 644243efd61b
- [mold](https://github.com/rui314/mold): 0 hits; files:  813 ; lines:  262,560 ;
    words:  9,992,769; commit: a45f97b47430
- [ClickHouse](https://github.com/ClickHouse/ClickHouse): 0 hits; files:  5,566 ;
    lines:  1,128,735 ; words:  68,112,047; commit: d42d9f70c812;
- [Dlib](https://github.com/davisking/dlib): 0 hits; files:  1,421 ;
    lines:  533,513 ; words:  19,080,728; commit: a12824d42584
- [&#83;FML](https://github.com/SFML/SFML): 0 hits; files:  532 ; lines:  168,787 ;
    words:  7,272,946; commit: 9bdf20781819
- [Kodi](https://github.com/xbmc/xbmc): 0 hits; files:  4,360 ; lines:  1,008,255 ;
    words:  34,114,229; commit: b228c778668f
- [Beast](https://github.com/boostorg/beast): 0 hits; files:  473 ;
    lines:  145,193 ; words:  4,768,152; commit: 334b9871bed6
- [JSON for modern C++](https://github.com/nlohmann/json): 0 hits; files:  450 ;
    lines:  137,679 ; words:  5,210,982; commit: 4c6cde72e533
- [IncludeOS](https://github.com/includeos/IncludeOS): 0 hits; files:  841 ;
    lines:  107,582 ; words:  2,903,698; commit: 99b60c782161
- [SerenityOS](https://github.com/SerenityOS/serenity): **15 hits in 2 files**
    (`reloc` only used as local variable, counting all uses); files:  5,538 ;
    lines:  887,768 ; words:  31,766,641; commit: 97dde51a9b3f

Repository statistics are computed with the following command:
```bash
find -type f \( -name '*.h' -or -name '*.hh' -or -name '*.hpp' -or -name '*.cc' \
    -or -name '*.cpp' -or -name '*.cxx' \) -exec wc -l -c {} \; \
    | awk '{ f+=1 } { l += $1 } { w += $2 } END { print "files: ", f, "; lines: ", l, "; words: ", w }'
```

As you can see, in the vast majority of cases, `reloc` is not used at all.
The impact seems to be minimal, where only a few files might need to be fixed
here and there. To smooth the transition, compilers may also warn that existing
code will break as `reloc` will become a keyword in a next C++ version.

## Future directions ## {#future-directions}

We removed some of the changes we initilialy had in mind, to keep for future
extensions. This proposal aims to be the bare minimum to bring support for
relocate-only types.

### More perfect forwarding ### {#future-capture-value}

Currently, "perfect forwarding" is built on top of *universal references*, requiring
an understanding of reference-collapsing and the use of `std::forward`. The present
proposal improves on this by incidentally replacing `std::forward` with `reloc`, but
at the same time the situation is worsened by making relocate-only types viable;
such types cannot be relocated when passed by universal reference.

<table>
<tr><th>Before</th><th>After</th></tr>
<tr>
<td>
```c++
template <class... Args>
void fwd(Args&&... args)
{
    do_stuff(std::forward<Args>(args)...);
}
```
</td>
<td>
```c++
template <class... Args>
void fwd(Args&&... args)
{
    do_stuff(reloc args...);
}
```
</td>
</tr>
</table>
<br/>
<table>
<tr><th>Future</th></tr>
<td>
```c++
template <class... Args>
void fwd(decltype(Args)... args)
{
    do_stuff(reloc args...);
}
```
</td>
</tr>
</table>

We suggest a new way to deduce template type parameters, by allowing
`decltype(T)` in the function parameters (only if `T` is a function template
type parameter). With this addition,
it would become possible to deduce each parameter to value, lvalue
reference or rvalue reference according to whether the argument is of
value category prvalue, lvalue or xvalue, and forward by relocation.

### discarded reloc expression ### {#solve-discarded-reloc-expr}

Initilialy, discarded reloc expressions such as `reloc obj;` would simply
translate to a call to the destructor of `obj`, while ensuring that the
destructor won't be called again at the end of its scope.

However this is hardly possible at the moment because of all the different ABIs
that exist. If `obj` is an *unowned parameter*, then the function cannot elide
the destructor call of `obj` that will happen on the caller-side.

We wanted the well-formedness of the code above all else (i.e. `reloc obj;` could
not be well-formed on some implementations and not in others). As such,
in this proposal, `reloc obj;` is only well-formed if `obj` is
relocatable, movable or copyable.

Hence, the best we can do if `obj` is an *unowned parameter*,
is to move-construct a temporary, and destruct
it right after, which will trigger the desired side-effects of the destructor
(e.g. release a lock if `obj` is a `unique_lock`).
The destructor of `obj` will still be called when the function
returns, but will likely do nothing as the object will be in a moved-from state.

A future proposal could make `reloc obj;` to just call the destructor,
regardless of whether `obj` is an *unowned parameter* and of its constructors,
solving those ABI issues.

## Will it make C++ easier? ## {#easier-cpp}

This proposal introduces a new keyword, and a bunch of new concepts
(relocation contructor, decomposition), which are additional things to teach.
However we have hopes this proposal will improve the language on many areas
and eradicate some gotchas:

- support for relocation-only types, which allow for better class design
    with stronger class invariants ;
- `reloc` aims to fix the "moved-from state" understanding problem,
    and the used-after-move errors ;
- relocation fixes the `const` pessimization with move constructor ;
- `reloc` creates more opportunities to declare constant variables, improving on
    code readability and performance.

<pre class=biblio>
{
  "P1144R8": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "std::is_trivially_relocatable",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1144r8.html",
    "date": "May 2023"
  },
  "P0023R0": {
    "authors": [ "Denis Bider" ],
    "title": "Relocator: Efficiently moving objects",
    "href": "http://open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0023r0.pdf",
    "date": "April 2016"
  },
  "N4158": {
    "authors": [ "Pablo Halpern" ],
    "title": "Destructive Move",
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4158.pdf",
    "date": "October 2014"
  },
  "P1029R3": {
    "authors": [ "Niall Douglas" ],
    "title": "move = bitcopies",
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1029r3.pdf",
    "date": "January 2020"
  },
  "P0308R0": {
    "authors": [ "Peter Dimov" ],
    "title": "Valueless Variants Considered Harmful",
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0308r0.html",
    "date": "March 2016"
  },
  "IIFE": {
    "authors": [ "Bartlomiej Filipek" ],
    "title": "IIFE for Complex Initialization - C++ Stories",
    "href": "https://www.cppstories.com/2016/11/iife-for-complex-initialization/",
    "date": "October 2016"
  },
  "D2839R1": {
    "authors": [ "Brian Bi", "Joshua Berne" ],
    "title": "Nontrivial Relocation via a New owning reference Type",
    "href": "https://isocpp.org/files/papers/D2839R1.html",
    "date": "June 2023"
  },
  "P2665R0": {
    "authors": [ "Bengt Gustafsson" ],
    "title": "Allow calling overload sets containing T, const T&",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2665r0.pdf",
    "date": "October 2022"
  }
}
</pre>
