<pre class='metadata'>
Title: Relocating prvalues
Revision: 4
Audience: LEWG, EWG
Status: P
Group: WG21
ED: https://htmlpreview.github.io/?https://github.com/SebastienBini/cpp-relocation-proposal/blob/main/relocation.html
Shortname: P2785
Editor:
  SÃ©bastien Bini, Amadeus, sebastien.bini@gmail.com
  Ed Catmur, ed@catmur.uk
Markup Shorthands: markdown yes, biblio yes, markup yes
Abstract:
  This paper proposes several mechanisms to enable real relocation in C++.
  We cover several topics, such as trivial relocatibility, container optimizations,
  supports for relocate-only types, library changes and the impact of the existing code base.
Date: 2023-06-14
</pre>

# Overview # {#intro}

Move semantics were introduced with C++11, and have improved the language in
many aspects. However they have also brought their lot of defects:

- `std::move` does not move ;
- moved-from objects are in an unspecified state, and more often than not,
    must not be reused ;
- constant objects cannot be moved ;
- classes that want to support move-semantics must either have a natural empty
    state (like strings, containers or smart pointers)
    or force one into their design, usually creating a loophole in their class invariant.

We propose to resolve all these issues with a new kind of operation: "relocation".
Relocation is the operation of constructing a
new target object while simultaneously destructing the source object.
Relocation will happen thanks to a new keyword `reloc` and a new relocation
constructor (with signature `T(T)`).

```c++
// with: void foo(non_null<unique_ptr<T>>)

non_null<unique_ptr<T>> const ptr{new T};
ptr->do_stuff();
foo(reloc ptr);
// ptr cannot be reused or else the program is ill-formed
```

This tackles every flaw not solved by move-semantics:

- `reloc` does perform the relocation ;
- relocated objects cannot be re-used, or else the program is ill-formed ;
- relocation disregards cv-qualifiers, so constant objects can be relocated ;
- classes that want to support relocation can do so without breaking their
    class invariant, as the relocated-from object is simultaneously destructed.

Another major addition of this proposal is the object decomposition feature.
Object decomposition enables to relocate data members of compound types
(such as `std::pair`) and to easily write used-defined relocation constructors
and relocation assignment operators.

```c++
pair<std::string const, int> const keyValue reloc = extractKV();
storeKey(reloc keyValue::first);
```
```c++
template <class First, class Second>
class MyPair
{
public:
    First first;
    Second second;

    // user-defined relocation constructor (could have been defaulted)
    MyPair(MyPair rhs reloc) : first{reloc rhs::first}, second{reloc rhs::second} {}
};
```

The `reloc` keyword in the object definition indicates that the object
is *decomposed*, which allows the relocation of its subobjects with `reloc`.

This proposal introduces:

- two new special member functions: a relocation constructor `T(T)` and a relocation
    assignment operator `T& operator=(T)` ;
- a new keyword: `reloc` which backs a new operator: `reloc` and the object
    decomposition feature ;
- slight changes to overload resolution rules ;
- might introduce ABI breaks to some functions (opt-in).

This proposal does not introduce a new value category: instead it completes C++
tripartite value system as we propose relocation to happen from prvalues.

## Changes from previous revisions of P2785 ## {#changes}

### Changes from P2785R3 ### {#changes-from-r3}

#### Motivation #### {#changes-from-r3-motivation}

The motivation section is more complete, giving more explanations, describing
where today's C++ falls short, how we intend to improve, and each time illustrated with an
example.

#### Generalization of object decomposition #### {#changes-from-r3-dot-reloc}

One of the major changes we introduced is the generalization of the decomposition
feature, which was introduced by the "decomposing functions".
The `reloc` keyword can now be used to decompose any object, not only
the `this` parameter of a member function.
This has several advantages:

- it greatly simplifies the writing and the understanding of the relocation constructor
    and reloc assignment operator ;
- it simplifies the handling of relocate-only subobjects in user code ;
- it removes the *decomposing functions* feature as they are being replaced by
    a more generic object decomposition feature ;
- the whole proposal is more unified as all those changes are now built on top
    of the *object decomposition* feature.

#### Value parameter ownership rule #### {#changes-from-r3-value-param-ownership}

In P2785R3, we mandated that a function taking a relocate-only type as value
parameter **must** have control over its lifetime. This might break some ABIs
on rare occasions, but in a controlled way.

In R4, we take a slightly less conservative approach: *any function
that takes a parameter by value, whose type provides a relocation constructor*
**but no move constructor**, *must have control over the lifetime of that parameter.*

Discussion about this change is detailed in the
[reloc with function parameters](#reloc-with-function-param)
section.

#### Library changes #### {#changes-from-r3-stl}

In P2785R3, we enumerated all the desired changes in the STL to properly
support relocation. Now the suggested library changes only contain the bare
minimum for library writers. A more comprehensive list of changes
will be proposed separately, depending on the reception of the current proposal.

### Changes from older revisions ### {#changes-from-older}

R0, R1 and R2 revisions are internal versions bumps that were
never officially presented.

# Motivation # {#motivation}

## More constness! ## {#const-vs-move}

Automatic objects are recommended by various guidelines to be constant, since a constant object
will not change throughout its lifetime, simplifying reasoning about program state both for
humans (coders, reviewers, maintainers) and for machines (compilers, tooling).
In addition when used in class design, `const` on member functions and data members
enables to explicitly state class invariants. Last, allowing an object
to be `const` throughout its lifetime but give up its resources at the end of its lifetime allows
for better, safer code.

However `const` usefulness is greatly diminished because of move-semantics.
The move constructor cannot work with a constant source object.
Hence for those, the program either
silently falls back to calling their copy constructor, or is simply ill-formed...

```c++
// with: void bar(A);

A const a = someFunc();
bar(std::move(a)); // silently calls A's copy ctor, performing a deep copy...
```

Declaring an object with `const` may have unwanted side-effects. As a consequence:

- some developers will use `const` to naively declare constant objects as so - *as one would
    expect from the language* - while being unaware of the side-effects. This may
    lead to unoptimized code, with the copy constructor being called *silently*
    while `std::move` is explicitly called ;
- knowledgeable developers will rather not use it if they can foresee the
    negative side-effect, which leads to poorer code (see the benefits of `const`
    described above), but can make use of the move constructor.

This is a missed opportunity and it leads to poorer code. The
proposed relocation semantics solves this problem: constant objects can be relocated,
they are just destroyed when done so.

```c++
A const a = someFunc();
bar(reloc a);
```

### Constant local variables cannot be moved ### {#const-var}

We also have to consider that the Immediately Invoked Function Expressions (IIFE)
decouples the possibilities to declare constant variables (even when they have
a complex initialization routine), were they not hindered down
by `std::move`.

Consider the following code snippets:

<table>
<tr><th>Before</th><th>Constified + relocation (IIFE)</th></tr>
<tr>
<td valign="top">
```c++
void foo(A a, B b, C c);

void bar()
{
  A a = getA();

  B b = getB(a);
  b.processData();

  C c = getC(a.token(), b);
  c.fetchAll();
  c.processData();
  c.finalize();

  foo(std::move(a), std::move(b),
    std::move(c));
}
```
</td>
<td valign="top">
```c++
void foo(A a, B b, C c);

void bar()
{
  A const a = getA();

  B const b = std::invoke([&] {
    B b = getB(a);
    b.processData();
    return b;
  });

  C const c = std::invoke([&] {
    C c = getC(a.token(), b);
    c.fetchAll();
    c.processData();
    c.finalize();
    return c;
  });

  foo(reloc a, reloc b, reloc c);
}
```
</td>
</tr></table>

NOTE: We expect the `reloc` operator to also multiply the
possibilities to declare constant variables, with or without the IIFE idiom:

<table>
<tr><th>Constified + relocation (no IIFE)</th></tr>
<tr>
<td valign="top">
```c++
void foo(A a, B b, C c);

void bar()
{
  A const a = getA();

  B b_mut = getB(a);
  b_mut.processData();
  B const b = reloc b_mut;

  C c_mut = getC(a.token(), b);
  c_mut.fetchAll();
  c_mut.processData();
  c_mut.finalize();
  C const c = reloc c_mut;

  foo(reloc a, reloc b, reloc c);
}
```
</td>
</tr></table>

The versions with `reloc` can benefit from constant variables.
Their initialization code
is strictly enclosed in the lambda expressions (IFFE version) or relocated
to their const version once initialized (no IFFE). By looking at the code, we
know that each variable will remain unmodified for the remaining of the function,
even when used in the initialization of other variables.

The `reloc` keyword relocates the objects to the parameter slots of `foo`. `a`,
`b`, and `c` have reached their end of life when the call to `foo` completes and
can no longer be used in `bar`. In particular, should `a`, `b` and `c` be relocatable,
their destructor will not even be called.

### Constant data members ### {#const-data-members}

It's not uncommon to find in production codebase things like this:

```c++
class SomeType
{
public:
    // some parameterized constructor
    // SomeType(...)

    SomeType(SomeType&&) = default;

private:
    std::string const _key1;
    std::string const _key2;
    int _val;
};
```

Here the developer innocently qualified `_key1` and `_key2` as constant.
In their mind, their value was never to change in the lifetime of the object.
This being part of the class invariant, it only feels natural to enforce the
class invariant in the code, with the `const` qualifier.

However the experienced developer will have noticed the incurred performance drawback:
the move constructor, because of `const`, will be forced to make a deep copy
of `_key1` and `_key2` (via std::string's copy constructor). This gives an even
bitter taste when we know that
the moved-from object will pretty likely be destructed right after, meaning
that the deep copy will have been done for nothing.

This issue is solved with relocation:

<table>
<tr><th>Before (fixed)</th><th>After</th></tr>
<tr>
<td valign="top">
```c++
class SomeType
{
public:
  // some parameterized constructor
  // SomeType(...)

  SomeType(SomeType&&) = default;

private:
  std::string _key1; /* const but cannot
    mark it so because of the
    move constructor */
  std::string _key2; /* const but cannot
    mark it so because of the
    move constructor */

  int _val;
};
```
</td>
<td valign="top">
```c++
class SomeType
{
public:
  // some parameterized constructor
  // SomeType(...)

  SomeType(SomeType) = default;

private:
  std::string const _key1;
  std::string const _key2;
  int _val;
};
```
</td>
</tr></table>

See how the code becomes clearer: class invariant can be written in the code
instead of comments, which leads to a code that is both more readable and
robust.

*This is not an isolated example*. In fact, we invite the reader to think of all
the places that could have benefited from a constant data member but didn't because
of this issue. How much clearer the code would have been, had you been able
to write `const`?

Let's illustrate this with a final example. Consider a `flat_map` implementation.
As a `flat_map` implements an associative container, we know for a fact that the keys
of that container will never change. We could write it quite easily in our class
invariant:

```c++
template <class Key, class Val>
class MyFlatMap
{
public:
    // [...]

private:
    std::vector<std::pair<Key const, Val>> _map;
};
```

However, as of today,
this will lead to a deep copy of some range of keys when a new item is inserted
anywhere but at the end of `_map`, or when `_map` needs to grow.
Support for relocation in the language (and in the STL) will enable to write
`const` with no performance hit.

## Support for relocate-only types ## {#reloc-only-support}

As of today, C++ provides very little support for class-types which provide
no copy and no move constructors. Such objects are impractical to handle, for they
can only be:

- constructed as a function local variable ;
- returned from said function if copy-elision is guaranteed ;
- constructed in-place in a node-based container ;
- or constructed in-place in the parameter slot of another function.

We cannot however, perform any operation that will move or copy the object to
another address in memory:

- we cannot pass such objects by value in the parameter slots of other functions,
    unless the object is constructed in the parameter slot.
- Such types cannot be stored in any non node-based containers. Node-based
    containers have a performance overhead as they require more
    memory allocations. The node-based property may not be desired by users
    but they are forced to pay for it anyway as there is no support for such
    types in other containers.

Relocation fixes those issues by bringing support for relocate-only types.
Thanks to relocation, relocate-only types can for instance be stored in a `std::vector`
or passed from functions to functions.

### Accidental relocate-only types ### {#motivation-accidental-relocate-only-types}

Some classes do need to be immovable by design (like `std::mutex`) ;
those types can perfectly remain so with this proposal. However there is still
the case of some types which are accidentally made immovable, because they are
being wrapped with another type, or merely because of their cv-qualifiers
(look no further than `const`).

Let's us consider the
`gsl::not_null<std::unique_ptr<T>>` case for a moment. `gsl::not_null` inhibits
the move constructor, as a moved-from pointer would be null and break the class invariant.
In turn `std::unique_ptr` inhibits the copy constructor because of its ownership policy.
Hence this type is non-copyable and non-movable. Another example is simply
`std::unique_ptr<T> const`, where the qualifier inhibits the move constructor...

Those objects are legitimate since
they improve code correctness (the user need not check whether they are empty,
or are sure the pointed address hasn't changed) and performance. However, we
choose not to use such types in our code because we know how impractical they
are to handle, especially if we know they will need to be moved.

This is once again a missed opportunity ; our proposal fixes this issue.
With the relocation
semantics in mind, this would be allowed: each time `gsl::not_null<std::unique_ptr<T>>`
or `std::unique_ptr<T> const`
are moved in memory, the previous instance is simultaneously destroyed (very often in practice,
this simply means the memory is moved as if by `memcpy`, and the memory occupied
by the source object just becomes uninitialized.
In particular, the source object's destructor is not called).

### Move constructor breaks class invariant ### {#motivation-never-empty}

In framework code it is a relatively everyday task to write helper classes that are
constructed to own some resource, passed around from place to place, and then destroyed,
cleaning up the resource in the destructor.

Move semantics for such classes requires
identifying or adding an appropriate empty state, writing a move constructor, and
adding checks to the destructor; all of these inhibit performance and are opportunities
to introduce bugs. Relocation would replace all of this with a single defaulted special
member function declaration.

For instance, consider a file descriptor class, which opens a file in its
constructor (throws in case of failure), and closes it in its destructor.

<table>
<tr><th>Before</th><th>After</th></tr>
<tr>
<td valign="top">
```c++
class FileDesc
{
public:
  // some parameterized constructor, which
  // guarantees _fd != -1 or else throws
  // FileDesc(...)

  ~FileDesc()
  { if (_fd != -1) ::close(_fd); }

  FileDesc(FileDesc&& rhs) noexcept :
    _fd{std::exchange(rhs._fd, -1)} {}

  FileDesc&
  operator=(FileDesc&& rhs) noexcept
  {
    _fd = std::exchange(rhs._fd, -1);
    return *this;
  }

private:
  int _fd;
};
```
</td>
<td valign="top">
```c++
class FileDesc
{
public:
  // some parameterized constructor, which
  // guarantees _fd != -1 or else throws
  // FileDesc(...)

  ~FileDesc() { ::close(_fd); }

  FileDesc(FileDesc) noexcept = default;

  FileDesc&
  operator=(FileDesc) noexcept = default;

private:
  int const _fd; //< can now be const
};
```
</td>
</tr></table>

The code on the right is easier to write, to maintain and to understand.
This is because there is no need to handle the *moved-from* state in which
`_fd == -1`. But first and foremost, the version with relocation benefits from
an **improved class-invariant**: it provides at all times a valid file
descriptor. This simplifies reasoning and usability throughout the code.

We didn't have this guarantee before because of the move-constructor: the `FileDesc`
class might not have held a valid file
descriptor, had it been moved-from before.

## Safety against use-after-move ## {#motivation-safer-use-after-move}

Moved-from objects are in an unspecified yet valid state. This is true even
in cases where there exists a natural empty state (like for `std::string` or
`std::vector`). For this reason, it is advised not to reuse a moved-from object
(that is to say, we let it die). However the language does not prevent from
reusing such objects,
which leaves the door open for mistaken uses, ... and sometimes with
disastrous consequences.

Consider for instance the *p-impl* idiom, which is commonly used by
library vendors to guard against ABI breaks. The `impl` pointer is allocated
in the constructor, but what about the move constructor? Understandably, to
avoid unnecessary allocations, library
vendors often choose to leave the `impl` pointer of the moved-from object set to the
null pointer. Unless the moved-from object is re-assigned to something valid,
any further access to its data will trigger the program termination!

This issue is fixed with relocation, as the language will forbid any reuse
of a relocated object. Reconsidering any *p-impl* implementation, the move
constructor could simply be dropped in favor of the relocation constructor, and
the `impl` pointer would always be valid.

External tools do exist to detect such `use-after-move` errors. However we believe
the language can only be improved if we reduce its reliance on external tools,
especially for things as embarrassing as memory safety. Also, tools are fallible
(they may not detect all issues, or may not at all be ran in some companies),
which is less true for compilers (you cannot not run a compiler).

## Early destruction ## {#motivation-early-dtor}

We sometimes need to trigger the destruction of an object early, before
its end of scope. It's often the case when a particular destructor side-effect
is wanted early:

```c++
std::experimental::scope_exit guard{[this] { updateMetrics(); }};
// [...]
if (someTest())
{
    // need to call updateMetrics before modifyMetrics!
    guard.release();
    updateMetrics();
    modifyMetrics();
}
// [...]
```

There is no clean mechanism to do this today in C++. One way is to wrap the
type into an `std::optional` and reset the optional when the destruction of the
contained object is wanted. Another is to move to a temporary.

As it is done with this paper, relocation provides a clean solution for this
case. [Discarded relocated objects are simply destructed](#discarded-reloc-expr), triggering the desired
effect.

<table>
<tr><th>Before (optional)</th></tr>
<tr>
<td valign="top">
```c++
std::optional guard = std::scope_exit{[this] { updateMetrics(); }};
// [...]
if (someTest())
{
    // need to call updateMetrics before modifyMetrics!
    guard.reset();
    modifyMetrics();
}
// [...]
```
</td>
</tr></table>
<br/>
<table>
<tr><th>Before (Temporary)</th></tr>
<td valign="top">
```c++
std::scope_exit guard{[this] { updateMetrics(); }};
// [...]
if (someTest())
{
    // need to call updateMetrics before modifyMetrics!
    { auto _ = std::move(guard); }
    modifyMetrics();
}
// [...]
```
</td>
</tr></table>
<br/>
<table>
<tr><th>After</th></tr>
<td valign="top">
```c++
std::scope_exit guard{[this] { updateMetrics(); }};
// [...]
if (someTest())
{
    // need to call updateMetrics before modifyMetrics!
    reloc guard;
    modifyMetrics();
}
// [...]
```
</td>
</tr></table>

This is not what motivates this proposal, but comes as an added bonus, which
we thought was worth mentioning.

## Teachability ## {#motivation-teachability}

It is a matter of some confusion for learners that a "moved-from" object still exists and is
accessible, but has an unspecified state. This leads to so-called "use-after-move" bugs, and
requires static analysis passes and coding guidelines to prevent. "What does `std::move` do?"
is, regrettably, a common "gotcha" question in a certain style of coding interview. In this
matter C++ compares unfavorably to other languages where the "move" operation is destructive
(if trivial) and bars further access to the source object.

## Versus trivial relocation ## {#motivation-vs-trivial-relocation}

As will be seen below, trivial relocation provides an incomplete solution to the issues
presented in this section. The primary concern is that of composability; an aggregate of
a self-referential type that cannot be trivially relocated (e.g. `std::string` in some
implementations) and a relocate-only type (e.g. a non-null `unique_ptr`) can neither be
relocated by move-and-destroy nor trivially relocated. Thus non-trivial relocation
emerges as a requirement.

## Library performance ## {#motivation-performance}

Finally, relocation and especially trivial relocation will bring performance boosts
in many situations. Other proposals make fine work at enumerating all the gains to be had
from trivial relocation (see in particular [[P1144R8]]). To summarize, the performance gains
are mainly in containers (std::vector::resize and the likes)
and code size gains from functions that use `std::swap`.

# Nomenclature # {#nomenclature}

We refer to the <a href="https://wg21.link/intro.defs">Terms and definitions</a> of the C++ Standard,
and to nomenclature introduced therein,
in particular the <a href="https://wg21.link/intro.object">object model</a>.
In addition, we define:

## Source and target objects ## {#src-and-target}

Relocation is the act of constructing a new instance while ending the lifetime of an existing one.
This allows destructively stealing its resources, if any.

The new instance is called the *target object*.
The existing instance whose lifetime is ended and whose resources
are stolen is called the *source object*.

## Destructed state ## {#dtor-state}

An object is to be in a *destructed state* if its lifetime has ended because:

- its destructor was called, or ;
- it was passed to as source object to its relocation constructor.

It is a
programming error to call the destructor of an object if it is already in a
*destructed state*.
As described in <a href="https://eel.is/c++draft/basic.life#9">[basic.life]</a>,
this has undefined behavior unless the object type is trivial, in which case its destructor
or pseudo-destructor is a no-op.

## Early destructible ## {#early-destructible}

The lifetime of function parameters is implementation-defined in C++, but it
is of most importance with relocation. Depending on the function call convention
or ABI, the function may or may not be in charge of the lifetime of its parameters.

An object is said to be *early destructible* with regards to a function `f`
if:

- the object is a local variable of `f`, not ref-qualified, and with automatic
    storage ;
- or the object is a parameter of `f`, passed by value, and that `f`
    has control over its lifetime ;
- or the object's destructor is a no-op.

We denote two main parameter passing conventions:

- *caller-destroy*: the call site is in charge of the lifetime of the
    value parameter passed in the function call ;
- *callee-destroy*: the function itself is in charge of the lifetime of its
    value parameters ;

Depending on the ABI choice, the convention can be per parameter, or apply
to all the function parameters. Other conventions may exist, and they are
still compatible with this proposal.

For instance, in a function with caller-destroy convention, none of its value
parameters are *early destructible*.
Likewise, with callee-destroy, all of its value parameters are
*early destructible*.
And last, regardless of the convention, all not ref-qualified, local variables
with automatic storage are *early destructible*.

# Comparison with existing proposals # {#compare}

This proposal introduces the `reloc` keyword, which allows users to explicitly
and safely relocate local variables in their code base.

This proposal is also one of the few (with [[P0308R0]]), to tackle the case of
relocate-only types. The `reloc` keyword thus becomes necessary to safely pass
around such objects in user code.

Also, all these proposals (but [[P0308R0]]) aim to optimize the move and destruct
operations into a single memcpy. But there are places where this optimization
could not happen, and we are left with suboptimized move constructor and destructor calls.

The relocation constructor that we propose offers a customization point, and
especially allows for a more optimized relocation technique than move and destruct.
If trivial, then it can be optimized into a `memcpy`.

## P1144R8: Object relocation in terms of move plus destroy by Arthur O'Dwyer ## {#compare-P1144R8}

[[P1144R8]] puts the focus on trivially relocatable types, and offers ways to
mark a type as trivially relocatable.

The current proposal has its own take on trivial relocatability that does not
rely on a class attribute. Instead the trivial relocatability
trait flows naturally from the new relocation constructor that we introduce. In short:
if a class type has a relocation constructor that is (explicitly) declared as defaulted or
is implicitly defined and not defaulted as deleted, and all of
its subobjects are trivially relocatable (or fully trivial), then the type
is trivially relocatable.

This approach is not prone to errors when compared to a class attribute,
which could be mistakenly overridden by some users on classes that are not
trivially relocatable.

Also, [[P1144R8]] does not account for relocate-only types. To some extend, trivially
relocatable types have minimal support as they could be trivially relocated in the
places where "move plus destroy" can be optimized. However:

- this only concerns trivially relocatable types ;
- there are places where the optimization cannot happen, and as such the object cannot be "relocated" ;
- this poses a composability issue. If a relocate-only (non-movable and non-copyable), trivially-relocatable type
    is a data member of a class that also has other non-trivially-relocatable data members, then the
    enclosing class becomes non trivially relocatable, while remaining relocate-only.
    This renders the enclosing class impractical to use without proper support
    for relocate-only types.

In this proposal we reuse [[P1144R8]]'s `std::relocate` function, except that we
name it `std::reloc_and_uninitialize`.

## P0023R0: Relocator: Efficiently moving objects by Denis Bider ## {#compare-P0023R0}

The Relocator introduced in [[P0023R0]] is similar to the proposed relocation constructor.
However P0023R0's Relocator is not viewed as a constructor. Instead, it is a special
function that can be invoked in lieu of move plus destroy where possible.

However this brings again suboptimal support for relocate-only types. Indeed [[P0023R0]]
does not force relocation to happen in all cases, and falls back to move+destroy paradigm
when relocation cannot happen.

A typical example is when relocating a function parameter:

```c++
void sink(T);
void foo(T x) { sink(x); }
```

Here, under the terms of [[P0023R0]], relocation may not happen because of ABI
constraints (if `x` is not *early destructible*).
This will cause `foo` to fallback to a move+deferred destroy paradigm.

This proposal has another take on this issue: if `T` has a relocation constructor
but no move constructor, then any function
that takes a `T` parameter by value is required to have an ABI that allows it to
relocate
its input parameter (e.g. callee-destroy ABI).

This proposal also introduces the `reloc` keyword that is here to trigger
the relocation, and protect against the reuse of the relocated object.
The solution then becomes:

```c++
void sink(T);
void foo(T x) { sink(reloc x); /* x can no longer be used. */ }
```

Moreover, the proposed syntax for invoking [[P0023R0]]'s relocator is low-level and
prone to error:

```c++
T x;
alignas(T) char buf[sizeof(T)];
T* y = new (buf) >>T(x);
```

Here the lifetime of `x` has been ended as if by a destructor call, but the language
is not aware of this,
so firstly the user may erreoneously refer to `x` as if it was within its lifetime,
and secondly if an object is not recreated in `x` by the time the block
exits, the behavior is undefined by <a href="https://eel.is/c++draft/basic.life#9">[basic.life]/9</a>.
Likewise, the language is not aware of the existence of `*y` so will not call its
destructor; the behavior is then possibly undefined under <a href="https://eel.is/c++draft/basic.life#5">[basic.life]/5</a>.
In contrast, the present proposal would write the above as:

```c++
T x;
T y = reloc x;
```

Here the use of the `reloc` keyword ensures that the language is aware that the lifetime
of `x` has finished, so the destructor only of `y` is called at scope exit.

## N4158: Destructive Move by Pablo Halpern ## {#compare-N4158}

[[N4158]] proposes a customizable function `std::uninitialized_destructive_move`,
that is somewhat similar to the relocation constructor, but is a pure library solution.

It has several drawbacks :

- relocation can only happen if this function is called explicitly. Typically this function
    would be called in container implementation. But then we cannot relocate
    local variables with this.
- users can write their own `uninitialized_destructive_move` overload, but this
    is terrible for composability. Classes that have a subobject with a
    custom `uninitialized_destructive_move` overload do not get a
    `uninitialized_destructive_move` overload generated for free.
- `uninitialized_destructive_move` cannot be default-generated with memberwise
    relocation.

## P1029R3: move = bitcopies by Niall Douglas ## {#compare-P1029R3}

[[P1029R3]] enables a special bitcopies move constructor for types that are trivially relocatable.

Like the other proposals [[P1029R3]] does not provide support for relocate-only types
(it suffers from the same drawbacks as [[P1144R8]] in that regard).

## P0308R0: Valueless Variants Considered Harmful by Peter Dimov ## {#compare-P0308R0}

We only consider the "pilfering" proposition from [[P0308R0]].
P0308R0's pilfering shares some similarities with the current proposal,
as it is an attempt to support relocate-only types as a pure library solution.

We believe a language solution is best suited here:

- the source object is effectively destroyed by the relocation: its destructor
    is not called. This can hardly be achieved by a library solution ;
- the `reloc` keyword makes sure the relocated object is not reused,
    while `std::pilfer` does not ;
- the pilfering constructor is inconvenient to write as we need to unwrap from
    `std::pilfered` and rewrap to propagate to base classes and data members ;
- as a library solution, the pilfering constructor cannot be defaulted ;
- trivial relocation is not possible with pilfering, which makes [[P0308R0]] miss
    the performance boost that is so longed for.

## D2839R1: Nontrivial Relocation via a New *owning reference* Type by Brian Bi and Joshua Berne ## {#compare-D2839}

[[D2839R1]] is very close in spirit and mechanism to this paper. We consider the
addition of an "owning reference" to be an unnecessary complication to the type
system that would impose a burden throughout library code. We refute the claim
that a prvalue occupying storage constitutes a fourth value category; in our
model, the lvalue that previously occupied that storage ceases to exist and a
new prvalue is formed, which may come to occupy that storage (if relocation is
elided) or distinct storage (in the general case).

We are intrigued by the claim that an owning reference can provide superior
performance when passing a variable up the stack, compared to repeatedly relocating
it from caller to callee, but believe that in practice such gains would be minimal
and liable to be eliminated via optimization, while our model offers the possibility
of improved locality, since the relocated object will reside directly in the leafmost
function's stack as opposed to being accessible only via indirection.
Alternatively, this concern can be regarded as an implementation choice.
Implementations where only the address of the object is
passed down from caller to callee are [still possible with our model](#0-copy).

Otherwise, the paper has some minor differences in naming (e.g. `std::force_relocate`
for what we call `std::reloc_and_uninitialize`) that could easily be reconciled in either
direction.

# Proposed language changes # {#lg-changes}

## reloc operator ## {#reloc-operator}

This paper suggests to introduce a new keyword, named `reloc`. `reloc` acts as a
unary operator that can be applied to named, local, complete objects (in other
words: function-local non-static variables and, with some restrictions,
function parameters and
identifiers introduced through the syntax of structured binding declarations).

`reloc obj` does the following:

- if `obj` is ref-qualified, then performs perfect-forwarding
    (as if by `static_cast<decltype(obj)>(obj)`) ;
- otherwise returns a temporary obtained from the source object, constructed
    from the relocation, move or copy constructor.
    - If the relocation constructor
        was called, then the source object has been destroyed.
    - If not, then the destructor of the source object will be implicitly
        invoked as soon as the implementation permits, if possible at the end
        of the full-expression evaluation ;
- in all cases, marks the "early" end-of-scope of the variable `obj`, preventing
    reuses of the variable.

### reloc to perfectly forward all value categories ### {#reloc-perfect-fwd}

`reloc` can be used on ref-qualified objects to enable perfect forwarding.
If the source object is ref-qualified, then it performs the following cast:
`static_cast<decltype(obj)>(obj)`.

This makes `reloc` the one operator to use to perfectly forward objects, whether
they are ref-qualified or not.
It also prevents from use-after-move and use-after-relocation errors.

### reloc in constexpr ### {#reloc-constexpr}

`reloc` can be used in constexpr functions and constant-evaluated expressions.

### reloc produces a prvalue ### {#reloc-value-change}

Unlike `std::move`, `reloc` does perform some form of relocation.
Through misuse of language, we say that `reloc` returns a temporary object,
created by relocation, move or copy constructor. In truth,
given that the source object is not ref-qualified, `reloc` merely
changes the value category of the source object from lvalue to prvalue
(if the source object is ref-qualified, see [above](#reloc-perfect-fwd)).

It is this value category change that *may* trigger the creation of a temporary
object. However, optimizations may happen that will elide the creation of the
temporary entirely.

If the temporary is materialized, then it is ideally constructed by the relocation
constructor, destroying the source object in the process. However, `reloc` does
not force the use of the relocation constructor. The constructor which will be used
to create the temporary is selected by overload resolution. `reloc` merely enables
the relocation constructor to be selected because of the value category change
(the relocation constructor has the signature `T(T)`, meaning it will be preferred
when constructed from a prvalue, with our new [overload resolution rules](#overload-resolution)).

### Relocation constructor discardment with function parameters ### {#reloc-with-function-param}

Function parameters' lifetime ownership is implementation-defined in C++.
Depending on the ABI in use, a function parameter may be destroyed at caller-site
(upon function return, at the end of the full-expression evaluation),
or at callee-site (before the function exits).

Enforcing the relocation constructor when `reloc` is used on a function
parameter, which would effectively destroy the function parameter,
will not be compatible with all existing ABIs (see Itanium ABI for
instance). We could propose this nonetheless, by stating that the relocation
constructor must be used if declared.
However we fear this would propagate ABI changes with too little control
and the proposal would meet to much resistance to go further.

We could take a very conservative approach, and mandate the ABI change
for *relocate-only* value parameters. Such types don't exist today, so the
likelihood of breaking any existing ABI is relatively small. However this may
lead to suboptimized code, where `reloc` would perform worse than move semantics.
Consider now the following code:


<table>
<tr><th>With move semantics</th><th>With relocation</th></tr>
<tr>
<td valign="top">
```c++
struct A
{
    // [...]
    A(A const&) = default;
    A(A&&) = default;
};

void bar(A);
void foo(A a)
{
    bar(std::move(a));
}
```
</td>
<td valign="top">
```c++
struct A
{
    // [...]
    A(A const&) = default;
    A(A&&) = delete;
    A(A) = default;
};

void bar(A);
void foo(A a)
{
    bar(reloc a);
}
```
</td>
</tr>
</table>

Since `A` has a copy constructor, it is not relocate-only. With the conservative
approach, we have no guarantee
that `foo` has the ownership of `a`. Hence `reloc a` here may simply call the copy
constructor, as the ABI may not permit otherwise.

To prevent such a pessimization, developers will be tempted to add a move constructor
to `A`, ensuring that at least the move constructor is called in such cases.
Doing so goes against what we are trying to achieve with this proposal. One
of our main motivation points is that the move constructor doesn't fit all classes
that could yet still be moved. We don't want users to declare one anyway
to avoid pitfalls.

Thus in an attempt to make a compromise between ABI compatibility and acceptable
support for relocation, we take a slightly less conservative approach.
We would like function parameters passed by value, whose type declares
a relocation constructor but no move constructor, to be *early destructible*.
As the C++ standard leaves this area implementation-defined, we are going to force
this another way, although the effect will likely be the same:

**Rule:** If the source object is a function parameter passed by value, and its type
provides an eligible move constructor, then the relocation constructor (if any)
may be discarded during overload resolution. Whether the relocation constructor
is discarded is *implementation-defined*.

Note: *eligible* is defined in
<a href="http://wg21.link/special#def:special_member_function,eligible">[special]</a>.

As consequences of that rule, we get the following:

- *early destructible* source objects are always guaranteed that
    their relocation constructor (if eligible) is called ;
- source objects which are not *early destructible*, and have both an eligible move
    and relocation constructor, will not be relocated. Instead the move constructor
    will be invoked by `reloc`.
- source objects which are function parameters, and have an eligible relocation
    constructor but no move constructor, are forcibly *early destructible*.

NOTE: Types which have a relocation constructor but no move constructor
still don't exist today, so the likelihood of breaking existing ABIs is still
small.

With this updated rule, `reloc a` from our previous example will effectively
call the relocation constructor. And users can safely migrate from the move
constructor to the relocation constructor if they wish to without any gotchas.

Note that this rule still isn't optimal. Consider the following code,
having in mind a putative `std::pair` with a relocation constructor:

```c++
void bar(pair<const string, int>);

void foo(pair<const string, int> val)
{
    val.second *= 2;
    bar(reloc val);
}
```

`val` has the three constructors, so our rule does not apply. The ownership
of `val` by `foo` is implementation-defined. If `foo` doesn't own `val`, then
`reloc val` will call the move constructor, making a full string copy
(because of `const`). Contrary to our previous example which motivated us to
update the parameter ownership rule,
here `reloc` may call `std::move` so we haven't worsened the situation.

### Early end of scope ### {#reloc-src-obj-lifetime}

As we have seen `reloc` may trigger a call to the relocation constructor.
At the moment of the call, the source object is in a destructed state.
Thus it is unsafe to reuse it after the `reloc` expression completes.

To prevent uses of a potentially destructed object, we state that the program is
**ill-formed** if the source object is reused after being passed to `reloc`,
regardless of whether the relocation constructor was called. For a detailed
explanation of how this is enforced, please refer to [the dedicated section](#ill-formed-reuse).

NOTE: The rest of this section only applies to `reloc` operands that are
not ref-qualified.

That early end of scope provides us with a strong guarantee. We know that the
source object cannot be reused, and as such we may be tempted to call the
destructor of the source object early (in cases where the relocation constructor
was not selected). For instance, we may want to destroy the
source object at the end of the full-expression evaluation, when temporaries are
destroyed. It would be the natural thing to do:

- for consistency, if the object had been relocated (with the relocation constructor),
    then it already reached its end of life. The same could be expected for
    copy and move constructor ;
- the source object cannot be reused anyway, why defer its destruction?

Unfortunately this cannot be done without breaking some ABIs, especially because
the source object may not be *early destructible*.
Let us see what happens if we allow the early destruction of function parameters
to be *implementation-defined*:

- If `reloc` calls the copy constructor:
    all the resources owned by the source object are *copied* to the target object.
    As such if the destructor has side-effects, they may be applied twice, once
    for the destruction of each object. Depending on the ABI, the destructor
    of the source object may be called at the end of full-expression, or deferred
    until control returns to the caller.
    We can see that the destruction time of the source object would be
    *implementation-defined* (as of today). Remember that we might have side-effects from the
    destructor, so the moment those side-effects will be applied will also
    be *implementation-defined*.
- If `reloc` calls the move constructor:
    all the resources owned by the source object are *transferred* to the target
    object. As such if the destructor has side-effects, we expect them to be
    applied only once, at the destruction of the target object. We expect the
    source object destructor to detect the *moved-from state* and return, without
    triggering any side-effects.
    Under those reasonably safe assumptions, it doesn't matter when the source
    object is destroyed, be it at its natural end of scope, or at the end of the
    `reloc` expression.

As of today, the lifetime of function parameters is already *implementation-defined*.
As such, code that relies on the timing of a destructor side-effects of a
function parameter is already *implementation-defined*.
We don't feel we will worsen the
situation with `reloc`, even with copy-only source objects.
We prefer to keep this behavior implementation-defined, same as
today, except that the source object may also be destructed early, at the end
of the full-expression evaluation that contained `reloc`.

In conclusion, we establish the following rules when a `reloc` expression
is evaluated:

- **Rule:** If the source object passed to `reloc` is not a function parameter, and
    the source object has not been relocated by its relocation constructor, then
    its lifetime ends (i.e. its destructor is implicitly invoked) at the end of the
    full-expression evaluation containing `reloc`.
- **Rule:** If the source object passed to `reloc` is a function parameter, and
    the source object has not been relocated by its relocation constructor, then
    its destructor must be implicitly invoked at the end of the full-expression
    containing the evaluated `reloc` expression, upon function exit,
    or at the caller site at the end of the
    full-expression evaluation. Which it is is *implementation-defined*.

We acknowledge that with `reloc` expressions we allow for more code to be executed between
the end of the full-expression which contained `reloc`,
and when control returns to the caller site.
One might argue that we exacerbate this destruction time discrepancy between
implementations. However please keep in mind that:

- this only concerns copy-only value parameters, whose destructor have a side-effect, and
    are passed to `reloc` ;
- any arbitrary amount of code could still be executed today upon function exit,
    at the end of the full-expression evaluation that made the function call,
    at caller-site. Indeed, all function parameters need to be destructed,
    and their destruction order remains *implementation-defined* as of today,
    leaving the door open for any arbitrary code from a destructor,
    to be executed before the destructor of our source object ;
- code that relies on a precise destruction timing of a function parameter is
    poor code as this timing is implementation-defined, even today.

### Illegal uses of reloc ### {#reloc-illegal-uses}

A `reloc` statement is ill-formed if any of the following conditions is met:

- its parameter is not the name of a variable ;
- the source object is not a *complete object* ;
- the source object is not ref-qualified and does not have local storage
    (i.e. not a local function variable and not a function parameter passed by
    value) ;
- the source object is not ref-qualified and does not have an accessible relocation,
    move, or copy constructor ;
- the source object is a structured binding (and not an identifier introduced in a
    <a href="#structured-decomposition">structured decomposition declaration</a>) ;
- the source object is a lambda capture (unless the lambda closure object has been [decomposed](#decompose-lambda)) ;
- the source object is a virtual base of a [decomposed object](#decomposed-state) ;


In particular, the `reloc` statement is well-formed if the source object is a
member of a function-local anonymous union.

For instance:
```cpp
void foo(std::string str);
std::string get_string();
std::pair<std::string, std::string> get_strings();

std::string gStr = "static string";

void bar(void)
{
    std::string str = "test string";
    foo(reloc str); // OK: relocation will happen given that std::string has a reloc ctor
    foo(reloc gStr); // ill-formed: gStr does not have local storage

    std::pair p{std::string{}, std::string{}};
    foo(reloc p.first); // ill-formed: p.first is not a complete object, and not the name of variable

    foo(reloc get_string()); // ill-formed: not the name of variable
    foo(reloc get_strings().first); // ill-formed: not a complete object, and not the name of variable
}

void foobar(const std::string& str)
{
    foo(reloc str); // OK: str is passed by reference.
    // Note that the lifetime of the referent of str is unaffected.
}
void foobar(std::string* str)
{
    foo(reloc *str); // ill-formed: *str is not the name of variable
}
void foobar2(std::string* str)
{
    foobar(reloc str); // OK, the pointer itself is relocated (not the pointed value)
}

class A
{
    std::string _str;
public:
    void bar()
    {
        foo(reloc _str); // ill-formed: _str is not a complete object and does not have local storage
    }
};
```

### Discarded reloc expressions ### {#discarded-reloc-expr}

`reloc` expressions can be discarded: `reloc obj;` (note the semi-colon).
We expect this statement to have the same effect as ` { auto _ = reloc obj; } `.
A temporary is constructed from the source object and is then destructed at scope
exit (that is right-away). The source object is destructed right-away,
or at later stage if it's a function parameter (*implementation-defined*).
We will discuss here the effects of such expressions.

Materializing a temporary whose only goal is to be
destroyed is suboptimal.
We might be tempted to optimize away the temporary
materialization, and only call the destructor of the source object.

This optimization is authorized (whether it is performed is *implementation-defined*).
If the optimization does not happen, then
the temporary must be materialized and destroyed at the end of full-expression
evaluation. The lifetime of the source object follows
[the established rules](#reloc-src-obj-lifetime).

Note that, if the temporary is materialized and that the source object:

1. *has an eligible relocation or move constructor*: In this case,
    all the owned
    resources of the source object will be *transferred* to the temporary. For this
    reason, we expect that destroying the temporary *will have the same effects
    as* destroying the source object directly.
2. *only has an eligible copy constructor*:
    all the owned resources of the source object will be *copied* to the temporary.
    This is very likely a useless operation.
3. Other cases need not to be considered, as the `reloc` expression requires the
    source object to declare one of the three constructors.

NOTE: If the source object is a copy-only function parameter, then implementations
are encouraged to emit a warning on discarded reloc statements, as if `reloc`
had the `[[nodiscard]]` attribute. This is because the intent of this statement
is likely to trigger the destruction of the source object (or to trigger the
effect of the destructor, if a move-constructed temporary is materialized and
destroyed). But whether this statement indeed calls a destructor early
(or has any side-effect) for copy-only function parameters is
*implementation-defined*.

To summarize, it means that `reloc obj;` has the following behavior:

- If `obj` is *early destructible* then:
    - The temporary is likely elided, effectively only calling the
        destructor of `obj`.
    - Otherwise a temporary is initialized from the
        source object, and then destructed.
- Otherwise:
    - A temporary is move-or-copy-constructed and then destructed.
    - The source object destruction is deferred until the function returns.

For instance this gives:
```c++
void do_something_01(std::mutex& m)
{
    std::lock_guard guard{m};
    if (!some_test())
    {
        reloc guard; // ill-formed: no relocation, move or copy constructor
        log("thread ", std::this_thread::get_id(), " failed");
        return;
    }
    bar();
}
void do_something_02(std::unique_lock<std::mutex> guard)
{
    if (!some_test())
    {
        reloc guard; /* well-formed: lock is released, either by calling the
            destructor directly, or by constructing a temporary from
            guard (by relocation or move) and destructing it. */
        log("thread ", std::this_thread::get_id(), " failed");
        return;
    }
    bar();
}
void do_something_03(std::mutex& m)
{
    std::unique_lock guard{m};
    if (!some_test())
    {
        reloc guard; /* well-formed: temporary is likely elided regardless of
            do_something_03's ABI, only calling the destructor of guard. */
        log("thread ", std::this_thread::get_id(), " failed");
        return;
    }
    bar();
    /* guard destructor is called only if it wasn't passed to reloc. */
}
// assuming non_null does not have a relocation constructor
void do_something_04(non_null<shared_ptr<int>> copyOnlyObj)
{
    if (!some_test())
    {
        reloc copyOnlyObj; /* well-formed but its effects are implementation
            defined. Will emit a warning. */
        return;
    }
    bar();
}
```

### Relocation elision ### {#reloc-elision}

Relocation may be elided. This is intended to work in much the same way as the
named return value optimization; for example:

```c+
void f(std::string s);
void g() {
    std::string s;  // may be created in f's argument slot
    f(reloc s);  // relocation may be elided
}
```

More formally, whether performed by relocation, move or copy constructor,
the temporary created by the `reloc` expression may not be materialized if:

1. the implementation can ensure that the source object is created at
    the address to be occupied by the temporary object ;
2. and the source object is *early destructible*.

For instance,
given the following function `void sink(T)`, let us observe the effects of the
`sink(reloc obj)` expression (`obj` being not ref-qualified) across different
ABIs and object lifetime ownerships:

<table>
<tr><th>`sink` ABI and object lifetime ownership</th><th>Effect</th></tr>

<tr>
<td valign="top">
`sink` ABI is callee-destroy and `obj` is *early destructible*
</td>
<td valign="top">
Elision may happen, in which case `sink` will end the lifetime of `obj`.
</td>
</tr>

<tr>
<td valign="top">
`sink` ABI is callee-destroy and `obj` is **not** *early destructible*
</td>
<td valign="top">
Elision cannot happen as `obj` cannot be destructed. A new instance is
move-or-copy-constructed from `obj`, passed to `sink`.
</td>
</tr>

<tr>
<td valign="top">
`sink` ABI is caller-destroy and `obj` is *early destructible*
</td>
<td valign="top">
Elision may happen, in which case the destructor of `obj` is implicitly invoked
at the end of the full-expression evaluation.
</td>
</tr>

<tr>
<td valign="top">
`sink` ABI is caller-destroy and `obj` is **not** *early destructible*
</td>
<td valign="top">
Elision cannot happen, a new instance is move-or-copy-constructed from `obj`, passed to `sink`.
</td>
</tr>

</table>

<!--

Let us consider a final example with the following function `void xvsink(T&&)`,
invoked through the `xvsink(reloc obj)` expression:

<table>
<tr><th>Object lifetime ownership</th><th>Effect</th></tr>

<tr>
<td valign="top">
`obj` is *early destructible*
</td>
<td valign="top">
Elision is very likely to happen, in which case an rvalue reference of `obj` is sent to `xvsink`
and the destructor of `obj` is implicitly invoked
at the end of the full-expression evaluation.
</td>
</tr>

<tr>
<td valign="top">
`obj` is **not** *early destructible*
</td>
<td valign="top">
Elision cannot happen, a new instance is move-or-copy-constructed from `obj`,
whose rvalue reference is passed to `xvsink`.
</td>
</tr>

</table>

-->

#### Achieving 0-copy with relocation elision and cooperative ABI #### {#0-copy}

Let `f` be a function which takes an object of non-trivial type `T` as value parameter:
`void f(T);`. To call `f`, the Itanium ABI
chooses to pass the parameter by address. The following happens in the caller:

1. a temporary object is created, initialized from the expression passed in the
    matching parameter slot of the function call expression.
1. `f` is called, passing the address of the temporary object instead
    of the whole object bytefield.
1. when the function returns (normally or through an exception), the temporary
    object is destroyed.

Now, let us say that `T` has migrated to relocation semantics: it has a
relocation constructor, but no move constructor. This alone makes any object of
type `T` *early destructible*, and hence all eligible to relocation elision.
Hence, with the updated Itanium ABI and with relocation elision,
the expression `f(reloc obj)` translates
into a call to `f`, merely forwarding the address of `obj`. No temporaries are
created.

For instance, in the following snippet:
```c++
vector<T>::push_back(T x) // putative std::vector push_back
{
  ensures_space();
  new (_end++) T{reloc x};
}

void bar(T x)
{
  get_vector().push_back(reloc x);
}

void foo(T x)
{
  if (test()) bar(reloc x);
}

// in some function:
T x;
foo(reloc x);
```

Translates into:
```c++
vector<T>::push_back(T* x)
{
  ensures_space();
  memcpy(_end++, x, sizeof(T)); // given that relocation is trivial
}

void bar(T* x)
{
  get_vector().push_back(x);
}

void foo(T* x)
{
  if (test()) bar(x);
}

// in some function:
T x;
foo(&x);
```

This allows the object to be created once, and forwarded by address until it
is relocated inside a vector. No useless copies are created.
Yet no new value categories were introduced, all happened with value-semantics,
and the code is safe as static analysis ensures the object is not reused after
`reloc`. This can be achieved only because of relocation elision and the fact
that value parameters are passed by address in Itanium ABI.

This proposal does not mandate this implementation, we only highlight that such
an implementation is possible. Also, if this proposal is approved, it will create
an opportunity to other ABIs to migrate to something similar,
should they wish to benefit from this optimization.

## Object decomposition ## {#decomposed-object}

This proposal introduces the concept of object decomposition.
Only complete objects can be *decomposed*. An object is *decomposed*
if the `reloc` keyword appears in its definition.
If an object is *decomposed*, then it ceases to exist, but all
its subobjects are considered as complete objects.

### Declaration and definition ### {#decomposed-object-decl}

In an object definition, the `reloc` keyword can be specified after the
object name:

```c++
T const value reloc = getValue();
```

`reloc` cannot be used in an object declaration or else the program is ill-formed.
Note that `reloc` is not part of the C++ type system. This is emphasized by the
fact that `reloc` can only be specified *after* the object name.

`reloc` can only be used in an object definition
(with `T` the type of the object being defined) if:

- the object is a complete object with automatic storage ;
- the object is a function parameter or a function-local object ;
- `T` is a non-union class-type ;
- `T` is not ref-qualified.

If any of the above conditions is not verified, then the definition is ill-formed.
For instance:

```c++
struct X
{
    std::pair<int, std::string> m reloc; // ill-formed
};

static std::pair<int, std::string> g reloc; // ill-formed

void foo(T const& a reloc) {} // ill-formed (ref-qualified)
void foo(T const* a reloc) {} // ill-formed (not a class-type)
void foo()
{
    T const a[] reloc = { }; // ill-formed (not a class-type)
}

// But
void foo(T const obj reloc) // well-formed if T is a class-type
{
    T obj2 reloc; // well-formed if T is a class-type
}
```

In particular, functions must be declared without `reloc` on their parameters,
while the function definition does. In other words, `reloc` is not
part of the function signature, and is only effective in the function
definition. For instance:

```c++
struct X
{
    void foo(T obj);
};

void X::foo(T obj reloc) // well-formed
{
    // ...
}

static_assert(std::is_same_v<decltype(&X::foo), void (X::*)(T)>); // ok
```

If several objects are declared in the same expression, then `reloc` needs to be
repeated for each object which the user wants to decompose:

```c++
T const value reloc = getValue(0), value2 = getValue(1), value3 reloc = getValue(2);
// only "value" and "value3" are decomposed.
T const c, *d reloc; // ill-formed, d is not a class-type
```

### Decomposition operation ### {#decomposed-state}

When a complete object is defined as *decomposed*, then:

- The object is *initialized* using the existing rules ;
- All its direct bases and non-static data members are now considered as
    distinct complete objects:
    - the decomposition does not odr-use any of the copy, move or relocation
        constructor of the subobjects. In particular, their address remains unchanged ;
    - for all of the virtual and direct bases which have a runtime type information, they
        now point to that of the base class, and no longer point to the type
        of the *decomposed* object. This step is identical as to what happens with
        the runtime type information of base classes once the destructor body
        is executed ;
    - all virtual bases, if any, keep the same address ; all pointers to such
        virtual bases remain unchanged.
- All its subobjects are now introduced in a special namespace named after the
    decomposed object:
    - all its virtual and direct bases are introduced in that namespace with
        an identifier identical to that of their class identifier ;
    - all non-static data members are introduced in that namespace with
        an identifier identical to that of their definition ;
    - member functions are not introduced ;
    - the introduced objects (i.e. the subobjects of the *decomposed* object)
        have the same lifetime as the *decomposed* object,
        had it not been *decomposed* ;
    - the introduced objects still inherit from the cv-qualifiers,
        if any, of the *decomposed* object ;
    - all the virtual bases introduced in that namespace cannot be the operand
        of the `reloc` operator, or else the expression is ill-formed.
- *The lifetime of the* decomposed *object ends*: its destructor is never invoked implicitly.
    All its non-static subobjects, now considered as complete objects, are still
    alive and will
    follow normal destruction rules: their destructor will be
    invoked implicitly at scope exit
    unless they have been relocated before.

Note: If not for changing the runtime type of the direct bases that have one,
the decomposition operation would be a no-op.

For instance:
```c++
void foo(std::pair<std::string const, int> kv reloc)
{
    // kv object no longer exists
    // its subobjects are accessible in the special "kv" namespace:
    // kv::first and kv::second
    bar(kv::second, reloc kv::first);
    // kv::second destructor will be invoked implicitly
}

struct V { int _v; };
struct B : public virtual V { int _b; };
struct D : B { std::string _d; };
void foo(D const d reloc)
{
    // d::B designates the base of former d object
    static_assert(std::is_same_v<decltype(d::V), V const>);
    static_assert(std::is_same_v<decltype(d::B), B const>);
    static_assert(std::is_same_v<decltype(d::_d), std::string const>);
    bar(reloc d::B); // well-formed
    bar(reloc d::V); // ill-formed, cannot relocate virtual base
}
```

#### Namespace of the decomposed object #### {#decomposed-obj-namespace}

All the subobjects of the decomposed object are introduced in a special
namespace.

- This namespace is only accessible from within the scope of the
    decomposed object, had it not been decomposed.
- This namespace cannot be aliased.
- This namespace cannot be the target of a `using namespace` directive.
- If the decomposed object is anonymous, then it remains decomposed but its
    subobjects are not accessible through any special namespace. Their
    destructor will be invoked implicitly at scope exit. **Note:** Alternatively,
    its subobjects could have been introduced in an anonymous namespace,
    but doing so would create name clashes between base class type identifiers and
    base class subobject identifiers.
- It is not an error if the special namespace identifier clashes with an
    existing namespace identifier. In this case, name resolution will look-up
    the special namespace unless explicit disambiguation is specified (`::`).
- It is also not an error if the special namespace identifier clashes with
    another existing special namespace identifier, introduced by an enclosing
    scope. In this case, name resolution will look-up
    the special namespace in the least-enclosing scope.
    This is similar as to what happens when a variable "shadows" another.

```c++
namespace np1
{

namespace np2
{

static inline const std::string _b = "";
static inline const std::string _d = "";

}

struct D { std::string _d; }

void foo(D np2 reloc)
{
    // np2::_d refers to the subobject of the decomposed np2 object.
    // np2::_b is an unknown identifier
    // ::np1::np2::_d and ::np1::np2::_b refer to the static storage objects.
    bar(reloc np2::_d);

    {
        D np2 reloc = getD();
        // np2:: now refers to the subobjects of the line above
        std::cout << np2::_d << std::endl;
    }
}

}
```

### Illegal decomposition ### {#ill-formed-decomposition}

The decomposition of an object `src` of type `T` is ill-formed if any of
the following conditions is not satisfied:

- all subobjects of `src` are accessible. They all need to be
    since their destructor will be called if not relocated ;
- all declared special member functions of `T` are declared either as
    defaulted or deleted,
    **or** the call-site has private access privilege to `T`.

These requirements ensure that we can only decompose (a) compound types,
where subobjects have no dependencies with one another (like an `std::pair`),
or (b) types that we are in control of (because of the private access).

### Decomposition of a lambda closure type ### {#decompose-lambda}

Lambda objects can be decomposed with the rules defined above. The subobjects
of the closure type are all the lambda captures which are captured by copy.
The decomposition can only happen from the lambda body and not from outside
the lambda, as if its captures had private access.

The following is well-formed:

```c++
non_null<unique_ptr<int>> ptr;
auto const getPtr = [p = reloc ptr](this auto self reloc)
{
    foo(reloc self::p);
};
(reloc getPtr)();
```
But this is ill-formed:
```c++
non_null<unique_ptr<int>> ptr;
auto const getPtr reloc = [p = reloc ptr](this auto self reloc)
{
    foo(reloc self::p);
};
auto ptr2 = reloc getPtr::p; // ill-formed, no access privilege to the captures
```

### Implicit decomposition of temporaries ### {#decompose-tmp}

Temporary objects can be implicitly decomposed to allow relocations in the following
scenarios (but non exclusively):

```c++
struct D : public B {};
D getD();
std::pair<std::string, std::string> getPair();

B b = getD(); /* under conditions, equivalent to:
    auto d reloc = getD(); B b = reloc d::B; */
std::string s = getPair().first; /* under conditions, equivalent to:
    auto pair reloc = getPair(); std::string s = reloc pair::first; */
```

Inspired by [[class.temporary](https://eel.is/c++draft/class.temporary#6.sentence-2)]
we add a clause to when a subobject of a temporary is to be converted to a
prvalue (for instance because passed to the relocation constructor or relocation
assignment operator).

In all the expressions listed in [6](https://eel.is/c++draft/class.temporary#6.sentence-2),
the resulting expression can be converted to a prvalue with *implicit decomposition*:

- In [6.3](https://eel.is/c++draft/class.temporary#6.3), the C-array case,
    the array decomposition is always legal and each of its elements are considered
    as complete objects (their destructor will be implicitly invoked).
    It's only if that array element is relocated or further implicitly decomposed
    that its destructor will not
    be implicitly invoked (for that element only).
    It is the only situation where the decomposition of an
    array-type is possible.
- In [6.5](https://eel.is/c++draft/class.temporary#6.5), the pointer to data
    member case, **the pointer to data member must be constant-evaluated**.
    The language will identify which data member is pointed at.
    It's only if that data member is relocated or further implicitly decomposed
    that its destructor will not be implicitly invoked.
    The pointer must be constant-evaluated, as it is otherwise impossible
    to know at compile-time whether it refers to a direct data member or
    to one of a base class (in which case further implicit decompositions will
    happen). This information is required at compile-time to access the
    well-formedness of the expression.
    If the pointer is not constant evaluated, then no implicit decomposition
    can happen.

The *implicit decomposition* materializes the temporary complete object.
Further implicitly decompositions occur for each data member access
(or array element access for array-types) or cast to a base class,
to extract the desired subobject.

If any *implicit decomposition* is illegal, then it does not cause the program
to be ill-formed, the expression simply cannot be converted
to a prvalue (e.g. any relocation constructor or assignment operator are
discarded from overload resolution).
All the incurred decompositions must be legal, as defined
[here](#ill-formed-decomposition), or else the *implicit decomposition* is
illegal. In particular, if any virtual base is to be decomposed,
then the *implicit decomposition* is illegal.

For instance:
```c++
class T
{
public:
    std::string _pub;
private:
    std::string _priv;
};
class U
{
public:
    std::string _pub[5];
};

T getT();
U getU();

std::pair<std::string, std::string> getPair();


std::string a = getT()._pub; /* implicit-decomposition is ill-formed
    because T has a private member, move constructor is used */
std::string b = getU()._pub[2]; /* implicit-decomposition is ill-formed
    as reloc cannot be used on array elements, move constructor is used */
std::string c = getPair().second; /* implicit-decomposition is well-formed;
    std::string's relocation constructor is used */
```

### Decomposition of value parameters ### {#decompose-value-param}

As we have seen, decomposition ends the lifetime of the source object.
The reader may be concerned that this may break existing ABIs, should the source
object be a function parameter passed by value.
However we do not foresee any extra breakage other than what the support for
the `reloc` operator does.

Indeed if the decomposed object is not *early destructible*, then the function
may silently relocate its argument to some local storage before the function
body is entered. *This is a putative
workaround and is not part of the proposal.*

For instance:

<table>
<tr><th>User-written code</th><th>Putative equivalent generated code</th></tr>
<tr>
<td valign="top"><pre lang="cpp">
void foo01(T obj reloc)
{
    // ...
    if (test())
    {
        sink(reloc obj::m);
    }
    // ...
}
</pre></td>
<td valign="top"><pre lang="cpp">
void foo01(T __obj)
{
    auto obj reloc{reloc __obj};
    // ...
    if (test())
    {
        sink(reloc obj::m);
    }
    // ...
}
</pre></td>
</tr>
<tr>
<td valign="top"><pre lang="cpp">
void foo02(T obj reloc) try
{
    // ...
    if (test())
    {
        sink(reloc obj::m);
    }
    // ...
}
catch (...) {}
</pre></td>
<td valign="top"><pre lang="cpp">
void foo02(T __obj) try
{
    auto obj reloc{reloc __obj};
    // ...
    if (test())
    {
        sink(reloc obj::m);
    }
    // ...
}
catch (...) {}
</pre></td>
</tr>
</table>

### Decomposition in constexpr ### {#dot-reloc-constexpr}

Object decomposition can be used in constexpr functions and
constant-evaluated expressions.

### Examples ### {#decomposed-object-examples}

#### Nominal case #### {#decomposed-object-ex-nominal}

One of the main practical uses of object decomposition is for compound types, such as
`std::pair`. Note that this code would not be feasible without relocation and
without decomposition.

```c++
void bar(string, non_null<unique_ptr<int>>);

void foo(pair<string const, non_null<unique_ptr<int>>> p reloc)
{
    bar(reloc p::first, reloc p::second);
}
```

#### Custom extractor #### {#decomposed-object-ex-extractor}

```c++
class T
{
private:
    string const _key;
    non_null<unique_ptr<int>> _val;

public:
    // [...]
    non_null<unique_ptr<int>> getVal(this T self reloc)
    {
        return self::_val;
        // note that here the destructor of self is not called.
        // however every non relocated data member is still destructed
        // so self._key.~string() is called at function exit.
    }
};
```

This code may be invoked in the following situations:
```c++
// with: T getT();
//       T src;

auto val1 = getT().getVal();
auto val2 = (reloc src).getVal();
```

#### Putative std::unique_ptr::release #### {#decomposed-object-putative-release}

```c++
template <class T, class Deleter>
class unique_ptr
{
// ...
public:
    T* release(this T self reloc)
    {
        return self::_ptr;
    }
};
```

Because of the decomposition, the destructor of `self` is not called. This code
safely releases the guarded pointer. Note that this `release` function
is not part of the proposal.

## Ill-formed reuse of relocated objects ## {#ill-formed-reuse}

### Variable state tracking ### {#variable-state-tracking}

The `reloc` operator changes the state of its operand, imposing
restrictions of how the variable can be used in the next expressions.

Let us formally introduce the new states a local variable can have:

- *alive* (**A**): this is the default state. As of today in C++, all variables are in this
    state.
- *relocated* (**R**): the variable was passed as operand to the `reloc` operator.
- *alive-or-relocated* (**A-R**): the variable may be *relocated* or *alive*. For instance
    the variable will have this state at the end of an if statement,
    if the variable was *relocated* in one path and remained *alive* in the other.

Those states are evaluated *at compile-time*, and their primary use is to verify
the well-formedness of expressions.

The state of a given variable (including function parameters) is evaluated as follows:

- The variable starts in the **A** state.
- The state of the variable is tracked by *examining* potentially-evaluated expressions,
    from one expression to the next, following the evaluation order.
    - If two or more expressions have an unspecified evaluation order with
        one another, then
        expressions containing a `reloc` operator with the tracked variable as
        operand are examined first (in any order).
    - Expressions that are part of [unevaluated operands](https://eel.is/c++draft/expr.context#1)
        are not examined.
    - Expressions that are part of a
        [discarded statement](https://eel.is/c++draft/stmt.if#def:discarded_statement)
        of a `constexpr if` statement are not examined.

- The *id-expression* designating the tracked variable is ill-formed
    if the expression is examined and the variable's state is not **A**.
    - If the *id-expression* is used as operand of the `reloc` operator,
        then the variable transitions to the **R** state after the
        `reloc` expression examination.

- If the code path forks (for instance because of an if statement), then all the
    different code branches need to be examined.
- If two or more code paths rejoin, then the resulting state of the variable
    is the **OR**-combination of the state it had in all the joined code branches.
- On a code jump:

    - if the code jumps before the variable declaration or after the variable
        enclosing scope, then the state analysis for this code branch stops here
        for this variable.
    - otherwise the state of the variable after the jump is the **OR**-combination
        of the state it had before the jump, and the state it would have had at the
        destination code location without taking the jump.
        If the destination code location cannot be reached without jump, then
        the jump does not change the state the variable.
        The state of the variable prior to the jump is memorized for this code jump.
    - if a same code jump needs to be taken an extra time, then the state of the variable
        is compared to the one previously memorized. If they are identical then
        the state analysis for this code branch stops here for this variable.
        Otherwise the new state prior the jump is updated and the jump re-examined.

- In a try block, if the variable was declared before the block: at the end of
    an expression that may throw,
    a code jump to each catch block may be examined.
    This code jump is necessary:

    - if the state of the variable has changed prior to when the last jumps
        to the catch blocks were made.
    - or if no last jumps to catch blocks were made, then compare the state
        the variable had when entering the try block against the current state
        and perform the jumps if they differ.

- This state analysis stops until code reaches the natural end of scope of the
    variable.

NOTE: We don't expect this analysis to be costly. It is only necessary in functions
for the variables that are relocated or decomposed. If none of the two are used,
then this analysis is not needed.

### reloc in unevaluated operands ### {#unevaluated-operands}

The `reloc` operator can be used in
[unevaluated operands](https://eel.is/c++draft/expr.context#1).
Such expressions are ignored by the code analysis described
[above](#variable-state-tracking).
If `reloc`  is used in an unevaluated operands,
then (a) their operands are always considered to have the *alive* state,
and (b) the state of their operands do not change.

For instance:
```c++
void foo(T x)
{
    decltype(reloc x) y = reloc x; // well-formed
    decltype(reloc x, (reloc x).m) z = y.m; // well-formed
}
```

### Examples ### {#reloc-dot-reloc-ill-formed-showcase}

Consider the following examples:

```cpp
void reloc_showcase_01()
{
    const T var = getT();
    bar(reloc var);
    if (sometest(var)) // ill-formed: state of 'var' is relocated
        do_smth(var); // ill-formed: state of 'var' is relocated
}
```
`var` cannot be reused after the `reloc` call.
```cpp
void reloc_showcase_02()
{
    const T var;
    {
        const T var;
        bar(reloc var);
        do_smth(var); // #1 ill-formed: state of 'var' is relocated
        {
            const T var;
            do_smth(var); // OK
        }
        do_smth(var); // #2 ill-formed: state of 'var' is relocated
    }
    do_smth(var); // OK
}
```
At #1 and #2, the calls to `do_smth(var)` are allowed because the name `var`
does not resolve to the relocated object.
```cpp
void reloc_showcase_03()
{
    const T var = getT();
    if (sometest(var))
        bar(reloc var); // #1, var state is relocated
    else
        do_smth(var); // #2, var state is alive
    // var state is alive-or-relocated
}
```
At #2 `do_smth(var)` is allowed because `var` state is not affected by the
`reloc` call at #1 (they occur in different code branches).
```cpp
void reloc_showcase_04()
{
    const T var = getT();
    if (sometest(var))
        bar(reloc var); // #1
    else
        do_smth(var); // OK
    // [...]
    do_smth_else(var); // #2, ill-formed: state of 'var' is A-R
}
```
At #2, `do_smth_else(var)` is an error because `var` is mentioned after the
`reloc` call at #1.
```cpp
void reloc_showcase_05()
{
    const T var = getT();
    if (sometest(var))
        bar(reloc var);
    else
        do_smth(reloc var); // OK
    // var state is relocated
}
```
Both `reloc` are okay as they happen on different code paths.
```cpp
void reloc_showcase_06()
{
    const T var = getT();
    bool relocated = false;
    if (sometest(var))
    {
        bar(reloc var);
        relocated = true;
    }
    else
        do_smth(var); // OK
    // [...]
    if (!relocated)
        do_smth_else(var); // ill-formed: state of 'var' is A-R
}
```
It does not matter that the developer tried to do the safe thing with the
`relocated` variable. The code-path analysis disregards run-time values and
explores all branches of an `if` statement.
```cpp
void reloc_showcase_07()
{
    constexpr bool relocated_v = my_can_relocate<T>{}();
    const T var = getT();
    if constexpr(relocated_v)
    {
        bar(reloc var);
    }
    else
        do_smth(var); // OK
    // [...]
    // var state is R if relocated_v is true, A otherwise
    if constexpr(!relocated_v)
        do_smth_else(var); // OK
}
```
The above example is safe because of the use of `if constexpr`.
```cpp
void reloc_showcase_08()
{
    const T var = getT();
    if (sometest(var))
    {
        bar(reloc var);
        return;
    }
    do_smth(var); // OK
}
```
This example is also safe thanks to the `return` statement right after the
`reloc` instruction, which prevents from running `do_smth(var);`.
```cpp
void reloc_showcase_09()
{
    const T var = getT();
    for (int i = 0; i != 10; ++i)
        do_smth(reloc var); // ill-formed: state of 'var' is A-R (on second iteration)
}
```
This is ill-formed as each iteration reuses `var` which is declared before
the loop body.

In the code path analysis:

1.  At the first loop iteration, the variable gains the *relocated* state.
2.  The loop increment is examined, and it does not change the state of `var`.
3.  The loop condition is examined, and it does not change the state of `var`.
4.  The code jump is examined for the first time, memorizing the state of `var`
    at that moment (*relocated*).
5.  The new state of `var` is now **A-R**.
6.  `do_smth(reloc var)` is examined, and `reloc var` is ill-formed as `var`
    is not in the *alive* state.

```cpp
void reloc_showcase_10()
{
    const T var = getT();
    for (int i = 0; i != 10; ++i)
    {
        if (i == 9)
            do_smth(reloc var); // ill-formed: state of 'var' is A-R (on second iteration)
        else
            do_smth(var); // ill-formed: state of 'var' is A-R (on second iteration)
    }
}
```
This is ill-formed for the same reason as above.
```cpp
void reloc_showcase_11()
{
    const T var = getT();
    for (int i = 0; i != 10; ++i)
    {
        if (i == 9) {
            do_smth(reloc var); // OK, var state is relocated
            break;
        }
        else
            do_smth(var); // OK, var state is alive
    }
    // var state is A-R
}
```
Adding the break statement right after the `reloc` call makes the code snippet well-formed.
Indeed the `break` statement forces the loop exit, which implies that the
conditional jump at the end of loop (that may start the next iteration) is no
longer part of the code path that follows the `reloc` instruction.
```cpp
void reloc_showcase_12()
{
    for (int i = 0; i != 10; ++i)
    {
        const T var = getT();
        do_smth(reloc var); // OK
    }
}
```
`var` is local to the for-loop body, so `reloc` is well-formed here.
The code path analysis for this variable does not require several loop iterations,
as the variable scope ends before the code jump leading to the next iteration
is evaluated.

```cpp
void reloc_showcase_13()
{
    const T var = getT();
from: // #1
    if (sometest(var)) // #2, ill-formed: var state is A-R after the jump
    {
        do_smth(var); // #3, ill-formed: var state is A-R after the jump
        return;
    }
    else
    {
        do_smth(reloc var); // #4, ill-formed: var state is A-R after the jump
    }
    // #5
    goto from;
}
```
Because of #4, the state of `var` at #5 is **R**. The goto statement is executed
and we are back at #1. `var` state is then the OR combination of the **A** state
and the **R** state, which is **A-R**.
Then the expressions #2, #3 and #4 are ill-formed because `var` is not in the
**A** state.
```cpp
void reloc_showcase_14()
{
    const T var = getT();
from:
    if (sometest(var)) // var state is alive
    {
        do_smth(var); // var state is alive
        goto from;
    }
    else
    {
        do_smth(reloc var);
    }
}
```
In this scenario `goto` is placed in a way that does not trigger the reuse of relocated `var`.
```cpp
void reloc_showcase_15()
{
    union { T x; U y; };
    x = getT();
    if (sometest(x))
    {
        do_smth(reloc x);
        x = getT(); // well-formed
    }
    else
    {
        reloc x; // destroy x
        y = getU();
        do_smth_else(reloc y); // well-formed
        x = getT(); // well-formed
    }
    do_smth_else(reloc y); // well-formed
}
```
`reloc` does not prevent from reusing the names of anonymous union members.
```cpp
void reloc_showcase_16()
{
    T x;
    if (sometest(x))
    {
        do_smth(reloc x);
    }
    else
    {
        auto const y reloc = reloc x;
        do_smth_else(reloc y::m); // well-formed
        // equivalent to: do_smth_else((reloc x).m);
    }
    do_another_thing(x); // ill-formed: state is now R
}
```
`do_another_thing(x)` is ill-formed as `x` is relocated.
```cpp
void reloc_showcase_17()
{
    T x;
    if (sometest(x) || sometest(reloc x)) // well-formed: x state is A-R
    {
        do_smth(x); // ill-formed: x state is A-R
    }
    else if (othertest(x)) // ill-formed: x state is A-R
    {
        foo();
    }
}
```
```cpp
void reloc_showcase_18()
{
    // unspecified evaluation order
    { T x; auto y = reloc x + reloc x; } // ill-formed
    { T x; auto y = x + reloc x; } // ill-formed
    { T x; auto y = reloc x + x; } // ill-formed
    { T x; auto y = x[reloc x]; } // ill-formed

    // sequenced evaluation order
    { T x; auto y = x, reloc x; } // well-formed
    { T x; auto y = reloc x, x; } // ill-formed
    { T x; auto y = x or reloc x; } // well-formed
    { T x; auto y = reloc x or x; } // ill-formed

    // unspecified evaluation order with ternary
    { T x; foo(x, reloc x); } // ill-formed
    { T x; foo(x, test() ? reloc x : x); } // ill-formed
    { T x; foo(test() ? reloc x : x); } // well-formed
}
```

If two or more expressions have an unspecified evaluation order,
then to determine their well-formedness
we examine the expressions containing `reloc` first, and
examine the rest after (in any order).

```cpp
void reloc_showcase_19()
{
    T x = getT();
    try
    {
        foo();
        bar(reloc x);
    }
    catch (std::exception const& excp)
    {
        std::cerr << excp.what() << " for " << x << std::endl;
        // ill-formed: x state is alive or relocated
    }
}
```

### Conditional destruction ### {#conditional-reloc}

NOTE: This section only applies to variables that are not ref-qualified.

The variable state analysis described [here](#variable-state-tracking)
may be used to know what kind of cleanup is necessary at scope exit
(i.e. if the end of scope is reached or an exception is emitted).

When this happens, if the variable is in **A-R** state, and that its type is
not trivial, then
implementations must track *at runtime* the actual state of the variable
(**A** or **R**)
and process its destruction accordingly:

- If the variable was the operand in an evaluated `reloc` expression, then
    the variable may need to be destructed following the rules described [here](#reloc-src-obj-lifetime).
- Otherwise the variable must be destructed by its destructor following normal
    rules.

NOTE: If the variable was the operand of a `reloc` expression,
    but that expression was *not evaluated*, then
    *its lifetime is not affected* and the variable must still be destroyed
    normally.

How this runtime tracking is done is
*implementation-defined*, although it will probably take the form of extra flags
in the function stack.

For instance:
```c++
void foo()
{
    T obj = /* ... */;
    if (some_test())
        bar(reloc obj); // obj state is relocated
    else
        handle_error(); // obj state is alive
    live_on(); // obj state is alive-or-relocated
}
```

After the call to `live_on()`, or should `live_on` throw, `obj` destructor
is only implicitly invoked if `reloc obj` was not evaluated. Implementations may simply turn on
a flag right before the evaluation of the `reloc` expression.

Concerns have been expressed that extra flags would violate the "don't pay for
what you don't use" principle. We acknowledge this concern, but feel that the
user is getting at least something out of this. Alternatives would be for the source
object to be destroyed implicitly at the opening or closing brace of the `else`,
for the code to be ill-formed unless the source object is relocated within the
`else`, or for the code to be ill-formed unconditionally. Note that in each of these
cases, the user can recover our preferred behavior in library, using `std::optional`
to add the tracking flags that in our proposal would be provided by the language.

## Relocation constructor ## {#reloc-ctor}

Now that we have introduced the `reloc` operator and object decomposition, we
introduce the relocation constructor, which is built upon those new concepts.
As relocation happens from prvalues,
the constructor takes a prvalue as parameter: `T(T)`.

This signature was picked as it completes the C++ tripartite value system.
The copy constructor creates a new instance from an lvalue, the move constructor
from an xvalue, and then the relocation constructor from a prvalue.

Note: a further benefit of this syntax is that it is currently ill-formed
<a href="http://wg21.link/class.copy.ctor#5">[class.copy.ctor]/5</a>, and
thus available for extension.

A point of confusion may be that the syntax implies an infinite regress: the
parameter must be constructed, which requires a prior call to the relocation
constructor, and so on. This is not the case; if the source object was previously
the operand of the `reloc` operator, it was transformed into a prvalue
immediately before entering the relocation constructor, and the parameter of the
relocation constructor is that same prvalue. (If the source object was already a
prvalue, there is no issue; the parameter is that prvalue.)

An attractive intuition is that the parameter aliases the source object in the
same way as a reference or a structured binding declaration.
However, this is misleading; the lifetime of a source object glvalue has already
ended and so use of a pointer or reference referring to the source object has
undefined behavior, except as provided by [basic.life] and [class.cdtor].

Note: this behavior matches that for the destructor of a class type; see
<a href="https://wg21.link/basic.life#1.4">[basic.life]</a> paragraph 1.

This intuition is only useful in so far as the ABI for a relocation
constructor prvalue parameter is likely to be the same as that for a copy or move
constructor parameter, since the prvalue parameter may have the same storage
location as a previously existing glvalue.

Note: it does not matter that the ABI for the relocation constructor parameter
differs from that for a prvalue parameter in normal functions, since it is not
possible to take the address of a constructor.

The role of the relocation constructor is to construct a new instance by *destructively
stealing* the resources from the source object. Unlike the move
constructor, the relocation constructor needs not to leave the source object in
valid state.

### The relocation constructor is a second destructor ### {#reloc-ctor-is-2nd-dtor}

The relocation constructor **is a second destructor** of the class-type
with regards to the source object. Indeed, the lifetime of the source object
was ended immediately prior to entering the relocation constructor, and thus
the source object is considered as destructed thereafter.
In particular, once an object has been passed to its relocation constructor, its
destructor must not be implicitly invoked.
See [destruction of the source object](#reloc-ctor-dtor-def) section
for more details.

### Declaration ### {#reloc-ctor-declaration}

The relocation constructor can be declared (implicitly or explicitly), defaulted
and deleted like any other constructor.

The relocation constructor of a class-type `T` implicitly gets a `noexcept(true)`
exception specification unless:

- it is explicitly declared with `noexcept(false)` ;
- or one `T`'s subobjects has a `noexcept(false)` relocation constructor ;
- or one `T`'s subobjects does not declare a relocation constructor and has
    a `noexcept(false)` move constructor.

These rules are similar to that of the destructor's implicit exception specification.

A class-type that provides a relocation constructor has some impact on the program
ABI. See the [ABI section](#abi).

#### Implicit declaration #### {#reloc-ctor-declaration-implicit}

If a class-type follows the Rule of Zero (updated to account for the relocation
constructor and relocation assignment operator), then the compiler will declare
a non-explicit inline public relocation constructor,
i.e. if none of the following are user-declared:

* copy constructor
* copy assignment operator
* move constructor
* move assignment operator
* destructor
* relocation assignment operator

#### Deleted implicitly-declared or defaulted relocation constructor #### {#reloc-ctor-declaration-deleted}

The implicitly-declared or defaulted relocation constructor for class `T` is defined as deleted:

- if `T` has subobjects that explicitly declare a deleted relocation constructor ;
- or `T` has subobjects with missing relocation and move constructors (i.e.
    that are deleted, inaccessible, or ambiguous).
- or `T` has subobjects with deleted or unaccessible destructor.

As for move constructors, a defaulted relocation constructor that is deleted is
ignored by overload resolution.

Note: this means that a class with an explictly deleted relocation constructor
will still be relocated if necessary, but through the move (or copy) constructor
and destructor.

#### Trivial relocation #### {#trivial-relocation}

A relocation constructor of a class type `X` is *trivial* if it is not user-provided and
if:
* `X` has no virtual functions and no virtual base classes, and
* for each direct base class and direct non-static data member of class type or array thereof,
    the relocation operation (which may be a relocation constructor or
    synthesized from copy/move constructor plus destructor) selected
    to relocate that base or member is trivial.

A *trivially relocatable class* is one which:
* has a trivial, eligible relocation constructor, or
* does not have a relocation constructor (including one that is deleted),
    and is trivially copyable.

Note: *eligible* is defined in
<a href="http://wg21.link/special#def:special_member_function,eligible">[special]</a>.

Scalar types, trivially relocatable class types, and arrays and cv-qualified versions
thereof are *trivially relocatable*.

Advisement: We also tighten the definition of "trivial class" (and thus "trivial") to
require that the class in question be trivially relocatable as well as trivially
copyable. This is to ensure that if the user wants code to be called on relocation,
the library does not bypass said code by, say, using `memmove`.

### Definition ### {#reloc-ctor-definition}

#### Destruction of the source object #### {#reloc-ctor-dtor-def}

As mentioned above, the relocation constructor **is a second destructor** of
the class-type.
Once its body has been executed,
the relocation constructor proceeds with the
destruction of the source object in a similar manner as the destructor:

- All its subobjects will be destructed in reverse declaration
    order, unless they got relocated.
- If not already decomposed, the runtime type information of all its base
    classes is adjusted to that of their base class.
- If the constructor initialization sequence or body exits because of an
    exception, this destruction sequence
    is triggered by stack unwinding.

#### Virtual bases #### {#reloc-dtor-virtual-bases}

Virtual bases have a special treatment in constructors and destructors:
they are only contructed and destructed by the class-type of the complete object,
and not by its base classes.
The relocation constructor has the same behavior.
Hence it must be passed with the same extra information
that is passed today to any constructor and to the destructor:
(a) whether it is in charge of the construction of the virtual bases, and
(b) whether it is in charge of the destructon of the virtual bases of the source object.

It follows that the relocation constructor will construct the virtual
bases of the target object (respectively destroy them from the source object)
only if the extra information *(a)* (respectively *(b)*) states so.

For instance:
```c++
class B
{
    B(B src);
    // [...]
};
class C : public virtual B
{
    C(C src);
    // [...]
};
class D : public C
{
    D(D src);
    // [...]
};

void foo(C);

void bar()
{
    D const d reloc = getD();
    foo(reloc d::C); // #1
}
```

Here, at #1 when `bar` calls the `C`'s relocation constructor to build the
parameter of `foo`:

- `C(C)` is in charge of constructing the virtual base `B` ;
- `C(C)` is **not** in charge of destroying the virtual base `B` of its parameter.
    `src.~B()` is not called by the relocation constructor ;
- The default implementation of `C(C)` will move-construct the virtual base ;
- `foo` gets a `C` object owning its virtual base.

After #1:

- `d::B` still points to valid data, albeit that it was likely moved-from
    in `C(C)` ;
- `d::B` destructor will be implicitly invoked, as it will be for all the data
    members of `d::D` ;

#### Default definition #### {#reloc-ctor-default-definition}

The default relocation constructor implementation for a class-type `T` depends
on `T`'s type traits.

If `T` is trivially relocatable then the relocation constructor
effectively (ignoring padding) performs
a `memcpy` over its entire memory layout.

Otherwise the constructor implementation first decomposes
the source object, and then performs
memberwise relocations. In the relocation constructor `T(T src reloc)`,
for each subobject `s` (of type `S`) of `T`, in declaration order:

- if `S` is a virtual base, then `S` is move-or-copy-constructed as if by:
    `S{std::move(src::S)}` ;
- otherwise we construct `s` (or `S` for direct base classes)
    by calling its own relocation, move or copy
    constructor, as if by: `s{reloc src::s}` (or `S{reloc src::S}`);

NOTE: If the relocation constructor is defaulted, then the `reloc` keyword
marking the decomposition of the source object does not need to be specified.
All the following definitions are well-formed and equivalent:

```c++
T(T) = default;
T(T src) = default;
T(T src reloc) = default;
T(T reloc) = default;
```

#### User-provided definition #### {#reloc-ctor-user-definition}

Although the default definition should cover almost all cases, users can provide
their own definition of the relocation constructor. Doing so is relatively
straightforward thanks to the object decomposition feature.
The only reason we have found to write a custom relocation constructor is to adjust some
self-referencing pointers, otherwise the default implementation should suffice.

Consider the following examples:

```c++
struct T
{
    std::string _a, _b, _c;

    // Dummy example to explain all the steps of the relocation constructor.
    T(T src reloc) :
        _a{std::move(src::_a)}, _c{reloc src::_c} {} /*
        1. T::_a is constructed using the move constructor.
        2. T::_b is default constructed.
        3. T::_c is constructed using std::string's relocation
           constructor, from src._c.
        4. src._b and src._a are destructed (in that order)
           when the constructor body exits.
    */
};

struct U
{
    std::string _a;

    ~U();

    // Second dummy example.
    U(U src) {} /*
        1. U::_a is default-constructed.
        2. Although src is not explicitly decomposed, and that
           src has a user-provided destructor,
           src destructor is not called, only src._a is.
    */
};

// Motivating example
template <class T>
class BinaryTree
{
public:
    // works also if T is relocate-only
    BinaryTree(BinaryTree src reloc) : _root{reloc src::_root}
    {
        /* fixup references */
        if (_root._left)
            _root._left->_parent = &_root;
        if (_root._right)
            _root._right->_parent = &_root;
    }
private:
    struct BTNode {
        BTNode* _parent = nullptr;
        BTNode* _left   = nullptr;
        BTNode* _right  = nullptr;
        T _value;
    };
    BTNode _root;
};
```

#### Delegating relocation constructor #### {#reloc-ctor-delegate}

We do not support writing a delegating relocation constructor. Doing would raise
several problems that are difficult to solve:

- `T(T src, [...])` with non-defaulted extra parameters after `src` is a valid
    syntax today and considering this as a putative relocation constructor may
    break existing code ;
- When relocation constructor delegates to another relocation constructor,
    the source object needs to be relocated in the parameter slot of the
    delegating relocation constructor, causing infinite regress ;
- It's the relocation constructor responsibility to properly destruct
    non-relocated subobjects of the source object.
    This rule would need to be clarified if a delegating relocation constructor
    is called somehow or else we will have double destruction.

For all those reasons, using `reloc` on the source object of the relocation
constructor is likely wrong, and compiler vendors are encouraged to emit a
warning in that case.

NOTE: We do not consider this as a blocking issue.
[Additional default parameters](#reloc-ctor-additional-params)
are supported with the relocation constructor. And the relocation constructor
may still delegate to another non-relocating constructor:

```c++
struct T
{
    T(T src) : T{std::move(src), Helper{}} {} /*
        all subobjects of src are destroyed upon exit */
    // [...]
private:
    T(T&& src, Helper); /* can only be called from the relocation constructor.
        may leave src in a dirty state, as we know src destructor body will not
        be called. */
};
```

#### Additional parameters #### {#reloc-ctor-additional-params}

As with copy and move constructors, it is permissible to add additional parameters
to a relocation constructor, on condition they have a default initializer.

One case where this can be of use is if the user needs space to store information
and/or resources
for the duration of the relocation constructor, for a contrived example:

```c++
class T
{
public:
    class Helper {
    public:
        Helper() = default;
        ~Helper() { delete p; }
    private:
        friend T;
        int* p;
    };

    T(T src reloc, Helper storage = {}) noexcept(false)
        : _p(storage.p = std::exchange(src::_p, nullptr))
        , _q{reloc src::_q}
        , _r{reloc src::_r}
    {
        storage.p = nullptr;
    }

    ~T() {
        delete _p;
    }

private:
    int* _p;
    RelocateOnly _q;
    ThrowingRelocate _r;
};
```

In the above, `T::_p` does not manage its own lifetime,
but the presence of `T::_r` means that `T::T(T)` is not noexcept so we need to
release its resources if an exception is thrown during relocation.

### Invocation ### {#reloc-ctor-invoke}

The relocation constructor is invoked *as necessary* to relocate a prvalue
from one storage location to another. Use of the `reloc` operator does not
guarantee that a relocation constructor (if present) will be called,
since it may be elided
if the compiler can arrange that the source glvalue was constructed at the
appropriate address.

In particular, code of the form `T x = reloc y;` is *highly* likely to be a
no-op, simply renaming an existing object. This is however likely to find use
for "sealing" objects with complex initialization, replacing the idiom of
immediately-invoked function expressions (IIFEs, [[IIFE]]):

<table>
<tr><th>Before</th><th>After</th></tr>
<tr>
<td valign="top"><pre lang="cpp">
T const x = std::invoke([&]
{
    T x;
    x.modify(y, z);
    return x;
});
</pre></td>
<td valign="top"><pre lang="cpp">
T x_mut;
x_mut.modify(y, z);
T const x = reloc x_mut;
</pre></td>
</tr></table>

Or, consider:

```c++
C f(int i) {
    C c1, c2;
    if (i == 0)
        [[likely]] return reloc c1;  // #1
    else if (i == 1)
        [[likely]] return c1;  // #2
    else
        [[unlikely]] return c2;  // #3
}
```

At `#1` the `reloc` is largely redundant; the end-of-life optimization means
the compiler is entitled to treat `c1` as a prvalue anyway, as in `#2`. Indeed,
the likelihood annotation encourages the compiler to construct `c1` in the
return slot, such that both `#1` and `#2` are a no-op. It is only `#3` that is
likely to invoke the relocation constructor.

The relocation constructor may also be invoked by library functions, for example
[[#std-reloc_and_uninitialize]].

### Virtual relocation constructor ### {#virtual-reloc-ctor}

As the relocation constructor is a second destructor, it can be declared as `virtual`.
The virtual relocation constructor is useful when relocating from dynamic
storage, to prevent leaky object-slicing. Consider the following scenario:

```c++
class D : public B { std::string _str; };

B* b = new D;

B sliced = std::reloc_and_reclaim(b);
// reloc_and_reclaim relocates the given address to
// its return value and deallocates the memory.
```

If `B`'s relocation constructor is not virtual, then only the `B` part of `*b` will
be relocated, leaking the rest.

User code cannot make a virtual call to the relocation constructor, only STL
functions can (like [std::reloc_and_uninitialize and std::reloc_and_reclaim](#std-reloc_and_uninitialize)).
In other words, how to make a virtual function call to the relocation constructor
is implementation-defined.

#### Declaration #### {#virtual-reloc-ctor-decl}

A relocation constructor can be declared as virtual by adding the `virtual`
keyword before the declaration. In derived classes, the relocation constructor
signature must not change: the parameter type must still match the class-type:

```c++
struct B
{
    virtual B(B);
};
struct D : public B
{
    D(D) override;
    // and not D(B)!
};
```

If a class-type `T` derives from a class-type which declares a virtual relocation
constructor, and that the class-type `T` has no user-declared relocation constructor,
then the class-type `T` gets a public, defaulted implicitly-declared relocation
constructor.

#### Definition #### {#virtual-reloc-ctor-def}

Let `T` be a class-type with a virtual relocation constructor.
If `T` relocation constructor has been called normally (not through a
virtual function call), then it proceeds normally as if non-virtual.

Otherwise, the virtual relocation constructor must know
(they may be passed as extra parameters):

- the target type of the object to construct, which we will call `U`.
    `U` is by construction, either `T` or a (maybe non-direct) base class of `T` ;
- the address where it is to be constructed, which we will call `u`.

The virtual relocation constructor `T(T src)` then proceeds recursively as follows:

1.  If `U` is the same as `T`, then proceeds with the relocation constructor
    as if non-virtual.
2.  If `U` is a direct base of `T`:

    1.  If `U` is a virtual base, then use move semantics to initialize `u`:
        `new (u) U{static_cast<U&&>(src)};` and return.
    2.  Otherwise, decompose `src` and initialize `u`: `new (u) U{reloc src::U};`
        and return.
    3.  When the constructor exits, the destructors of all non-relocated subobjects
        of `src` are implicitly invoked.

3.  Let `V` be the direct base of `T` which is on the inheritance path from `T` to `U`:

    1. If `V` is a virtual base, then move-construct a local object `v`
        (`V v{static_cast<V&&>(src)};`). Then make a virtual relocation
        constructor call, passing `v` as source object, and forwarding the target type
        `U` and its target address `u`. Return.
    2. Otherwise, decompose `src` and call the virtual relocation constructor of `V`,
        passing the base class `V` of `src` as the source object
        (as if by `reloc src::V`), and forwarding the target type
        `U` and its target address `u`. Return.
    3.  When the constructor exits, the destructors of all non-relocated subobjects
        of `src` are implicitly invoked.

As you can see when the virtual relocation constructor completes,
all the non-relocated subobjects of `src` are destroyed normally, and the target
subobject is relocated at the desired location.

NOTE: To detect how the relocation constructor is called,
implementations may emit two relocation constructor definitions, one virtual
and one non-virtual. User code can only call the non-virtual version, which
ensures the virtual one is only called through virtual function calls.

#### Ill-fomed definition #### {#virtual-reloc-ctor-def-ill-formed}

A virtual relocation constructor definition of a class-type `T` is ill-formed if:

- any of the direct base of `T`, which declares (maybe implicitly) a virtual
    relocation constructor, has a non-accessible relocation constructor ;
- or if any of the subobject of `T` have an inaccessible destructor.

## Relocation assignment operator ## {#reloc-assign-operator}

We further introduce the relocation assignment operator. Its signature shall be:
`T& T::operator=(T)`. Such operators may already be defined in existing codebases,
but the proposed changes will not interfere with them.

Sometimes we also make mentions to the *prvalue-assignment operator*.
It refers to the same function,
but further indicates that this function existed prior to the proposal.

### Declaration ### {#reloc-assign-declaration}

The relocation assignment operator becomes a special member function. As such,
declaring one breaks the Rule of Zero, which was not the case previously.

The relocation assignment operator may be implicitly declared, and may be
defaulted or deleted.

#### Implicit declaration #### {#reloc-assign-operator-implicit}

If a class-type follows the Rule of Zero, then the compiler will declare
an inline public relocation assignment operator.

#### Deleted implicitly-declared or defaulted relocation assignment operator #### {#reloc-assign-declaration-deleted}

The implicitly-declared or defaulted relocation assignment operator for class `T` is defined as deleted:

- if `T` has subobjects that have an implicitly or explicitly deleted relocation assignment operator ;
- or `T` has no relocation, move, or copy constructor ;
- or `T` has subobjects that have inaccessible relocation or move assignment operators ;
- or `T` has subobjects with deleted or unaccessible destructor.

A defaulted relocation assignment operator that is deleted is ignored by overload
resolution.

### Relocation assignment operator parameter relocation elision ### {#aliased-reloc-assign}

As with the relocation constructor, it is desirable that the parameter should be
the source object *converted to* a prvalue, and not a temporary prvalue relocated
*from* the source object. This is particularly critical for
the default definition of the operator, which
(as you might suspect) performs memberwise calls to other relocation assignment operators.
Without elision, that would imply recursive relocation of each subobject, down to
their smallest unbreakable parts (incurring O(N<sup>2</sup>) byte copies, *N* being the size in
bytes of the source object).

However, this poses a problem since it is possible to take the address of a
relocation assignment operator, yielding a pointer (or reference) with (typical)
signature `T& (T::)(T)`, implying that the source object must occupy a parameter slot,
which may not find it possible to have the same storage address as the source object,
and/or which the caller may expect to destroy (see [[#abi]]).

Nevertheless, we mandate elision where possible:

- If the class-type (possibly implicitly) declares a non-deleted relocation constructor,
    or declares a defaulted relocation assignment operator, then elision is
    mandated at declaration level ;
- Otherwise, if the class-type defines a relocation assignment operator as
    defaulted, then elision is mandated at definition level ;
- Otherwise elision is not mandated.

Elision is performed in such a way as to avoid ABI break (more on that on the [ABI
section](#prvalue-assign-op-abi)).

#### Elision at declaration level #### {#aliased-reloc-assign-declaration}

If elision is mandated at declaration level, then the assignment operator
declaration actually declares two member functions:

- the non-eliding one, which takes its input parameter by value.
    This is the function that will get called when user-code calls the
    assignment operator. It is the prvalue-assignment operator as we know it
    today ;
- the eliding one, which takes its input parameter as if by reference, and has the
    same return type as the non-eliding one. The eliding
    function has no identifier and does not participate in overload resolution.
    Users cannot take its address.
    The eliding operator is forced to have callee-destroy ABI: the operator
    is in charge of the lifetime of the source object.

The definition of the assignment operator (which is user-provided or
defaulted) will serve as the definition of the eliding operator.

The non-eliding operator definition is generated by the compiler, and merely wraps
the call to the eliding one:

- If the source object passed to the non-eliding operator is *early destructible*,
    then the operator:
    1.  Calls the eliding operator, passing the source object as if by reference.
    2.  It forwards as return value whatever the eliding operator returns.
- Otherwise then the operator:
    1.  Creates a local copy of the source object, using move or copy constructor.
    2.  Calls the eliding operator, passing that copy by reference.
    3.  It forwards as return value whatever the eliding operator returns.
    4.  It does not call the destructor of that local copy.

If the address of the assignment operator is queried, then the address of the
non-eliding version is returned. If the assignment operator is virtual, then only
the non-eliding version is considered to be `virtual` and is added to the vtable entry.

#### Elision at definition level #### {#aliased-reloc-assign-definition}

If elision is mandated at definition level, then the two versions of the operator
are generated (eliding and non-eliding) in the translation unit where the operator
is defined. The visibility of the eliding operator symbol to other translation
units is *implementation-defined*.

The eliding operator has an ABI where it takes its input parameter by reference,
and is in charge of the lifetime of the source object (callee-destroy).

The definition of the two functions are the same as if elision was mandated at
declaration level.

Typically, we expect code in the same translation unit to befenit from the
elided-version. Code outside the translation unit may also benefit from it
through link time optimizations.

### Definition ### {#reloc-assign-definition}

#### Default definition #### {#reloc-assign-default-definition}

As you would expect, the default definition merely delegates to the relocation
assignment operator of all its subobjects.

In `T`'s default assignment operator, the source object `src` of type `T` is
decomposed, and for all its subobjects `s` of type `S`:

- if `S` is a virtual base, then `S` is move-or-copy-assigned as if by:
    `static_cast<S&>(*this) = std::move(src::S);` ;
- otherwise we construct `s` (or `S`) by calling its own relocation, move or copy
    assignment operator, as if by: `s = reloc src::s;`
    (or `static_cast<S&>(*this) = reloc src::S;` for base classes);

Thanks to the relocation-assignment operator special eliding,
no copies or relocations of the source subobjects are performed.

#### Possible user definitions #### {#reloc-assign-user-definition}

User-provided operators can still perform memberwise relocation as it is
done with the defaulted version.

Other definitions are possible, notably the famous *copy-and-swap*
(now *relocate-and-swap*) and the *destroy-and-construct* idioms.

Note that the most optimal implementation will result in a single destructor
call and a single memcpy call (given that the class-type is trivially
relocatable).

**Memberwise relocation**

```c++
T& T::operator=(T src reloc)
{
    static_cast<B&>(*this) = reloc src::B; // relocate base
    this->_a = reloc src::_a;
    return *this;
}
```

This implementation is the best possible given that memberwise relocation
matches the need of the class-type. It has a strong exception safety
and has optimal performance (memberwise, one resource clean-up and one memcpy).

**destroy-and-construct**

```c++
T& T::operator=(T src) noexcept
{
    std::destroy_at(this);
    return *std::construct_at(this, reloc src);
}
```

Or an exception-safe version, necessary if the destructor or the relocation
constructor throws:

```c++
T& T::operator=(T src) requires std::is_default_constructible_v<T>
{
    std::experimental::scope_fail _{[this] { new (this) T; }};
    std::destroy_at(this);
    return *std::construct_at(this, reloc src);
}
```

This idiom is as optiomal as we could hope for, merely destructing the object
and reconstructing it thanks to the relocation constructor.

Exception safety is a bit tricky and requires
to be able to reconstruct a valid instance of the object from scratch, should
an exception be thrown. Of course, this is not possible in the general case as
not all classes are default-constructible.

Note that if `T` is trivially
relocatable, then the operator is as optimal as we would like, as it merely
translates into a destructor call and a memcpy call.

NOTE: If the assignment operator needs no further logic than a simple memberwise
assignment, then users should instead use the defaulted version of the operator
as it will provide better exception safety for similar performance.

**relocate-and-swap**

```c++
T& T::operator=(T src)
{
    using std::swap;
    swap(*this, src);
    return *this;
}
```

This version is exception-safe, although it may not be the most efficient approach.

Should `std::swap` be optimized to perform memcpy on trivially relocatable
objects, then it results in one destructor call (`src`'s) and three memcpy calls.

**Union trick**

If for some reason, the implementation needs to prevent the destructor call
on the source object, it is still possible to perform the "union trick":

```c++
T& operator=(T src)
{
    union { T tmp } = { .tmp = reloc src; };
    /* do some stuff with tmp (like calling std::reloc_and_uninitialize),
     * knowing its destructor will not be called by the language */
    return *this;
}
```

### Invocation ### {#reloc-assign-invoke}

```c++
T x, y;
x = reloc y;
```

Every call to the relocation assignment operator follows normal rules.

If the call site detects that an eliding version of the operator is available
(either because the eliding happened at declaration level, or because it
happened at definition level and the call site is in the same
translation unit as the definition, or through link-time optimization),
then which version of the operator
is called is implementation-defined.

The nominal case is to call the non-eliding version. The implementation is allowed
to call the eliding version instead, as long as it can elide the call to the
destructor on the source object.

## Overload resolution ## {#overload-resolution}

The current overload resolution rules are not suitable for relocation by prvalue.

Indeed, consider the following scenario:
```c++
void bar(T&&); // same issue with: bar(T const&);
void bar(T);

void foo(T val)
{
    bar(reloc val); /* ambiguous call using today's rules */
}
```

Hence we propose a change in the overload resolution rules to prefer passing by
value for prvalue arguments.

Specifically, we would amend <a href="https://eel.is/c++draft/over.ics.rank#3.2.3">[over.ics.rank]/3.2.3</a> to read:

- neither of S1 and S2 bind a reference to an implicit object parameter of a
    non-static member function declared without a ref-qualifier, and either:
    - S1 binds an lvalue reference to an lvalue, and S2 does not, or:
    - S1 binds an rvalue reference to an xvalue, and S2 does not, or:
    - S1 does not bind a reference, and S2 binds a reference to a prvalue, or:
    - S1 binds an rvalue reference to a prvalue, and S2 binds an lvalue reference [Example:
        ```c++
        int i;
        int f1();
        int&& f2();
        ...
        int g2(const int&);
        int g2(int);
        int g2(int&&);
        int j2 = g2(i); // calls g2(const int&)
        int k2 = g2(f1()); // calls g2(int)
        int l2 = g2(f2()); // calls g2(int&&)
        ...
        ```
        &#45; end example]


### Comparison against P2665R0 ### {#overload-against-P2665R0}

[[P2665R0]] "Allow calling overload sets containing T, const T&" also proposes
to modify the overload resolution rules. It allows overload sets containing
both `T` and `T const&` to exist, and which overload is selected is
implementation-defined. The main motivation is for performance: "small" trivial
types, such as built-in integral types, are best passed by value than by
reference.

In what we propose, overload sets with `T`, `T const&` and `T&&` can also exist.
However, which is picked is (not *early destructible* objects left aside)
specified clearly by the standard
(depending on the value category of the parameter) and
not *implementation-defined*.

The `reloc` operator can be used to turn not-ref-qualified
automatic variables into prvalues, which allows the user to force the right
overload.

The only situation where the overload being selected is implementation-defined,
is when a function parameter passed by value is being relocated. Whether the
relocation constructor is considered in the overload resolution is
implementation-defined, as it depends on the ABI capabilities. Consider:

```c++
void foo(T);
void foo(T&&);

void bar(T value)
{
    foo(reloc value); /* always calls foo(T),
        but how foo's parameter is constructed
        is implementation-defined (reloc, move or copy ctor) */
}
```

In this example, `bar` will always call the `foo(T)` overload, as `reloc value`
is always a prvalue. However, the materialization of this prvalue is
implementation-defined, the relocation constructor being potentially
evicted.

NOTE: This proposal and P2665R0 can co-exist. Even with the updated overload
resolution rules that we propose, compilers may still be allowed to pick the
prvalue overload if they analyse it may bring a performance boost, as P2665R0
suggests.

## Structured decomposition ## {#structured-decomposition}

### Discussion ### {#structured-decomposition-discussion}

`auto [x, y] = foo(); sink(reloc y);` is ill-formed given the rules we
established for `reloc`. `x` and `y` are not complete objects but aliases to
some anonymous object which the language creates behind the scene.

As this proposal aims to provide support for relocate-only types, this support
would be partial, if not impractical, without allowing some form of
relocation from a structured binding.

In our experience, most C++ developers believe that a structured binding is
a complete, separate object, and not a name alias to some subobject. As such
it would feel unnatural for them if they cannot relocate from a structured binding.

We propose "structured decomposition" as an alternative to structured bindings.
Instead of binding the subobjects of the initializer (`foo()` in the example)
to the new identifiers, the initializer is *decomposed* into the new identifiers.
The new identifiers, being individual complete objects, can then be relocated.

### Structured decomposition declaration ### {#structured-decomposition-declaration}

A structured decomposition declaration is syntactically identical to a structured
binding, with the exception that no ref-qualifiers are allowed after the `auto`
type specifier.

```c++
T foo();
T const& bar();
T foobar();

// [...]

auto [x, y] = foo(); // matches structured decomposition declaration
auto const [w, z] = bar(); // matches structured decomposition declaration
auto&& [a, b] = foobar(); // structured bindings will be used
```

The structured decomposition declaration further requires that the type of the
expression that is used to initialize it
supports any of the [structured decomposition protocol](#structured-decomposition-obj-decomposition).
**If not, then the declaration is simply a structured bindings declaration and will
follow structured bindings rules.**

### Structured decomposition protocols ### {#structured-decomposition-obj-decomposition}

As there are three binding protocols for structured bindings, there are likewise
three "structured decomposition" protocols. If none
of those protocols match, then the declaration is not a
structured decomposition declaration, and structured bindings are considered.

The protocols are tested in the following order:

1. The *array* protocol ;
2. The *get_all* protocol ;
1. The *data members* protocol ;

In what follows, let `E` be the type of the initializer expression (the type
of the expression used to initialize the structured decomposition).

- If `E` is a glvalue, then let `S` be the same as `E`, but deprived of its
    ref-qualifiers.
    If one of the three protocols applies, then an anonymous object of type `S` is
    constructed from the initializer, using the appropriate constructor.
    This anonymous object will be considered as the prvalue source object ;
- Otherwise (`E` is a prvalue), then let `S` be the same as `E`. The initializer
    expression will be used as source object.

#### array protocol #### {#structured-decomposition-array}

The *array* protocol is quite similar to that of structured bindings.
For this protocol to apply, all the following conditions must be satisfied:

- `S` must be an array-type of known bound ;
- the number of identifiers must equal the number of array elements ;

If this protocol applies, then the *i*-th identifier is constructed by
relocation, move or copy constructor using the *i*-th array element as source object.

```c++
void foo()
{
    std::string const strs[3] = { /* ... */ };
    // [...]
    auto const [str1, str2, str3] = reloc strs;
    bar(reloc str2);
}
```

#### get_all protocol #### {#structured-decomposition-get_all}

The function `get_all(S)` is looked-up using ADL-lookup. If there is
no match, then this protocol does not apply.

If there is a match, then this function is called (copy-elision will happen,
`S` prvalue will share the same address as `get_all` parameter slot).
The returned type is tested recursively:

1. If *get_all* matches for the returned type, then we reapply it again ;
2. If *data members* protocol matches for the
    returned type, then it is applied ;
3. If no protocol matches for the returned type, then the expression is
    **ill-formed** (structured bindings is not tried).

This follows the same recursive logic as `operator->()`.
We recursively call `get_all` as long as the *get_all* protocol applies.
When the recursion ends, we end up with a type which
matches the *data member* protocol, or else the expression is ill-formed.

NOTE: If there are concerns that `get_all(S)` may clash with existing functions,
then other names may be used, such as `__get_all__` or `__decompose__`.

#### data members protocol #### {#structured-decomposition-dm}

The *data members* protocol is also similar to that of structured bindings.
For this protocol to apply, all the following conditions must be satisfied:

- every non-static data member of `S` must be a direct member of `S` or of the same
    base class of `S` ;
- the number of identifiers must equal the number of non-static data members ;
- `S` may not have an anonymous union member ;
- *specific to structured decomposition:* for every base class, between `S` and the base
    class the data members are found in, its decomposition is [well-formed](#ill-formed-decomposition).

If this protocol applies, then the *i*-th identifier is constructed as if by
`reloc s::i`, `s` being the decomposed base class holding all the data members
and `i` the *i*-th identifier.

#### Implementation-defined library support #### {#structured-decomposition-tuple}

`std::pair`, `std::tuple`, and `std::array` shall provide their own implementation
of `get_all`. The return type is implementation-defined (may rely on compiler magic).

This allows us to write things like:
```c++
void bar(T);
void foo(std::vector<T>& v)
{
    /* This code uses a putative vector::pilfer(const_iterator) (not proposed),
     * which removes a vector element at given iterator, and
     * returns a pair with next valid iterator and relocated vector element. */
    auto [val, it] = v.pilfer(v.begin() + 1); /* calls get_all behind
        the scene. */
    bar(reloc val); /* can call reloc on val as it is not a structured binding */
}
```

This code works even if `T` is relocate-only.

#### Possible get_all implementations #### {#structured-decomposition-implem}

Thanks to `std::tuple`'s `get_all` we can easily write
a `get_all` implementation for a custom class:

```c++
class MyType
{
public:
    MyType();
    MyType(MyType);

    // Possible implementation:
    auto get_all(this MyType self reloc)
    {
        return std::tuple{reloc self::_name, self::_flag,
            !self::_nodes.empty()};
    }

private:
    std::string _name;
    bool _flag;
    std::vector<Node*> _nodes;

};
```

The implementation relies on a putative new constructor for `std::tuple`
(not proposed) which captures the tuple elements by value category,
which allows to relocate objects into a tuple.

Then, in the following snippet:
```c++
MyType tp;
auto [name, flag, nodes] = reloc tp;
// equivalent to: auto [name, flag, nodes] = get_all(get_all(reloc tp));
```

`MyType`'s `get_all` returns a tuple. `get_all` is defined for tuples as well, so
it is called again. The second return type won't have a `get_all` defined, hence
the recursion stops and the *data member* protocol is used.

# Proposed library changes # {#proposed-lib-changes}

NOTE: Adding support for relocation in the STL is another major change.
What we are proposing to add for the moment is the bare minimum to allow
library writers to benefit from relocation. Support for relocation in the STL
will be done in a separate proposal, depending on whether the work on this
proposal is pursued.

## Memory header ## {#std-mem-header}

### std::construct_at ### {#std-construct_at}

We propose to add the following overload to `std::construct_at`:

```c++
template<class T>
constexpr T* construct_at( T* p, T src );
```

Which would be equivalent to `::new (p) T{reloc src}`, except that it may be
used in constant expression evaluations.

Note: this overload would be unnecessary if the [[#future-capture-value]]
direction were to be adopted; instead the existing signature should be
altered to use the `decltype(Args)...` placeholder.

### std::reloc_and_uninitialize and std::reloc_and_reclaim ### {#std-reloc_and_uninitialize}

We propose to add the following functions in the `std` namespace in the `memory`
header to perform relocation through a pointer:

```c++
template <class T>
std::remove_cv_t<T> reloc_and_uninitialize(T* src);
template <class T>
std::remove_cv_t<T> reloc_and_reclaim(T* src);
```

Both functions construct a new object by calling either the relocation constructor,
the move constructor or the copy constructor,
using `*src` as parameter while ignoring its cv-qualifiers, and return it.
They also ensure the end-of-life of the source object: if the move or copy
constructor is called then the destructor of `*src` is called afterwards.

NOTE: If `*src` is a polymorphic type, that the relocation constructor is selected in
the overload resolution,
and the relocation constructor is virtual,
then a virtual relocation constructor call is performed from the dynamic type of `*src`.

`reloc_and_uninitialize` leaves the memory that was occupied by `src` in an
uninitialized state.  If any exception is thrown,
then `reloc_and_uninitialize` is guaranteed to leave the source object in a
destructed state.

`reloc_and_reclaim` reclaims the memory by calling the appropriate deallocation
function (class-defined `delete` or global `delete`). If any exception is thrown,
then `reloc_and_reclaim` is guaranteed to leave the source object in a destructed
state and to have deallocated its memory.

`reloc_and_uninitialize` is intended to be used by library authors to enable relocation
from a memory address. For instance, extracting a value out of an optional just
becomes:

```c++
T optional<T>::extract()
{
    _has_value = false;
    return std::reloc_and_uninitialize(_value_addr());
    // _value_addr() being a private function returning the address of the owned value
}
```

Of course, this function is not intended to be used on local objects. Hopefully
its name should prevent misuses.

```c++
void foo()
{
    const T val;
    bar(std::reloc_and_uninitialize(&val)); /* BAD, val destructor is called at the
        end of its scope while it is already destructed!*/
}
```

`reloc_and_reclaim` is intended to be used by end users and library vendors alike.

```c++
unique_ptr<pair<string, reloc_only_t>> makeStuff();

reloc_only_t getRelocOnly()
{
    auto stuff = makeStuff();
    auto [str, relocOnly] = std::reloc_and_reclaim(stuff.release());
    return relocOnly;
    // or the short version:
    // return std::reloc_and_reclaim(makeStuff().release()).second;
}
```

### std::uninitialized_relocate ### {#std-uninitialized_relocate}

We propose to introduce the following new functions in the `std` namespace in
the `memory` header:

```c++
template<class InputIt, class ForwardIt>
ForwardIt uninitialized_relocate(InputIt first, InputIt last, ForwardIt d_first);

template<class ExecutionPolicy, class InputIt, class ForwardIt>
ForwardIt uninitialized_relocate(ExecutionPolicy&& policy, InputIt first, InputIt last,
    ForwardIt d_first) ;

template<class InputIt, class Size, class ForwardIt>
pair<InputIt, ForwardIt> uninitialized_relocate_n(InputIt first, Size count,
    ForwardIt d_first) ;

template<class ExecutionPolicy, class InputIt, class Size, class ForwardIt>
pair<InputIt, ForwardIt> uninitialized_relocate_n(
    ExecutionPolicy&& policy, InputIt first, Size count, ForwardIt d_first);
```

Those relocate elements from the range `[first, last)` (or the first `count`
elements from `first`) to an uninitialized memory area beginning at `d_first`.
Elements in the source range will be destructed at the end of the function
(even if an exception is thrown).

Returns:

- `uninitialized_relocate`: an iterator to the element past the last element relocated;
- `uninitialized_relocate_n`: a pair whose first element is an iterator to the
    element past the last element relocated in the source range, and whose second
    element is an iterator to the element past the last element relocated in the
    destination range.

If the type to relocate is trivially relocatable and both iterator types are
contiguous, then both functions can be implemented as single `memcpy` call over
the entire source range.
Otherwise relocation happens element-wise, as if by calling `std::reloc_and_uninitialize`
on each element.

If an exception is thrown by `std::reloc_and_uninitialize`, then the destructor of all
remaining elements in the source range is called, as well as the destructor of
all constructed objects in the output iterator.

## Type traits header ## {#std-type_traits-header}

We propose to introduce the following type traits, which all derive from
`std::true_type` or `std::false_type`
accordingly:

- `std::is_relocation_constructible<T>`: same as `std::is_constructible<T, T>` ;
- `std::is_trivially_relocation_constructible<T>`: same as
    `std::is_trivially_constructible<T, T>` ;
- `std::is_nothrow_relocation_constructible<T>` same as
    `std::is_nothrow_constructible<T, T>` ;
- `std::is_relocation_assignable<T>`: same as `std::is_assignable<T, T>` ;
- `std::is_trivially_relocation_assignable<T>`: same as `std::is_trivially_assignable<T, T>` ;
- `std::is_nothrow_relocation_assignable<T>`: same as `std::is_nothrow_assignable<T, T>` ;
- `std::has_virtual_relocation_constructor<T>`: derives from `std::true_type`
    if and only if `T` declares (maybe implicitly) a virtual or overridden
    relocation constructor.
    Derives from `std::false_type` otherwise ;
- `std::is_decomposable<T>`: derives from `std::true_type`
    if and only if `std::is_class_v<T>` is true, and `T` decomposition is legal ;
    Derives from `std::false_type` otherwise ;

For all new type traits, the inline constexpr boolean template variable counterparts
are also proposed. For instance we propose to introduce:
```c++
template< class T >
inline constexpr bool is_relocation_constructible_v = is_relocation_constructible<T>::value;
// along with the rest
```

# Discussions # {#discuss}

## Potential ABI changes ## {#abi}

As noted above ([[#early-destructible]]), some platforms have a *caller-destroy* ABI
where the *calling* function expects to destroy nontrivial parameters passed by
value. This poses a problem for functions that wish to relocate from such
parameters, and a potential ABI break.

### relocate-only function parameters ### {#callee-destroy-abi}

In the [case study](#reloc-with-function-param) of how `reloc` should behave
with function parameters passed by value, we established the following rule:

> **Rule:** If the source object is a function parameter passed by value, and its
type provides an eligible move constructor, then the relocation constructor
(if any) may be discarded during overload resolution. Whether the relocation
constructor is discarded is implementation-defined.

If the ABI is not already compliant, then this rule will force an ABI change
on functions which have parameters passed by value,
and whose type declares a relocation constructor but no move constructor.

The good news is as of today, there are no such types, so no existing function
should suffer from an ABI break. However, some types may accidently gain a relocation
constructor and may trigger an ABI break nonetheless.

In a future library changes proposal to support relocation (separate from this one),
we must be careful not to
make any existing type relocate-only, especially for that concern.
However we will add a relocation constructor on many classes, alongside their
existing copy and move constructors. In doing so,
some of them may fit the criteria for ABI break, should their copy and move constructors
be deleted (for instance `std::optional<T>` with `T` being relocate-only).

One example is a function with signature: `void foo(gsl::non_null<std::unique_ptr<int>>);`,
supposing `unique_ptr` gets a relocation constructor.
In turn GSL developers will
likely add a relocation constructor too. That makes `gsl::non_null<std::unique_ptr<int>>`
relocate-only, while it wasn't before, and may cause a potential ABI break.

There is zero value of passing a `gsl::non_null<std::unique_ptr>` by value
to a function today, so we doubt anyone would write such a function.
However those functions might theoritically exist, and might have an ABI change.

Also, library vendors are encouraged to migrate to an ABI where any function that
takes non-trivial parameters by value are responsible for their destruction.
Then, the function definitions can make the most of `reloc`.
This is not required by the proposal.

We believe it's up to the implementation to choose what they want to do with their ABI:
- *full break*, use callee-destroy or equivalent for all non-trivial relocatable types
    passed by value (for those who don't care about ABI) ;
- *break with opt-out*: a relocation constructor attribute to opt-out of the ABI
    break on functions where it is passed be value.
    This solution should also provide propagation mechanisms suitable for composition
    (these could be standardized at a later date) ;
- *likely no break, but opt-in*: an improved `[[trivial_abi]]` that actually checks that
    the type is trivially relocatable ;
-Â *likely no break*: use callee-destroy only for relocatable but immovable types ;
- and those that are callee-destroy already don't need to do anything!

In all cases the following mitigation and migration techniques could be employed:

- functions that have an ABI change could be mangled differently. This makes
    ABI breakage detectable ;
- for such functions, up to two symbols are emitted, where the old
    symbol is emitted only if the function does not in actual fact relocate from
    its parameters, in which case the new symbol is emitted, and its implementation
    forwards to the old and then destructs its relocatable parameters on exit ;

Last, this potential breakage was discussed on
[Itanium ABI github](https://github.com/itanium-cxx-abi/cxx-abi/issues/187),
although we didn't get much feedback.

### prvalue assignment operator ### {#prvalue-assign-op-abi}

As mentioned above, if the class-type is relocatable but immovable, then it may have an
impact on existing prvalue-assignment operators (like it does to any function).
However this change is purely opt-in. If there is an existing prvalue-assignment
operator in a class, then it will prevent the implicit declaration of the
relocation constructor, which will in turn prevent from the potential ABI break.

Also, the relocation assignment operator may be aliased.
If aliasing occurs, then the ABI does not break as aliasing happens only on a
new hidden function.

The only scenario where the ABI might break is where:

- aliasing happened on declaration level ;
- code was compiled against it, and especially generated code that makes direct
    calls to the aliased version ;
- the class changes, the aliasing only happens at definition level, or does not happen at all.

This may introduce an ABI break, detectable at link-time (aliased symbols missing):

- if the aliasing now happens at definition level, but the aliased operator symbol
    remains visible nonetheless, then no ABI breaks are introduced ;
- otherwise the ABI break happens, but remains detectable at link-time.

## Object decomposition alternatives ## {#object-decomposition-alt}

In R3, object decomposition took the form of "decomposing functions". An object
could only be decomposed through a member function:

```c++
class T {
    // [..]
    auto extract(this T reloc) { return _obj; }
private:
    reloc_only_t _obj;
};
```

This had drawbacks:

- As objects could only be decomposed through member functions, it implied that:
    - Decomposition had to happen through a dedicated function ;
    - Decomposition had to happen within the class-type ;
- It was hard to decompose more than one object at a given time ;
- This used a weird syntax to access base classes: `reloc B`, with `B` being
    a base class.

We wanted decomposition to be more convenient to use, as it is an intrinsically
close concept to relocation. It took several attempts to reach what we propose
in this paper.

### The dot-reloc operator ### {#dot-reloc-take-1}

We studied for a while a putative *dot-reloc* operator: `p.reloc first`.
The first time the expression was evaluated, the object used as the left operand
would become decomposed, and the subobject used as the right operand would be relocated.
Once decomposed, the source object could no longer be used normally. We
restricted the expressions where a decomposed object would be allowed down to:

- data member access ;
- cast to base class ;
- base member function call ;

For instance:

```c++
pair<string, string> p = getPair();
if (test()) {
    foo(p.reloc first); // p is now decomposed, p.first is relocated
    bar(p.second); // ok
}
foobar(p); // ko: p may be decomposed
```
And it could even work with pointer to data-members, given that they were
constant-evaluated:
```c++
template <auto DataMember>
string Get(pair<string, string> p)
{
    return p.*reloc DataMember;
}
```

This approach proved quite convenient to use. However it suffured from much added
complexity:
1. the code could be hard to follow because objects would be decomposed only when
    the first `.reloc` operator was evaluated ;
1. the static information of the object (for instance, whether some expressions
    involving the object are valid), which are supposed to remain
    unchanged during the program ... would change when the first `.reloc`
    operator was evaluated ;
1. relocating a base class still has the unusual syntax: `src.reloc BaseClass` ;
1. lots of new rules to learn on how to handle a decomposed object ;
1. would complicate code parsing, as the validity of an id-expression designing an
    object would depend on the surrounding expressions, should this object
    be decomposed or potentially decomposed.

This motivated us to make a second attempt with the *dot-reloc* operator.

### The dot-reloc operator (take 2) ### {#dot-reloc-take-2}

The second take of the *dot-reloc* operator was close to the first.
The only change was that the object was decomposed from the moment of its declaration,
by specifing `reloc`. Then, the *dot-reloc* operator could only be used on a
decomposed object.

For instance:

```c++
pair<string, string> p reloc = getPair();
if (test()) {
    foo(p.reloc first); // ok as p was decomposed, p.first is relocated
    bar(p.second); // ok
}
foobar(p); // ko: p is decomposed
```

However this did not fix the concerns (3), (4) and (5) raised above. First and
foremost, a decomposed object almost felt like a new value category in disguise.
This discouraged us to pursue the *dot-reloc* operator any further.

### The proposed approach ### {#dot-reloc-no-longer}

We learned from the fact that the decomposed object still being accessible
caused lots of issues. From this conclusion, we built the object decomposition
feature as it is proposed in this paper. The decomposed object is no longer
an accessible object but is instead a new namespace housing all its subobjects.

This approach addresses all the points raised above, while still being
convenient to use. There is one aspect where it compares unfavorably to *dot-reloc*,
is that we cannot relocate a subobject from a pointer to data member, or from a
base class whose name is passed as a template type parameter:
```c++
template <string T::*_str>
string GetStr(T obj reloc)
{
    return obj::*_str; // invalid expression
}
template <class B>
B GetBase(T obj reloc)
{
    return obj::B; // invalid expression
}
```

However we believe this to be minor issues, which can still be fixed with a
future proposal should there be a need for it.

## Why a new keyword? ## {#reloc-new-keyword}

Alternatively, a new series of symbols could be used instead of introducing
a new keyword, like: `<~< obj` or `&< obj` in place of `reloc obj`.
However, we feel like `reloc obj` better conveys the intent, and has better
readibility.

The introduction of a new keyword may always break existing codebases. We had a
look at several well-known open source C++ projects to analyse what volume of code
would break if `reloc` were a keyword.

For each of the following repositories, we searched for the `reloc` string,
at word boundaries, with case-sensitivity, in all C++ source files and headers
(`*.cc`, `*.cpp`, `*.cxx`, `*.h`, `*.hpp`, `*.hh`).
We manually discarded matches that
were not code (comments or strings). And we put that in perspective with the
total number of files, lines and words of the repository.

- [Qt](https://github.com/qt/qtbase): 0 hits; files:  7,586 ; lines:  2,794,607 ;
    words:  98,635,622; commit: 040b4a4b21b3
- [boost](https://github.com/boostorg/boost) (with all submodules): 0 hits;
    files:  23,726 ; lines:  4,133,844 ;
    words:  180,808,943; commit: 86733163a3c6
- [godot](https://github.com/godotengine/godot): 0 hits; files:  5,068 ;
    lines:  2,545,299 ;
    words:  99,389,743; commit: b6e06038f8a3
- [abseil-cpp](https://github.com/abseil/abseil-cpp): 0 hits; files:  766 ;
    lines:  247,441 ;
    words:  9,028,820; commit: de6fca2110e7
- [folly](https://github.com/facebook/folly): 0 hits; files:  1,861 ;
    lines:  532,918 ;
    words:  16,669,085; commit: cde9d22e8614
- [llvm-project](https://github.com/llvm/llvm-project): **124 hits in 11 files**
    (`reloc` only used as local variable or
    data member, counting all uses); files:  39,048 ; lines:  9,760,587 ;
    words:  385,429,611; commit: 9816c1912d56
- [gcc](https://github.com/gcc-mirror/gcc): **244 hits in 31 files**
    (`reloc` only used as local variable or
    data member, counting all uses); files:  15,337 ; lines:  4,616,875 ;
    words:  146,146,684; commit: ee6f262b87fe
- [rapidjson](https://github.com/Tencent/rapidjson): 0 hits; files:  96 ;
    lines:  39,828 ; words:  1,492,060;
    commit: a98e99992bd6
- [googletest](https://github.com/google/googletest): 0 hits; files:  155 ;
    lines:  85,703 ; words:  3,104,817;
    commit: 71140c3ca7a8
- [yaml-cpp](https://github.com/jbeder/yaml-cpp): 0 hits; files:  259 ;
    lines:  112,513 ; words:  3,784,676;
    commit: 1b50109f7bea
- [flatbuffers](https://github.com/google/flatbuffers): 0 hits; files:  175 ;
    lines:  98,163 ; words:  3,851,726;
    commit: e0d68bdda2f6
- [MongoDB](https://github.com/mongodb/mongo): **22 hits in 6 files**
    (`reloc` only used as local variable,
    counting all uses); files:  20,054 ; lines:  6,439,465 ; words:  265,329,429;
    commit: 73b7a22328c7
- [OpenCV](https://github.com/opencv/opencv): 0 hits; files:  3,315 ;
    lines:  1,556,606 ; words:  58,339,686;
    commit: 9627ab9462a4
- [electron](https://github.com/electron/electron): 0 hits; files:  698 ;
    lines:  99,717 ; words:  3,431,787;
    commit: 644243efd61b
- [mold](https://github.com/rui314/mold): 0 hits; files:  813 ; lines:  262,560 ;
    words:  9,992,769; commit: a45f97b47430
- [ClickHouse](https://github.com/ClickHouse/ClickHouse): 0 hits; files:  5,566 ;
    lines:  1,128,735 ; words:  68,112,047; commit: d42d9f70c812;
- [Dlib](https://github.com/davisking/dlib): 0 hits; files:  1,421 ;
    lines:  533,513 ; words:  19,080,728; commit: a12824d42584
- [&#83;FML](https://github.com/SFML/SFML): 0 hits; files:  532 ; lines:  168,787 ;
    words:  7,272,946; commit: 9bdf20781819
- [Kodi](https://github.com/xbmc/xbmc): 0 hits; files:  4,360 ; lines:  1,008,255 ;
    words:  34,114,229; commit: b228c778668f
- [Beast](https://github.com/boostorg/beast): 0 hits; files:  473 ;
    lines:  145,193 ; words:  4,768,152; commit: 334b9871bed6
- [JSON for modern C++](https://github.com/nlohmann/json): 0 hits; files:  450 ;
    lines:  137,679 ; words:  5,210,982; commit: 4c6cde72e533
- [IncludeOS](https://github.com/includeos/IncludeOS): 0 hits; files:  841 ;
    lines:  107,582 ; words:  2,903,698; commit: 99b60c782161
- [SerenityOS](https://github.com/SerenityOS/serenity): **15 hits in 2 files**
    (`reloc` only used as local variable, counting all uses); files:  5,538 ;
    lines:  887,768 ; words:  31,766,641; commit: 97dde51a9b3f

Repository statistics are computed with the following command:
```bash
find -type f \( -name '*.h' -or -name '*.hh' -or -name '*.hpp' -or -name '*.cc' \
    -or -name '*.cpp' -or -name '*.cxx' \) -exec wc -l -c {} \; \
    | awk '{ f+=1 } { l += $1 } { w += $2 } END { print "files: ", f, "; lines: ", l, "; words: ", w }'
```

As you can see, in the vast majority of cases, `reloc` is not used at all.
The impact seems to be minimal, where only a few files might need to be fixed
here and there. To smooth the transition, compilers may also warn that existing
code will break as `reloc` will become a keyword in a next C++ version.

## Future directions ## {#future-directions}

We removed some of the changes we initilialy had in mind, to keep for future
extensions. This proposal aims to be the bare minimum to bring support for
relocate-only types.

### More perfect forwarding ### {#future-capture-value}

Currently, "perfect forwarding" is built on top of *universal references*, requiring
an understanding of reference-collapsing and the use of `std::forward`. The present
proposal improves on this by incidentally replacing `std::forward` with `reloc`, but
at the same time the situation is worsened by making relocate-only types viable;
such types cannot be relocated when passed by universal reference.

<table>
<tr><th>Before</th><th>After</th></tr>
<tr>
<td>
```c++
template <class... Args>
void fwd(Args&&... args)
{
    do_stuff(std::forward<Args>(args)...);
}
```
</td>
<td>
```c++
template <class... Args>
void fwd(Args&&... args)
{
    do_stuff(reloc args...);
}
```
</td>
</tr>
</table>
<br/>
<table>
<tr><th>Future</th></tr>
<td>
```c++
template <class... Args>
void fwd(decltype(Args)... args)
{
    do_stuff(reloc args...);
}
```
</td>
</tr>
</table>

We suggest a new way to deduce template type parameters, by allowing
`decltype(T)` in the function parameters (only if `T` is a function template
type parameter). With this addition,
it would become possible to deduce each parameter to value, lvalue
reference or rvalue reference according to whether the argument is of
value category prvalue, lvalue or xvalue, and forward by relocation.

### discarded reloc expression ### {#solve-discarded-reloc-expr}

Initilialy, discarded reloc expressions such as `reloc obj;` would simply
translate to a call to the destructor of `obj`, while ensuring that the
destructor won't be called again at the end of its scope.

However this is hardly possible at the moment because of all the different ABIs
that exist. If `obj` is not *early destructible*, then the function cannot elide
the destructor call of `obj` that will happen on the caller-side.

We wanted the well-formedness of the code above all else (i.e. `reloc obj;` could
not be well-formed on some implementations and not in others). As such,
in this proposal, `reloc obj;` is only well-formed if `obj` is
relocatable, movable or copyable.

Hence, the best we can do if `obj` is not *early destructible*,
is to move-construct a temporary, and destruct
it right after, which will trigger the desired side-effects of the destructor
(e.g. release a lock if `obj` is a `unique_lock`).
The destructor of `obj` will still be called when the function
returns, but will likely do nothing as the object will be in a moved-from state.

A future proposal could make `reloc obj;` to just call the destructor,
regardless of whether `obj` is *early destructible* and of its constructors,
solving those ABI issues.

## Will it make C++ easier? ## {#easier-cpp}

This proposal introduces a new keyword, and a bunch of new concepts
(relocation constructor, decomposition), which are additional things to teach.
However we have hopes this proposal will improve the language on many areas
and eradicate some gotchas:

- support for relocation-only types, which allow for better class design
    with stronger class invariants ;
- `reloc` aims to fix the "moved-from state" understanding problem,
    and the used-after-move errors ;
- relocation fixes the `const` pessimization with move constructor ;
- `reloc` creates more opportunities to declare constant variables, improving on
    code readability and performance.

<pre class=biblio>
{
  "P1144R8": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "std::is_trivially_relocatable",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p1144r8.html",
    "date": "May 2023"
  },
  "P0023R0": {
    "authors": [ "Denis Bider" ],
    "title": "Relocator: Efficiently moving objects",
    "href": "http://open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0023r0.pdf",
    "date": "April 2016"
  },
  "N4158": {
    "authors": [ "Pablo Halpern" ],
    "title": "Destructive Move",
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4158.pdf",
    "date": "October 2014"
  },
  "P1029R3": {
    "authors": [ "Niall Douglas" ],
    "title": "move = bitcopies",
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1029r3.pdf",
    "date": "January 2020"
  },
  "P0308R0": {
    "authors": [ "Peter Dimov" ],
    "title": "Valueless Variants Considered Harmful",
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0308r0.html",
    "date": "March 2016"
  },
  "IIFE": {
    "authors": [ "Bartlomiej Filipek" ],
    "title": "IIFE for Complex Initialization - C++ Stories",
    "href": "https://www.cppstories.com/2016/11/iife-for-complex-initialization/",
    "date": "October 2016"
  },
  "D2839R1": {
    "authors": [ "Brian Bi", "Joshua Berne" ],
    "title": "Nontrivial Relocation via a New owning reference Type",
    "href": "https://isocpp.org/files/papers/D2839R1.html",
    "date": "June 2023"
  },
  "P2665R0": {
    "authors": [ "Bengt Gustafsson" ],
    "title": "Allow calling overload sets containing T, const T&",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2665r0.pdf",
    "date": "October 2022"
  }
}
</pre>
